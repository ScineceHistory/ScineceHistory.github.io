<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sh2zqp</title>
  <subtitle>Keep Learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-10-07T13:06:10.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>QinPeng Zhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android的沉浸式状态栏</title>
    <link href="http://yoursite.com/2016/10/07/Android%E7%9A%84%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    <id>http://yoursite.com/2016/10/07/Android的沉浸式状态栏/</id>
    <published>2016-10-07T02:58:55.000Z</published>
    <updated>2016-10-07T13:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Android 5.0发布了Material Design(MD)，App要尽可能遵从MD设计原则，本文就其中的沉浸式状态栏这一特性，描述其兼容到4.4的实现，以及一些小细节。</strong></p>
<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><blockquote>
<p>在4.4之前状态栏一直是黑色的，在4.4中带来了 windowTranslucentStatus 这一特性，因此可以实现<strong>给状态栏设置颜色</strong>，如下图所示，状态栏颜色不再是黑色，而是可以定制的颜色。</p>
</blockquote>
<p><img src="http://ac-qygvx1cc.clouddn.com/e61aeb3f3cc44354.png" alt=""></p>
<blockquote>
<p>我们将<strong>状态栏变色</strong>叫做<strong>沉浸式状态栏</strong>，这是种默认叫法，实际是「透明栏」（Translucent Bars）。</p>
</blockquote>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>4.4及其以上都是可以实现沉浸式状态栏效果的，5.0及其以上可以直接在主题中设置颜色，或者调用 Window 类中的 setStatusBarColor(int color) 来实现，这两种方式在5.0上都比较简单，但是如何兼容到4.4呢？</li>
<li>图片背景的页面,怎样让状态栏透明或者半透明（效果如下）？</li>
</ul>
<p><img src="http://ac-qygvx1cc.clouddn.com/74a963666851b9bd.png" alt=""></p>
<ul>
<li>使用 DrawerLayout 时，主界面实现沉浸状态栏同时，怎样保证抽屉视图也能延伸到状态栏（如下图所示），且兼容到4.4？</li>
</ul>
<p><img src="http://ac-qygvx1cc.clouddn.com/9585eb130bb180b5.png" alt=""></p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><ul>
<li>给状态栏设置颜色<ul>
<li>先设置状态栏透明属性；</li>
<li>给根布局加上一个和状态栏一样大小的矩形View（色块），添加到顶上；</li>
<li>然后设置根布局的 FitsSystemWindows 属性为 true,此时根布局会延伸到状态栏，处在状态栏位置的就是之前添加的色块，这样就给状态栏设置上颜色了。</li>
</ul>
</li>
</ul>
<p><strong>代码如下</strong></p>
<pre><code>/**
     * 设置状态栏颜色
     *
     * @param activity 需要设置的activity
     * @param color    状态栏颜色值
     */
    public static void setColor(Activity activity, int color) {
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
            // 设置状态栏透明
            activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
            // 生成一个状态栏大小的矩形
            View statusView = createStatusView(activity, color);
            // 添加 statusView 到布局中
            ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();
            decorView.addView(statusView);
            // 设置根布局的参数
            ViewGroup rootView = (ViewGroup) ((ViewGroup) activity.findViewById(android.R.id.content)).getChildAt(0);
            rootView.setFitsSystemWindows(true);
            rootView.setClipToPadding(true);
        }
    }
</code></pre><p><strong>其中生成状态栏一样大小的矩形色块的代码如下</strong></p>
<pre><code>/**
 * 生成一个和状态栏大小相同的矩形条
 *
 * @param activity 需要设置的activity
 * @param color    状态栏颜色值
 * @return 状态栏矩形条
 */
private static View createStatusView(Activity activity, int color) {
    // 获得状态栏高度
    int resourceId = activity.getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;);
    int statusBarHeight = activity.getResources().getDimensionPixelSize(resourceId);

    // 绘制一个和状态栏一样高的矩形
    View statusView = new View(activity);
    LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
            statusBarHeight);
    statusView.setLayoutParams(params);
    statusView.setBackgroundColor(color);
    return statusView;
}
</code></pre><blockquote>
<p>在 setContentView() 之后调用 setColor(Activity activity, int color) 方法即可</p>
</blockquote>
<ul>
<li>图片作背景时，状态栏透明</li>
</ul>
<blockquote>
<p>这个实现比较简单，根布局背景设置为图片，然后添加状态栏透明 Flag， 然后设置根布局的 FitsSystemWindows 属性为 true 即可。代码如下：</p>
</blockquote>
<pre><code>/**
    * 使状态栏透明
    * &lt;p&gt;
    * 适用于图片作为背景的界面,此时需要图片填充到状态栏
    *
    * @param activity 需要设置的activity
    */
   public static void setTranslucent(Activity activity) {
       if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
           // 设置状态栏透明
           activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
           // 设置根布局的参数
           ViewGroup rootView = (ViewGroup) ((ViewGroup) activity.findViewById(android.R.id.content)).getChildAt(0);
           rootView.setFitsSystemWindows(true);
           rootView.setClipToPadding(true);
       }
   }
</code></pre><blockquote>
<p>同样的，在 setContentView() 之后调用 setTranslucent(Activity activity) 方法即可</p>
</blockquote>
<ul>
<li>使用 DrawerLayout 时的特殊处理</li>
</ul>
<p><strong>注意点</strong></p>
<hr>
<h1 id="Android状态栏-Status-Bar-颜色"><a href="#Android状态栏-Status-Bar-颜色" class="headerlink" title="Android状态栏(Status Bar)颜色"></a>Android状态栏(Status Bar)颜色</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>Android在<strong>4.4</strong>版本推出一个<strong>透明状态栏</strong>的概念，使手机顶部的状态栏的颜色全透明。</li>
<li>在<strong>5.0</strong>版本推出了Material Design，可以修改状态栏颜色。</li>
<li>所以4.4之前的版本是无法设置状态栏颜色的。</li>
</ul>
<p><strong>网易云音乐对比图</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/943889-46b3b462b299423b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li><p>版本大于4.4</p>
<p>  // 1.设置状态栏透明，经测试在代码里直接声明透明状态栏更有效<br>  WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes();<br>  localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags);<br>  // 2.在布局文件中，添加属性 android:fitsSystemWindows=“true”，设置背景色。</p>
</li>
<li><p>版本5.0以上，在Theme中设置属性colorPrimaryDark的颜色</p>
</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/Android5.0_MD_%E6%89%8B%E6%9C%BA%E5%90%84%E9%83%A8%E5%88%86%E9%A2%9C%E8%89%B2.png" alt=""></p>
<hr>
<h1 id="Android-实现变色状态栏"><a href="#Android-实现变色状态栏" class="headerlink" title="Android 实现变色状态栏"></a>Android 实现变色状态栏</h1><blockquote>
<p>什么是<strong>透明状态栏</strong>以及什么是<strong>沉浸式状态栏</strong>，以及其区别，国内习惯称透明状态栏为沉浸式状态栏，但是两者是有本质区别的。</p>
</blockquote>
<h3 id="什么是沉浸式模式"><a href="#什么是沉浸式模式" class="headerlink" title="什么是沉浸式模式"></a>什么是沉浸式模式</h3><blockquote>
<p>Android 4.4中，<strong>沉浸式体验</strong>得到了再次强化，提供了一种“全屏模式”(Full-screen Immersive Mode)。全屏模式又分两种，一种叫后撤式 (Lean Back)，另一种叫做沉浸式(Immersive)。后撤式已经在之前的系统中被广泛使用了——当你在优酷APP中观看视频时，大部分时间手指是不会去碰屏幕的。这种情况下，虚拟键和状态栏都会自动隐藏，但当你触摸屏幕的时候，它们又会出现。而新加入的沉浸式则不太一样，在沉浸式全屏状态下，对屏幕的操作并不会唤出系统栏。想要唤出系统栏，你必须从屏幕的上/下边缘向屏幕内划入。沉浸式的全屏状态更适合游戏和阅读这样的应用。</p>
<p>但<strong>沉浸模式</strong>和普通全屏不同点在于，沉浸模式通过下滑屏幕上方或者下方可以调出虚拟键和状态栏。 </p>
</blockquote>
<p><strong>比如多看阅读，下图是在阅读时沉浸模式下全屏</strong></p>
<p><img src="http://img.blog.csdn.net/20150911113240462" alt=""></p>
<p><strong>然后从屏幕上方下滑或者下方上划，虚拟键和状态栏出现了。但却是直接覆盖在程序文字上的</strong></p>
<p><img src="http://img.blog.csdn.net/20150911113249528" alt=""></p>
<blockquote>
<p>而<strong>沉浸式状态栏</strong>的来源就是很多手机用的是实体按键，没有虚拟键，于是开了<strong>沉浸模式</strong>就只有状态栏消失了。于是沉浸模式成了<strong>沉浸式状态栏</strong>。</p>
</blockquote>
<h3 id="什么是透明状态栏"><a href="#什么是透明状态栏" class="headerlink" title="什么是透明状态栏"></a>什么是透明状态栏</h3><blockquote>
<p>Android 4.4 一个很重要的改变就是透明系统栏.。新的系统栏是渐变透明的, 可以最大限度的允许屏幕显示更多内容, 也可以让系统栏和 Action Bar 融为一体, 仅仅留下最低限度的背景保护以免通知通知栏内容和 Action Bar 文字/图标难以识别。谷歌把这种效果称之为：Translucent Bar。<br>Translucent Bar 是 Android 对 Edge to Edge 尝试中的一个, 也是最容易被用户注意到的. 它的初始目的就是要最大化可视面积和淡化系统界面的存在感。</p>
<p>其实简单一点就是布局延伸到状态栏，状态栏背景与应用背景相同，这就是<em>透明状态栏</em>。最直接的例子就是UC浏览器的天气界面，其布局延伸到状态栏，但是状态栏与应用同背景，如图所示</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20150911113305613" alt=""></p>
<blockquote>
<p>但是这样有时候会把状态栏颜色变得和应用的背景颜色一样，但是实际上只是修改了状态栏的颜色，我们称它为<strong>变色状态栏</strong></p>
<p>而现在大家所在用的QQ等软件，状态栏与软件颜色融为一体，其实就是<strong>变色状态栏</strong>。而小米MIUI的自带应用，也都是变色状态栏或者是透明状态栏，而并非是<strong>沉浸式状态栏</strong>。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20150911113316465" alt=""></p>
<p><img src="http://img.blog.csdn.net/20150911113324758" alt=""></p>
<blockquote>
<p>这里我们姑且称<strong>变色状态栏</strong>为<strong>透明状态栏</strong>的一种，本篇文章就是带大家实现这种透明状态栏。</p>
<p>由于这种效果只有在4.4及以上有效，所以本篇文章的效果只有在4.4及以上有效。</p>
</blockquote>
<h3 id="实现透明状态栏"><a href="#实现透明状态栏" class="headerlink" title="实现透明状态栏"></a>实现透明状态栏</h3><ul>
<li><p>首先应用主题</p>
  <resources><br>      <style name="AppTheme" parent="@style/BaseTheme"><br>      </style><br>      <style name="BaseTheme" parent="Theme.AppCompat.Light.NoActionBar"><br>          <item name="colorPrimary">@color/colorPrimary</item><br>          <item name="colorPrimaryDark">@color/colorPrimaryDark</item><br>      </style><br>  </resources>
</li>
<li><p>然后在res下新建一个values-v19的目录，代表最低API为19，新建一个style.xml，下面的代码是透明状态栏的关键</p>
  <resources><br>      <style name="AppTheme" parent="@style/BaseTheme"><br>          <item name="android:windowTranslucentNavigation">true</item><br>          <item name="android:windowTranslucentStatus">true</item><br>      </style><br>  </resources>

</li>
</ul>
<blockquote>
<p>我们禁用了系统的ActionBar，使用ToolBar代替，布局代码如下</p>
</blockquote>
<pre><code>&lt;LinearLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:background=&quot;?attr/colorPrimary&quot;
        android:fitsSystemWindows=&quot;true&quot;
        &gt;&lt;/android.support.v7.widget.Toolbar&gt;
&lt;/LinearLayout&gt;
</code></pre><blockquote>
<p>细心的你会发现在Toolbar中加入了android:fitsSystemWindows=”true”属性，这就是将布局延伸到状态栏，这时候你运行一下，会发现Toolbar上移到了状态栏的位置。上移的高度刚好是状态栏的高度。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20150911113344905" alt=""></p>
<blockquote>
<p>但是我们并不想它移动到上面，只是想它状态栏和Toolbar颜色一样，要怎么做的，很简单，在代码中通过setSupportActionBar设置到ActionBar的位置即可。</p>
</blockquote>
<pre><code>Toolbar mToolbar = (Toolbar) findViewById(R.id.toolbar);
setSupportActionBar(mToolbar);
</code></pre><p><strong>之后的效果就是这样的</strong></p>
<p><img src="http://img.blog.csdn.net/20150911113356988" alt=""></p>
<blockquote>
<p>很明显的看到，ToolBar就是之前的高度，但是状态栏也变色了</p>
<p>但是我们又怎么能满足于此呢。在Android 5.0上，我们的状态栏的颜色是要比Toolbar的颜色要深的。就像这样。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20150911113406774" alt=""></p>
<blockquote>
<p>我们还要进一步修饰，需要对状态栏着色，这里需要用到一个开源库SystemBarTint</p>
</blockquote>
<p><strong>加入依赖</strong></p>
<pre><code>compile &apos;com.readystatesoftware.systembartint:systembartint:1.0.3&apos;
</code></pre><p><strong>之后再设置布局后加入以下代码</strong></p>
<pre><code>SystemBarTintManager tintManager=new SystemBarTintManager(this);
tintManager.setStatusBarTintResource(R.color.colorPrimaryDark);
tintManager.setStatusBarTintEnabled(true);
</code></pre><p><strong>最终效果就是上图所示</strong></p>
<blockquote>
<p>当然这个库里还有很多函数，具体功能自己去琢磨吧，并且其内部源码也并不复杂，建议还是看下其源码实现。</p>
</blockquote>
<hr>
<h1 id="Android-沉浸式状态栏攻略"><a href="#Android-沉浸式状态栏攻略" class="headerlink" title="Android 沉浸式状态栏攻略"></a>Android 沉浸式状态栏攻略</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>QQ新版的沉浸式状态栏</strong></p>
<p><img src="http://img.blog.csdn.net/20150922091410975" alt=""></p>
<blockquote>
<p>关于这个<strong>状态栏变色</strong>到底叫「Immersive Mode」/「Translucent Bars」有兴趣可以去<a href="https://www.zhihu.com/question/27040217" target="_blank" rel="external">这里看看</a>。</p>
<p>只有<strong>大于等于4.4</strong>版本支持这个<strong>半透明状态栏</strong>的效果，但是<strong>4.4和5.0</strong>的显示效果有一定的差异，所有本篇博文内容为：</p>
<ul>
<li>如何实现<strong>半透明状态栏效果</strong>在大于4.4版本之上。</li>
<li>如何让4.4的效果与5.0的效果尽可能一致。</li>
</ul>
</blockquote>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul>
<li>4.4 模拟器</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150922091443734" alt=""></p>
<ul>
<li>5.x 真机</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150922091513487" alt=""></p>
<h3 id="实现半透明状态栏"><a href="#实现半透明状态栏" class="headerlink" title="实现半透明状态栏"></a>实现半透明状态栏</h3><ul>
<li>colors.xml 和 styles.xml</li>
</ul>
<blockquote>
<p>定义几个颜色</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;color name=&quot;primary&quot;&gt;#FF03A9F4&lt;/color&gt;
    &lt;color name=&quot;primary_dark&quot;&gt;#FF0288D1&lt;/color&gt;
    &lt;color name=&quot;status_bar_color&quot;&gt;@color/primary_dark&lt;/color&gt;
&lt;/resources&gt;
</code></pre><blockquote>
<p>定义几个styles.xml</p>
</blockquote>
<p><strong>values/styles.xml</strong></p>
<pre><code>&lt;resources&gt;
    &lt;style name=&quot;BaseAppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
        &lt;!-- Customize your theme here. --&gt;
        &lt;item name=&quot;colorPrimary&quot;&gt;@color/primary&lt;/item&gt;
        &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/primary_dark&lt;/item&gt;
        &lt;item name=&quot;colorAccent&quot;&gt;#FF4081&lt;/item&gt;
    &lt;/style&gt;

    &lt;!-- Base application theme. --&gt;
    &lt;style name=&quot;AppTheme&quot; parent=&quot;@style/BaseAppTheme&quot;&gt;
    &lt;/style&gt;
&lt;/resources&gt;
</code></pre><p><strong>values-v19</strong></p>
<pre><code>&lt;resources&gt;
    &lt;style name=&quot;AppTheme&quot; parent=&quot;@style/BaseAppTheme&quot;&gt;
        &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;
    &lt;/style&gt;
&lt;/resources&gt;
</code></pre><blockquote>
<p>注意我们的主题是基于<strong>NoActionBar</strong>的，android:windowTranslucentStatus这个属性是<strong>v19</strong>开始引入的</p>
</blockquote>
<ul>
<li>布局文件</li>
</ul>
<p><strong>activity_main.xml</strong></p>
<pre><code>&lt;android.support.v4.widget.DrawerLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    &gt;
    &lt;LinearLayout
        android:id=&quot;@+id/id_main_content&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/id_toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:background=&quot;?attr/colorPrimary&quot;
            android:fitsSystemWindows=&quot;true&quot;
            app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt;
        &lt;TextView
            android:id=&quot;@+id/id_tv_content&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;0dp&quot;
            android:layout_weight=&quot;1&quot;
            android:gravity=&quot;center&quot;
            android:text=&quot;HelloWorld&quot;
            android:textSize=&quot;30sp&quot;/&gt;
    &lt;/LinearLayout&gt;
    &lt;android.support.design.widget.NavigationView
        android:id=&quot;@+id/id_nv_menu&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;start&quot;
        android:fitsSystemWindows=&quot;true&quot;
        app:headerLayout=&quot;@layout/header_just_username&quot;
        app:menu=&quot;@menu/menu_drawer&quot;
        /&gt;
&lt;/android.support.v4.widget.DrawerLayout&gt;
</code></pre><blockquote>
<p>DrawerLayout内部一个LinearLayout作为内容区域，一个NavigationView作为菜单</p>
<p>注意下Toolbar的高度设置为wrap_content。然后我们的NavigationView中又依赖一个布局文件和一个menu的文件。</p>
</blockquote>
<p><strong> 布局文件 header_just_username.xml</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;192dp&quot;
                android:background=&quot;?attr/colorPrimaryDark&quot;
                android:orientation=&quot;vertical&quot;
                android:padding=&quot;16dp&quot;
                android:fitsSystemWindows=&quot;true&quot;
                android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/id_link&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignParentBottom=&quot;true&quot;
        android:layout_marginBottom=&quot;16dp&quot;
        android:text=&quot;http://blog.csdn.net/lmj623565791&quot;/&gt;

    &lt;TextView
        android:id=&quot;@+id/id_username&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_above=&quot;@id/id_link&quot;
        android:text=&quot;Zhang Hongyang&quot;/&gt;

    &lt;ImageView
        android:layout_width=&quot;72dp&quot;
        android:layout_height=&quot;72dp&quot;
        android:layout_above=&quot;@id/id_username&quot;
        android:layout_marginBottom=&quot;16dp&quot;
        android:src=&quot;@mipmap/ic_launcher&quot;/&gt;


&lt;/RelativeLayout&gt;
</code></pre><p><strong>menu的文件略</strong></p>
<blockquote>
<p>大体看完布局文件以后，有几个点要特别注意：<br>ToolBar高度设置为wrap_content<br>ToolBar添加属性android:fitsSystemWindows=”true”<br>header_just_username.xml的跟布局RelativeLayout，添加属性android:fitsSystemWindows=”true”</p>
<p>android:fitsSystemWindows这个属性，主要是通过调整当前设置这个属性的view的padding去为我们的status_bar留下空间。</p>
<p>根据上面的解释，如果你不写，那么状态栏和Toolbar就会有挤一块的感觉了，类似会这样：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20150922091617868" alt=""></p>
<ul>
<li><p>Activity的代码</p>
<p>  public class MainActivity extends AppCompatActivity<br>  {</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState)
{
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Toolbar toolbar = (Toolbar) findViewById(R.id.id_toolbar);
    setSupportActionBar(toolbar);
    //StatusBarCompat.compat(this, getResources().getColor(R.color.status_bar_color));
    //StatusBarCompat.compat(this);
}
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>setSupportActionBar</p>
</blockquote>
<p><strong>4.4的效果</strong></p>
<p><img src="http://img.blog.csdn.net/20150922091636754" alt=""></p>
<blockquote>
<p>有个渐变的效果</p>
</blockquote>
<p><strong>5.x的效果</strong></p>
<p><img src="http://img.blog.csdn.net/20150922094815752" alt=""></p>
<blockquote>
<p>默认并非是一个渐变的效果，类似是一个深一点的颜色</p>
</blockquote>
<h3 id="调整4-4的显示方案-尽可能符合md的规范"><a href="#调整4-4的显示方案-尽可能符合md的规范" class="headerlink" title="调整4.4的显示方案(尽可能符合md的规范)"></a>调整4.4的显示方案(尽可能符合md的规范)</h3><blockquote>
<p>4.4之后加入windowTranslucentStatus的属性之后，也就是我们可以用到状态栏的区域了</p>
<p>既然我们可以用到这块区域，那么我们只要在根布局去设置一个与状态栏等高的View，设置背景色为我们期望的颜色就可以了。</p>
</blockquote>
<p><strong>代码如下</strong></p>
<pre><code>public class StatusBarCompat
{
    private static final int INVALID_VAL = -1;
    private static final int COLOR_DEFAULT = Color.parseColor(&quot;#20000000&quot;);

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void compat(Activity activity, int statusColor)
    {

        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP)
        {
            if (statusColor != INVALID_VAL)
            {
                activity.getWindow().setStatusBarColor(statusColor);
            }
            return;
        }

        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP)
        {
            int color = COLOR_DEFAULT;
            ViewGroup contentView = (ViewGroup) activity.findViewById(android.R.id.content);
            if (statusColor != INVALID_VAL)
            {
                color = statusColor;
            }
            View statusBarView = new View(activity);
            ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
                    getStatusBarHeight(activity));
            statusBarView.setBackgroundColor(color);
            contentView.addView(statusBarView, lp);
        }

    }

    public static void compat(Activity activity)
    {
        compat(activity, INVALID_VAL);
    }


    public static int getStatusBarHeight(Context context)
    {
        int result = 0;
        int resourceId = context.getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;);
        if (resourceId &gt; 0)
        {
            result = context.getResources().getDimensionPixelSize(resourceId);
        }
        return result;
    }
}
</code></pre><blockquote>
<p>代码的思路很简单，根据Activity找到android.R.content，在其中添加一个View(高度为statusbarHeight，背景色为我们设置的颜色，默认为半透明的黑色)。</p>
<p>那么只需要在Activity里面去写上：</p>
</blockquote>
<pre><code>StatusBarCompat.compat(this);
</code></pre><blockquote>
<p>如果你希望自己设置状态看颜色，那么就用这个方法：</p>
</blockquote>
<pre><code>StatusBarCompat.compat(this, getResources().getColor(R.color.status_bar_color));
</code></pre><blockquote>
<p>这样的话我们就解决了4.4到5.x的适配问题，一行代码解决</p>
</blockquote>
<p><strong>参考资料</strong></p>
<p><a href="http://jaeger.itscoder.com/android/2016/02/15/status-bar-demo.html" target="_blank" rel="external">http://jaeger.itscoder.com/android/2016/02/15/status-bar-demo.html</a><br><a href="http://jaeger.itscoder.com/android/2016/03/27/statusbar-util.html" target="_blank" rel="external">http://jaeger.itscoder.com/android/2016/03/27/statusbar-util.html</a><br><a href="http://www.jianshu.com/p/eae7569d7023" target="_blank" rel="external">http://www.jianshu.com/p/eae7569d7023</a><br><a href="http://blog.csdn.net/sbsujjbcy/article/details/48370371" target="_blank" rel="external">http://blog.csdn.net/sbsujjbcy/article/details/48370371</a><br><a href="https://www.zhihu.com/question/27040217" target="_blank" rel="external">https://www.zhihu.com/question/27040217</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/48649563" target="_blank" rel="external">http://blog.csdn.net/lmj623565791/article/details/48649563</a><br><a href="https://github.com/jgilfelt/SystemBarTint" target="_blank" rel="external">SystemBarTint</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Android 5.0发布了Material Design(MD)，App要尽可能遵从MD设计原则，本文就其中的沉浸式状态栏这一特性，描述其兼容到4.4的实现，以及一些小细节。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; c
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="MD" scheme="http://yoursite.com/tags/MD/"/>
    
      <category term="状态栏" scheme="http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android消息处理机制 — 原理分析</title>
    <link href="http://yoursite.com/2016/10/04/Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%20%E2%80%94%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/10/04/Android消息处理机制 — 原理分析/</id>
    <published>2016-10-04T07:11:40.000Z</published>
    <updated>2016-10-04T09:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>Android消息机制</strong></p>
<ul>
<li>Handler是Android消息机制的上层接口，开发者只需要和Handler交互即可；</li>
<li>Handler作用就是将一个任务切换到某个指定的线程中去执行；</li>
<li>更新UI就是Handler的一个特殊使用场景（子线程执行耗时任务，通过Handler切换到主线程更新UI），但其功能远不于此；</li>
<li>Handler的运行机制是Android消息机制的主要内容；</li>
<li>Handler的运行需要底层的MessageQueue和Looper的支撑；</li>
<li>MessageQueue是消息队列，其内部存储了一组消息（Message），以队列的形式对外提供插入和删除工作，虽说称它为消息队列，但其内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表；</li>
<li>Looper（循环）是消息循环者，MessageQueue只是一个消息的存储单元，它不能去处理消息，Looper填补了这个功能；</li>
<li>Looper以无限循环的方式去查看消息队列中是否有新消息，如果有就去处理，否则就一直等待着；</li>
<li>Looper中有一个特殊的概念ThreadLocal，它不是线程，作用是可以在每个线程中存储数据。Handler创建的时候会采用当前线程的Looper来构造消息循环系统，此时就是通过ThreadLocal来获得当前线程的Looper；</li>
<li>ThreadLocal可以在不同的线程中互不干扰地存储并提供数据，通过ThreadLocal可以轻松地获得每个线程的Looper；</li>
<li>线程默认是没有Looper的，如果需要使用Handler就必须为线程创建Looper。在主线程就是ActivityThread，其被创建时就会初始化Looper，这就是主线程中默认可以使用Handler的原因。</li>
</ul>
<h3 id="消息机制分析"><a href="#消息机制分析" class="headerlink" title="消息机制分析"></a>消息机制分析</h3><blockquote>
<p>前面一节已经对Android的消息机制做了一个概述，大致分析了Handler的工作过程，本节将从实现原理的角度，再次深入分析Android的消息机制。</p>
</blockquote>
<h4 id="ThreadLocal的工作原理"><a href="#ThreadLocal的工作原理" class="headerlink" title="ThreadLocal的工作原理"></a>ThreadLocal的工作原理</h4><blockquote>
<p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<p>ThreadLocal使用的场景并不多，但在某些特殊场景下，使用ThreadLocal可以轻松实现一些看似复杂的功能，这一点在Android源码中有所体现，如：Looper，ActivityThread以及AMS中都用到了ThreadLocal。</p>
<p>具体到ThreadLocal使用场景，不好统一来讲，一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。</p>
<p>对于Handler来说，它需要获取到当前线程的Looper，很显然Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松实现Looper在线程中的获取。如果不采用ThreadLocal，那么系统就必须提供一个全局的哈希表供Handler查找指定线程的Looper，这样一来就必须提供一个类似于LooperManager的类了，但是系统并没有这么做而是选择了ThreadLocal，这也体现了ThreadLocal的好处。</p>
<p>ThreadLocal另一个使用场景就是复杂逻辑下的对象传递，比如监听器的传递，有时候一个线程中的任务过于复杂，这可能表现为函数的调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢？其实采用ThreadLocal 可以让监听器作为线程内的全局对象而存在，在线程内部只要通过get方法就可以获取到监听器。如果不采用ThreadLocal，那么我们能想到的两种方法：</p>
</blockquote>
<ul>
<li>将监听器通过参数的形式在函数调用栈中进行传递。但当函数调用栈很深时，通过函数参数来传递监听器对象是不可接受的。</li>
<li>将监听器作为静态变量供线程访问，但其不具有可扩充性，10个线程同时并发执行，就需要10个静态的监听器对象，而采用ThreadLocal，每个监听器对象都在自己的线程内部存储，不会存在这个问题。</li>
</ul>
<p><strong>举个例子</strong></p>
<blockquote>
<p>首先定义一个ThreadLocal对象，这里选择Boolean类型，如下：</p>
</blockquote>
<pre><code>private ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = new ThreadLocal&lt;Boolean&gt;();
</code></pre><blockquote>
<p>然后分别在主线程，子线程1和子线程2中设置和访问它的值，如下：</p>
</blockquote>
<pre><code>mBooleanThreadLocal.set(true);
Log.d(&quot;Science&quot;, &quot;[Thread#main] mBooleanThreadLocal = : &quot; + mBooleanThreadLocal.get());

new Thread(&quot;Thread#1&quot;) {
    @Override
         public void run() {
                mBooleanThreadLocal.set(false);
                Log.d(&quot;Science&quot;, &quot;[Thread#1] mBooleanThreadLocal = : &quot; + mBooleanThreadLocal.get());
          }
}.start();

new Thread(&quot;Thread#2&quot;) {
        @Override
        public void run() {
                Log.d(&quot;Science&quot;, &quot;[Thread#2] mBooleanThreadLocal = : &quot; + mBooleanThreadLocal.get());
        }
}.start();
</code></pre><blockquote>
<p>主线程中设置mBooleanThreadLocal的值为true<br>线程1中设置mBooleanThreadLocal的值为false<br>线程2中不设置mBooleanThreadLocal值<br>然后分别在3个线程中通过get方法获取mBooleanThreadLocal的值</p>
<p>运行结果如下：</p>
</blockquote>
<pre><code>D/Science: [Thread#main] mBooleanThreadLocal = : true
D/Science: [Thread#1] mBooleanThreadLocal = : false
D/Science: [Thread#2] mBooleanThreadLocal = : null
</code></pre><blockquote>
<p>分析日志，可以看到，在不同的线程中访问的是同一个ThreadLocal对象，但是他们通过ThreadLocal获取到的值却不一样，这就是ThreadLocal的奇妙之处。</p>
<p>ThreadLocal之所以有这么奇妙的效果，是因为不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值。很显然，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同的线程中维护一套数据的副本并且彼此互不干扰。</p>
</blockquote>
<p><strong>下面看看ThreadLocal的内部具体实现</strong></p>
<blockquote>
<p>ThreadLocal是一个范型类，它的声明如下：</p>
</blockquote>
<pre><code>public class ThreadLocal&lt;T&gt;;
</code></pre><blockquote>
<p>从上面ThreadLocal的工作流程可以知道，要搞明白ThreadLocal，必须弄明白其内部的get和set方法</p>
</blockquote>
<ul>
<li><p>set方法</p>
<pre><code>/**
   * Sets the value of this variable for the current thread. If set to
   * {@code null}, the value will be set to null and the underlying entry will
   * still be present.
   *
   * @param value the new value of the variable for the caller thread.
   */
  public void set(T value) {
      Thread currentThread = Thread.currentThread();
      Values values = values(currentThread);
      if (values == null) {
          values = initializeValues(currentThread);
      }
      values.put(this, value);
  }
</code></pre></li>
</ul>
<blockquote>
<p>首先，通过values方法来获取当前线程中的ThreadLocal数据Values。获取过程如下：在Thread类的内部有一个成员专门用于存储线程的ThreadLocal数据（ThreadLocal.Values  localValues），因此获取当前线程的ThreadLocal数据就很简单。如果localValues为null，就需要对其进行初始化，初始化后再将ThreadLocal的值进行存储。</p>
<p>下面看下ThreadLocal的值到底是如何在localValues中进行存储的，在localValues内部有一个数组：private Object[] table，ThreadLocal的值就存在这个table数组中。</p>
<p>下面看下localValues是如何使用put方法将ThreadLocal的值存储到table数组中的，如下：</p>
</blockquote>
<pre><code>/**
 * Sets entry for given ThreadLocal to given value, creating an
 * entry if necessary.
 */
 void put(ThreadLocal&lt;?&gt; key, Object value) {
       cleanUp();

       // Keep track of first tombstone. That&apos;s where we want to go back
       // and add an entry if necessary.
       int firstTombstone = -1;

       for (int index = key.hash &amp; mask;; index = next(index)) {
             Object k = table[index];

             if (k == key.reference) {
                    // Replace existing entry.
                    table[index + 1] = value;
                    return;
             }

             if (k == null) {
                    if (firstTombstone == -1) {
                        // Fill in null slot.
                        table[index] = key.reference;
                        table[index + 1] = value;
                        size++;
                        return;
                    }

                    // Go back and replace first tombstone.
                    table[firstTombstone] = key.reference;
                    table[firstTombstone + 1] = value;
                    tombstones--;
                    size++;
                    return;
             }

             // Remember first tombstone.
             if (firstTombstone == -1 &amp;&amp; k == TOMBSTONE) {
                    firstTombstone = index;
             }
        }
}
</code></pre><blockquote>
<p>上面的代码实现了数据的存储，这个不分析具体算法，但我们可以得出一个存储规则：</p>
</blockquote>
<p><strong>ThreadLocal的值在table数组中的存储位置总是为ThreadLocal的reference字段所标识的对象的下一个位置</strong></p>
<blockquote>
<p>比如ThreadLocal的reference对象table数组中的索引为index，那么ThreadLocal的值在table数组中的索引就是index+1。最终，ThreadLocal的值将会被存储在table数组中：table[index+1] = value.</p>
</blockquote>
<ul>
<li><p>get方法</p>
<pre><code>/**
   * Returns the value of this variable for the current thread. If an entry
   * doesn&apos;t yet exist for this variable on this thread, this method will
   * create an entry, populating the value with the result of
   * {@link #initialValue()}.
   *
   * @return the current value of the variable for the calling thread.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public T get() {
      // Optimized for the fast path.
      Thread currentThread = Thread.currentThread();
      Values values = values(currentThread);
      if (values != null) {
          Object[] table = values.table;
          int index = hash &amp; values.mask;
          if (this.reference == table[index]) {
              return (T) table[index + 1];
          }
      } else {
          values = initializeValues(currentThread);
      }

      return (T) values.getAfterMiss(this);
  }
</code></pre></li>
</ul>
<blockquote>
<p>同样是先取出当前线程的localValues对象，如果为null就返回初始值，初始值由ThreadLocal的initialValue方法描述，默认情况下为null，也可重写此方法。</p>
</blockquote>
<pre><code>/**
   * Provides the initial value of this variable for the current thread.
   * The default implementation returns {@code null}.
   *
   * @return the initial value of the variable.
   */
  protected T initialValue() {
      return null;
  }
</code></pre><blockquote>
<p>如果localValues对象不为null，那就取出它的table数组并找到ThreadLocal的reference对象在table数组中的位置，然后table数组中取下一个位置的数据就是ThreadLocal的值。</p>
<p>总结：从set和get方法可以看出，它们所操作的对象都是当前线程的localValues对象的table数组，因此在不同线程中访问同一个ThreadLocal的set和get方法，它们对ThreadLocal所做的读写操作都仅限于各自线程的内部，这就是为什么ThreadLocal可以在多个线程中互不干扰的存储和修改数据，理解ThreadLocal的实现方式有助于理解Looper的工作原理。</p>
</blockquote>
<h4 id="消息队列的工作原理"><a href="#消息队列的工作原理" class="headerlink" title="消息队列的工作原理"></a>消息队列的工作原理</h4><blockquote>
<p>MessageQueue （维护一个消息列表）主要包含两个操作：</p>
</blockquote>
<ul>
<li>插入</li>
</ul>
<blockquote>
<p>enqueueMessage：向MessageQueue中插入一条消息，底层实现就是单链表的插入操作。</p>
</blockquote>
<ul>
<li>读取(会伴随删除操作)</li>
</ul>
<blockquote>
<p>next：是一个无限循环的方法，如果MessageQueue中没有消息，该方法就会一直阻塞在这里；当有新消息到来时，就从MessageQueue中取出消息并将其从MessageQueue中删除。</p>
</blockquote>
<p><strong>MessageQueue内部实现不是队列，而是单链表（在插入和删除上有优势）</strong></p>
<h4 id="Looper的工作原理"><a href="#Looper的工作原理" class="headerlink" title="Looper的工作原理"></a>Looper的工作原理</h4><blockquote>
<p>Looper在Android的消息机制中扮演着消息循环的角色，它会不停的从MessageQueue中查看是否有新消息，有的话就立即处理，否则也会一直阻塞在那里。</p>
<p>首先，其在构造方法中创建一个MessageQueue，然后，将当前线程的对象保存起来，如下：</p>
</blockquote>
<pre><code>private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
}
</code></pre><blockquote>
<p>Handler的工作需要Looper，没有Looper的线程就会报错，那如何为一个线程创建Looper呢？</p>
<p>Looper.prepare() 为当前线程创建一个Looper，Looper.loop()来开启消息循环，如下：</p>
</blockquote>
<pre><code>new Thread(&quot;Thread#2&quot;) {
        @Override
        public void run() {
            Looper.prepare();
            Handler handler = new Handler();
            Looper.loop();
        }
}.start();
</code></pre><blockquote>
<p>Looper除了prepare方法外，还提供了prepareMainLooper方法，其主要作用是给主线程也就是ActivityThread创建Looper时使用的，本质上也是通过prepare方法来实现的。主线程的Looper比较特殊，Looper提供了一个get MainLooper方法，其可以在任何地方获取主线程的Looper。</p>
<p>Looper也是可以退出的，Looper提供quit和quitSafely来退出一个Looper，二者区别是：quit会直接退出Looper，而quitSafely只是设定一个退出标识，然后等到MessageQueue中已有的消息处理完毕后才安全退出。</p>
<p>Looper退出后，通过Handler发送的消息会失败，这个时候Handler的send方法会返回false。</p>
<p>在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待状态，而如果退出Looper以后，这个线程就会立刻终止，所以建议不需要的时候终止Looper。</p>
<p>Looper一个重要的方法是loop，只有调用了loop后，消息循环系统才会真正地起作用。loop方法是一个死循环，唯一跳出循环的方式就是MessageQueue的next方法返回了null。</p>
<p>当Looper的quit方法被调用时，Looper就会调用MessageQueue的quit或quitSafely方法来通知MessageQueue退出，当MessageQueue被标记为退出状态时，它的next方法就会返回null。也就是说Looper必须退出，否则loop方法就会无限循环下去。loop方法会调用MessageQueue的next方法来获取新消息，而next是一个阻塞操作，当没有消息时，next方法会一直阻塞在那里，也就导致loop方法一直阻塞在那里。如果MessageQueue的next方法返回了新消息，Looper就会处理这条消息：msg.target.dispatchMessage(msg), 这里的msg.target是发送这条消息的Handler对象，这样Handler发送的消息最终又交给它的dispatchMessage方法来处理了。但这里不同的是，Handler的dispatchMessage方法是在创建Handler时所使用的Looper中执行的，这样就成功的将代码逻辑切换到指定的线程中去执行了。</p>
</blockquote>
<h4 id="Handler的工作原理"><a href="#Handler的工作原理" class="headerlink" title="Handler的工作原理"></a>Handler的工作原理</h4><p><strong>Handler的工作主要包括：</strong></p>
<ul>
<li>消息的发送</li>
<li>消息的接收</li>
</ul>
<blockquote>
<p>通过post的一系列方法以及send的一系列方法来实现，post的一系列方法最终是通过send的一系列方法来实现的。</p>
</blockquote>
<pre><code>public final boolean sendMessage(Message msg) {
        return sendMessageDelayed(msg, 0);
}
public final boolean sendMessage(Message msg, long delayMillis) {
        if (delayMillis &lt; 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg,SystemClock.uptimeMillis() + delayMillis);
}
public final boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeExeception e = new RuntimeExeception(this + &quot; sendMessageAtTime() called with no mQueue&quot;)
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis)
}
private final boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre><blockquote>
<p>Handler发送消息的过程仅仅是向MessageQueue中插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由Looper交由Handler处理，即Handler的dispatchMessage方法会被调用，这时Handler就进入了处理消息的阶段。</p>
<p>dispatchMessage的实现如下所示：</p>
</blockquote>
<pre><code>public void dispatchMessage(Message message) {
        if (msg.callback != null) {
            handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}
</code></pre><blockquote>
<p>Handler处理消息的过程：</p>
</blockquote>
<ol>
<li><p>首先，检查Message的callback是否为空，不为null就通过handleCallback来处理消息。Message的callback是一个Runnable对象，实际上就是Handler的post方法所传递的Runnable参数。handleCallback的逻辑如下：</p>
<p> private static void handleCallback(Message msg) {</p>
<pre><code>msg.callback.run();
</code></pre><p> }</p>
</li>
<li><p>然后检查mCallback是否为null，不为null就调用mCallback的handleMessage方法处理消息。Callback是个接口，定义如下：</p>
<p> /**</p>
<ul>
<li>Callback interface you can use when instantiating a Handler to avoid having   to implement your own subclass of Handler.<br>* </li>
<li>@param msg A {@link android.os.Message Message} object</li>
<li><p>@return True if no further handling is desired<br>*/</p>
<p>public interface Callback {<br>  public boolean handleMessage(Message msg);<br>}</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>通过Callback可以采用如下方式来创建Handler对象：Handler handler = new Handler(callback).</p>
<p>Callback存在的意义就是用来创建一个Handler的实例但并不需要派生Handler的子类。在日常开发中，创建Handler最常见的方式就是派生一个Handler的子类并重写其handleMessage方法来处理具体的消息，而Callback给我们提供了另外一种使用Handler的方式，当我们不想派生子类时，就可以通过Callback来实现。</p>
</blockquote>
<ol>
<li>最后，调用Handler的handleMessage方法来处理消息</li>
</ol>
<p><strong>Handler处理消息的过程可以用一个流程图来表示*</strong><br><img src="http://o9zgq2ik9.bkt.clouddn.com/Handler%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt=""></p>
<blockquote>
<p>Handler还有一个特殊的构造方法，那就是通过一个特定的Looper来构造Handler，它的实现如下，通过此构造方法可以实现一些特殊的功能。</p>
</blockquote>
<pre><code>public Handler(Looper looper) {
        this(looper,null,false);
}
</code></pre><blockquote>
<p>Handler默认的构造方法为public Handler()，它会去调用下面的构造方法，很明显如果当前线程没有Looper的话，就会抛出“Can’t create handler inside thread that has not called Looper.prepare()” 这个异常，这也解释了在没有Looper的子线程中创建Handler会引发程序异常。</p>
</blockquote>
<pre><code>/**
   * Use the {@link Looper} for the current thread with the specified callback interface
   * and set whether the handler should be asynchronous.
   *
   * Handlers are synchronous by default unless this constructor is used to make
   * one that is strictly asynchronous.
   *
   * Asynchronous messages represent interrupts or events that do not require global ordering
   * with respect to synchronous messages.  Asynchronous messages are not subject to
   * the synchronization barriers introduced by {@link MessageQueue#enqueueSyncBarrier(long)}.
   *
   * @param callback The callback interface in which to handle messages, or null.
   * @param async If true, the handler calls {@link Message#setAsynchronous(boolean)} for
   * each {@link Message} that is sent to it or {@link Runnable} that is posted to it.
   *
   * @hide
   */
  public Handler(Callback callback, boolean async) {
      if (FIND_POTENTIAL_LEAKS) {
          final Class&lt;? extends Handler&gt; klass = getClass();
          if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                  (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
              Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                  klass.getCanonicalName());
          }
      }

      mLooper = Looper.myLooper();
      if (mLooper == null) {
          throw new RuntimeException(
              &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);
      }
      mQueue = mLooper.mQueue;
      mCallback = callback;
      mAsynchronous = async;
  }
</code></pre><h3 id="主线程的消息循环"><a href="#主线程的消息循环" class="headerlink" title="主线程的消息循环"></a>主线程的消息循环</h3><blockquote>
<p>Android的主线程就是ActivityThread，主线程的入口方法为main，在main方法中系统会通过Looper.prepareMainLooper()方法来创建主线程的Looper以及MessageQueue，并通过Looper.loop()来开启主线程的消息循环，过程如下：</p>
</blockquote>
<pre><code>public static void main(String[] args) {
        ...
        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);

    Looper.prepareMainLooper();

    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    AsyncTask.init();

    if (false) {
        Looper.myLooper().setMessageLogging(new LogPrinter(Log,DEBUG, &quot;ActivityThread&quot;))
    }
    Looper.loop();

    throw new RuntimeExeception(&quot;Main thread loop unexpectedly exited&quot;);
}
</code></pre><blockquote>
<p>主线程的消息循环开始后，ActivityThread需要一个Handler和MessageQueue进行交互，这个Handler就是ActivityThread.H，它内部定义了一组消息类型，主要包括了四大组件的启动和停止等过程，如下：</p>
</blockquote>
<pre><code>private class H extends Handler {
        public static final int LAUNCH_ACTIVITY = 100;
        public static final int PAUSE_ACTIVITY = 101;
        public static final int PAUSE_ACTIVITY_FINSHING = 102;
        public static final int STOP_ACTIVITY_SHOW = 103;
    public static final int STOP_ACTIVITY_HIDE = 104;
    public static final int SHOW_WINDOW = 105;
    public static final int HIDE_WINDOW = 106;
    public static final int RESUME_ACTIVITY = 107;
    public static final int SEND_RESULT = 108;
    public static final int DESTROY_ACTIVITY = 109;
    public static final int BIND_APPLICATION = 110;
    public static final int EXIT_APPLICATION = 111;
    public static final int NEW_INTENT = 112;
    public static final int RECEIVER = 113;
    public static final int CREATE_SERVICE = 114;
    public static final int SERVICE_ARGS = 115;
    public static final int STOP_SERVICE = 116;

    ......
}
</code></pre><blockquote>
<p>ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。</p>
</blockquote>
<p><strong>参考资料</strong><br>《Android开发艺术探索》 —  任玉刚</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Android消息机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Handler是Android消息机制的上层接口，开发者
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java中ThreadLocal的使用</title>
    <link href="http://yoursite.com/2016/10/04/Java%E4%B8%ADThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/10/04/Java中ThreadLocal的使用/</id>
    <published>2016-10-04T02:17:24.000Z</published>
    <updated>2016-10-04T08:05:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>JDK 1.2开始提供Java.lang.ThreadLocal类，为解决多线程并发访问问题提供了一种新思路，使用这个工具类可以很简洁地编写出优美的多线程程序。<br>　　<br>用ThreadLocal维护变量，可以为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的变量副本，而不会影响其它线程所对应的变量副本。</p>
<p>从线程的角度看，目标变量就像是线程的本地变量，这也是类名中“Local”所要表达的意思。所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。</p>
</blockquote>
<p><strong>ThreadLocal的接口方法</strong></p>
<blockquote>
<p>ThreadLocal类接口很简单，只有4个方法：</p>
</blockquote>
<p>•    void set(Object value) 设置当前线程的线程局部变量的值。<br>•    public Object get() 该方法返回当前线程所对应的线程局部变量。<br>•    public void remove() 将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。<br>•    protected Object initialValue() 返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</p>
<blockquote>
<p>值得一提的是，在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal\<t\>。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。</t\></p>
<p>ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。</p>
</blockquote>
<p><strong>一个例子</strong></p>
<pre><code>public class TestNum {  
    // ①通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值  
    private static ThreadLocal&lt;Integer&gt; seqNum = new ThreadLocal&lt;Integer&gt;() {  
        public Integer initialValue() {  
            return 0;  
        }  
    };  

    // ②获取下一个序列值  
    public int getNextNum() {  
        seqNum.set(seqNum.get() + 1);  
        return seqNum.get();  
    }  

    public static void main(String[] args) {  
        TestNum sn = new TestNum();  
        // ③ 3个线程共享sn，各自产生序列号  
        TestClient t1 = new TestClient(sn);  
        TestClient t2 = new TestClient(sn);  
        TestClient t3 = new TestClient(sn);  
        t1.start();  
        t2.start();  
        t3.start();  
    }  

    private static class TestClient extends Thread {  
        private TestNum sn;  

        public TestClient(TestNum sn) {  
            this.sn = sn;  
        }  

        public void run() {  
            for (int i = 0; i &lt; 3; i++) {  
                // ④每个线程打出3个序列值  
                System.out.println(&quot;thread[&quot; + Thread.currentThread().getName() + &quot;] --&gt; sn[&quot;  
                         + sn.getNextNum() + &quot;]&quot;);  
            }  
        }  
    }  
} 
</code></pre><blockquote>
<p>通常我们通过匿名内部类的方式定义ThreadLocal的子类，提供初始的变量值，如例子中①处所示。TestClient线程产生一组序列号，在③处，我们生成3个TestClient，它们共享同一个TestNum实例。运行以上代码，在控制台上输出以下的结果：</p>
</blockquote>
<pre><code>thread[Thread-0] --&gt; sn[1]
thread[Thread-1] --&gt; sn[1]
thread[Thread-2] --&gt; sn[1]
thread[Thread-1] --&gt; sn[2]
thread[Thread-0] --&gt; sn[2]
thread[Thread-1] --&gt; sn[3]
thread[Thread-2] --&gt; sn[2]
thread[Thread-0] --&gt; sn[3]
thread[Thread-2] --&gt; sn[3]
</code></pre><blockquote>
<p>考察输出的结果信息，我们发现每个线程所产生的序号虽然都共享同一个TestNum实例，但它们并没有发生相互干扰的情况，而是各自产生独立的序列号，这是因为我们通过ThreadLocal为每一个线程提供了单独的副本。</p>
</blockquote>
<h3 id="Vs线程同步机制"><a href="#Vs线程同步机制" class="headerlink" title="Vs线程同步机制"></a>Vs线程同步机制</h3><blockquote>
<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</p>
</blockquote>
<ul>
<li>线程同步机制</li>
</ul>
<blockquote>
<p>线程同步机制是通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用线程同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</p>
</blockquote>
<ul>
<li>ThreadLocal机制</li>
</ul>
<blockquote>
<p>ThreadLocal为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。每一个线程都拥有自己的变量副本，所以就没必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<p>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但从JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用，上面的例子就使用了JDK 5.0新的ThreadLocal\<t\>版本。</t\></p>
</blockquote>
<ul>
<li>两者比较</li>
</ul>
<blockquote>
<p>概括起来说，对于多线程资源共享的问题，线程同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
</blockquote>
<h3 id="ThreadLocal具体实现"><a href="#ThreadLocal具体实现" class="headerlink" title="ThreadLocal具体实现"></a>ThreadLocal具体实现</h3><blockquote>
<p>ThreadLocal类到底是如何实现这种“为每个线程提供不同的变量拷贝”的呢？先来看一下ThreadLocal的set()方法:</p>
</blockquote>
<pre><code>/** 
    * Sets the current thread&apos;s copy of this thread-local variable 
    * to the specified value.  Most subclasses will have no need to 
    * override this method, relying solely on the {@link #initialValue} 
    * method to set the values of thread-locals. 
    * 
    * @param value the value to be stored in the current thread&apos;s copy of 
    *        this thread-local. 
    */  
   public void set(T value) {  
       Thread t = Thread.currentThread();  
       ThreadLocalMap map = getMap(t);  
       if (map != null)  
           map.set(this, value);  
       else  
           createMap(t, value);  
   } 
</code></pre><blockquote>
<p>首先，通过getMap(Thread t)方法获取一个和当前线程相关的ThreadLocalMap；然后，将变量的值设置到这个ThreadLocalMap对象中，当然如果获取到的ThreadLocalMap对象为空，就通过createMap方法创建。</p>
<p>线程隔离的秘密就在于ThreadLocalMap类，ThreadLocalMap是ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取（对比Map对象来理解），每个线程中都有一个独立的ThreadLocalMap副本，它所存储的值，只能被当前线程读取和修改。ThreadLocal类通过操作每一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程中的隔离。因为每个线程的变量都是自己特有的，完全不会有并发错误。还有一点就是，ThreadLocalMap存储的键值对中的键是this对象指向的ThreadLocal对象，而值就是你所设置的对象了。</p>
<p>为了加深理解，我们接着看上面代码中出现的getMap和createMap方法的实现：</p>
</blockquote>
<pre><code>/** 
 * Get the map associated with a ThreadLocal. Overridden in 
 * InheritableThreadLocal. 
 * 
 * @param  t the current thread 
 * @return the map 
 */  
ThreadLocalMap getMap(Thread t) {  
    return t.threadLocals;  
}  

/** 
 * Create the map associated with a ThreadLocal. Overridden in 
 * InheritableThreadLocal. 
 * 
 * @param t the current thread 
 * @param firstValue value for the initial entry of the map 
 * @param map the map to store. 
 */  
void createMap(Thread t, T firstValue) {  
    t.threadLocals = new ThreadLocalMap(this, firstValue);  
}  
</code></pre><blockquote>
<p>接下来再看一下ThreadLocal类中的get()方法:</p>
</blockquote>
<pre><code>/** 
 * Returns the value in the current thread&apos;s copy of this 
 * thread-local variable.  If the variable has no value for the 
 * current thread, it is first initialized to the value returned 
 * by an invocation of the {@link #initialValue} method. 
 * 
 * @return the current thread&apos;s value of this thread-local 
 */  
public T get() {  
    Thread t = Thread.currentThread();  
    ThreadLocalMap map = getMap(t);  
    if (map != null) {  
        ThreadLocalMap.Entry e = map.getEntry(this);  
        if (e != null)  
            return (T)e.value;  
    }  
    return setInitialValue();  
}  
</code></pre><blockquote>
<p>再来看setInitialValue()方法：</p>
</blockquote>
<pre><code>/** 
    * Variant of set() to establish initialValue. Used instead 
    * of set() in case user has overridden the set() method. 
    * 
    * @return the initial value 
    */  
   private T setInitialValue() {  
       T value = initialValue();  
       Thread t = Thread.currentThread();  
       ThreadLocalMap map = getMap(t);  
       if (map != null)  
           map.set(this, value);  
       else  
           createMap(t, value);  
       return value;  
   }  
</code></pre><blockquote>
<p>获取和当前线程绑定的值时，ThreadLocalMap对象是以this指向的ThreadLocal对象为键进行查找的，这当然和前面set()方法的代码是相呼应的。</p>
<p>进一步地，我们可以创建不同的ThreadLocal实例来实现多个变量在不同线程间的访问隔离，为什么可以这么做？因为不同的ThreadLocal对象作为不同键，当然也可以在线程的ThreadLocalMap对象中设置不同的值了。通过ThreadLocal对象，在多线程中共享一个值和多个值的区别，就像你在一个HashMap对象中存储一个键值对和多个键值对一样，仅此而已。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p>
</blockquote>
<p><strong>一个是锁机制进行时间换空间，一个是存储拷贝进行空间换时间。</strong></p>
<p><strong>参考资料</strong><br><a href="http://blog.csdn.net/lufeng20/article/details/24314381" target="_blank" rel="external">博文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;JDK 1.2开始提供Java.lang.ThreadLocal类，为解决多线程并发访问问题提供了一种新思路，使用
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android事件分发机制</title>
    <link href="http://yoursite.com/2016/10/01/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/10/01/Android事件分发机制/</id>
    <published>2016-10-01T01:54:33.000Z</published>
    <updated>2016-10-03T15:21:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ViewGroup是一组View的集合，它包含很多的子View和子VewGroup，是Android中所有布局的父类或间接父类，像LinearLayout、RelativeLayout等都是继承自ViewGroup的。但ViewGroup实际上也是一个View，只不过比起View，它多了可以包含子View和定义布局参数的功能。这里按照View和ViewGroup两种情况去分析，其中，View特指不是容器的组件，而ViewGroup则是一个容器，里面可以包含前者的非容器View和ViewGroup。</strong></p>
<ul>
<li>View 的事件分发</li>
<li>ViewGroup 的事件分发</li>
<li>总结</li>
</ul>
<hr>
<h2 id="View-的事件分发"><a href="#View-的事件分发" class="headerlink" title="View 的事件分发"></a>View 的事件分发</h2><blockquote>
<p>定义一个Activity，其布局中只有一个按钮，并给按钮注册一个点击事件，如下：</p>
</blockquote>
<pre><code>button.setOnClickListener(new OnClickListener() {  
    @Override  
    public void onClick(View v) {  
        Log.d(&quot;TAG&quot;, &quot;onClick execute&quot;);  
    }  
});
</code></pre><blockquote>
<p>按钮被点击，onClick方法执行。然后再给按钮再添加一个touch事件，如下：</p>
</blockquote>
<pre><code>button.setOnTouchListener(new OnTouchListener() {  
    @Override  
    public boolean onTouch(View v, MotionEvent event) {  
        Log.d(&quot;TAG&quot;, &quot;onTouch execute, action &quot; + event.getAction());  
        return false;  
    }  
});  
</code></pre><blockquote>
<p>onTouch方法能够执行的逻辑要更复杂一些，如判断手指按下、抬起、移动等事件。</p>
</blockquote>
<p><strong>问题来了，哪一个会先执行呢？</strong></p>
<blockquote>
<p>运行程序点击按钮，打印结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130614230234671" alt=""></p>
<blockquote>
<p>结果证明：onTouch是优先于onClick执行，并且onTouch执行了两次，一次是ACTION_DOWN，一次是ACTION_UP(你还可能会有多次ACTION_MOVE的执行，如果你手抖了一下)。</p>
<p>因此事件传递的顺序是先经过onTouch，再传递到onClick。</p>
</blockquote>
<p><strong>为什么会这样？</strong></p>
<blockquote>
<p>查看onTouch方法，发现其有返回值的，上面返回的是false。</p>
</blockquote>
<p><strong>如果返回true呢？</strong></p>
<blockquote>
<p>再次运行，结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130614231001468" alt=""></p>
<blockquote>
<p>onClick方法不再执行了！为什么会这样呢？</p>
<p>可以暂时理解成onTouch方法返回true就认为这个事件被onTouch消费掉了，因而不会再继续向下传递。</p>
<p>当然，我们不会仅仅满足于此，让我们深层次的去看看出现上述现象的原理到底是什么？</p>
<p>首先，你触摸到了任何控件，那一定会调用该控件的dispatchTouchEvent方法。当点击按钮的时，就会去调用Button的dispatchTouchEvent方法，可Button里没有这个方法，那就去它父类TextView里找，发现TextView也没有，继续在TextView的父类View里找，Bingo，终于找到了。</p>
<p>然后，重点来了，看一下View中dispatchTouchEvent方法的源码吧！</p>
</blockquote>
<pre><code>public boolean dispatchTouchEvent(MotionEvent event) {  
    if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  
            mOnTouchListener.onTouch(this, event)) {  
        return true;  
    }  
    return onTouchEvent(event);  
}  
</code></pre><blockquote>
<p>简洁，只有几行代码！先是一个判断，如果mOnTouchListener != null，(mViewFlags &amp; ENABLED_MASK) == ENABLED和mOnTouchListener.onTouch(this, event)这三个条件都为真，就返回true，否则就去执行onTouchEvent(event)方法并返回。_</p>
<p>第一个条件，mOnTouchListener变量是在哪赋值的呢？寻找之后在View里发现了如下方法：</p>
</blockquote>
<pre><code>public void setOnTouchListener(OnTouchListener l) {  
    mOnTouchListener = l;  
}  
</code></pre><blockquote>
<p>Bingo！mOnTouchListener是在这里赋值的，也就是说，只要给控件注册了touch事件，mOnTouchListener就一定被赋值了，也就不为null了。</p>
<p>第二个条件，(mViewFlags &amp; ENABLED_MASK) == ENABLED，判断当前点击的控件是否是enable的，按钮默认都是enable的，因此这个条件恒定为true。_</p>
<p>第三个条件，mOnTouchListener.onTouch(this, event)，关键点，回调控件注册touch事件时的onTouch方法。如果在onTouch方法里返回true，这三个条件全部成立，从而整个方法直接返回true。如果在onTouch方法里返回false，就会再去执行onTouchEvent(event)方法。</p>
<p>结合前面的例子综合分析一下，先在dispatchTouchEvent中最先执行的是onTouch方法，因此onTouch要先于onClick执行，也印证了刚刚的打印结果。而如果在onTouch方法里返回了true，就会让dispatchTouchEvent方法直接返回true，不会再继续往下执行。而打印结果也证实了如果onTouch返回true，其onTouchEvent(event)方法也就不再执行了， onClick也就不会再执行了(后面我们知道，onClick方法就是在onTouchEvent(event)方法里执行的)。</p>
<p>根据以上分析，从原理上解释了前面例子的运行结果。那我们就来看下onTouchEvent的源码，看看onClick方法是不是真的在里面，如下所示：</p>
</blockquote>
<pre><code>1.  public boolean onTouchEvent(MotionEvent event) {  
2.      final int viewFlags = mViewFlags;  
3.      if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {  
4.          // A disabled view that is clickable still consumes the touch  
5.          // events, it just doesn&apos;t respond to them.  
6.          return (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  
7.                  (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));  
8.      }  
9.      if (mTouchDelegate != null) {  
10.         if (mTouchDelegate.onTouchEvent(event)) {  
11.             return true;  
12.         }  
13.     }  
14.     if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  
15.             (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {  
16.         switch (event.getAction()) {  
17.             case MotionEvent.ACTION_UP:  
18.                 boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0;  
19.                 if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) {  
20.                     // take focus if we don&apos;t have it already and we should in  
21.                     // touch mode.  
22.                     boolean focusTaken = false;  
23.                     if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {  
24.                         focusTaken = requestFocus();  
25.                     }  
26.                     if (!mHasPerformedLongPress) {  
27.                         // This is a tap, so remove the longpress check  
28.                         removeLongPressCallback();  
29.                         // Only perform take click actions if we were in the pressed state  
30.                         if (!focusTaken) {  
31.                             // Use a Runnable and post this rather than calling  
32.                             // performClick directly. This lets other visual state  
33.                             // of the view update before click actions start.  
34.                             if (mPerformClick == null) {  
35.                                 mPerformClick = new PerformClick();  
36.                             }  
37.                             if (!post(mPerformClick)) {  
38.                                 performClick();  
39.                             }  
40.                         }  
41.                     }  
42.                     if (mUnsetPressedState == null) {  
43.                         mUnsetPressedState = new UnsetPressedState();  
44.                     }  
45.                     if (prepressed) {  
46.                         mPrivateFlags |= PRESSED;  
47.                         refreshDrawableState();  
48.                         postDelayed(mUnsetPressedState,  
49.                                 ViewConfiguration.getPressedStateDuration());  
50.                     } else if (!post(mUnsetPressedState)) {  
51.                         // If the post failed, unpress right now  
52.                         mUnsetPressedState.run();  
53.                     }  
54.                     removeTapCallback();  
55.                 }  
56.                 break;  
57.             case MotionEvent.ACTION_DOWN:  
58.                 if (mPendingCheckForTap == null) {  
59.                     mPendingCheckForTap = new CheckForTap();  
60.                 }  
61.                 mPrivateFlags |= PREPRESSED;  
62.                 mHasPerformedLongPress = false;  
63.                 postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  
64.                 break;  
65.             case MotionEvent.ACTION_CANCEL:  
66.                 mPrivateFlags &amp;= ~PRESSED;  
67.                 refreshDrawableState();  
68.                 removeTapCallback();  
69.                 break;  
70.             case MotionEvent.ACTION_MOVE:  
71.                 final int x = (int) event.getX();  
72.                 final int y = (int) event.getY();  
73.                 // Be lenient about moving outside of buttons  
74.                 int slop = mTouchSlop;  
75.                 if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) ||  
76.                         (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) {  
77.                     // Outside button  
78.                     removeTapCallback();  
79.                     if ((mPrivateFlags &amp; PRESSED) != 0) {  
80.                         // Remove any future long press/tap checks  
81.                         removeLongPressCallback();  
82.                         // Need to switch from pressed to not pressed  
83.                         mPrivateFlags &amp;= ~PRESSED;  
84.                         refreshDrawableState();  
85.                     }  
86.                 }  
87.                 break;  
88.         }  
89.         return true;  
90.     }  
91.     return false;  
92. } 
</code></pre><p><strong>比较长，挑重点看</strong></p>
<blockquote>
<p>在第14行我们可以看出，如果该控件是可以点击的就会进入到第16行的switch判断中去，而如果当前的事件是抬起手指，则会进入到MotionEvent.ACTION_UP这个case当中。在经过种种判断之后，会执行到第38行的performClick()方法，那就看看这个方法：_</p>
</blockquote>
<pre><code>public boolean performClick() {  
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  
    if (mOnClickListener != null) {  
        playSoundEffect(SoundEffectConstants.CLICK);  
        mOnClickListener.onClick(this);  
        return true;  
    }  
    return false;  
} 
</code></pre><p><strong>舒服多了</strong></p>
<blockquote>
<p>看到mOnClickListener.onClick(this)，我们就更开心了，只要mOnClickListener不是null，就会去调用它，那mOnClickListener又是在哪里赋值的呢？看下面：</p>
</blockquote>
<pre><code>public void setOnClickListener(OnClickListener l) {  
    if (!isClickable()) {  
        setClickable(true);  
    }  
    mOnClickListener = l;  
}  
</code></pre><blockquote>
<p>一切都清楚了！当调用setOnClickListener方法来给控件注册一个点击事件时，就会给mOnClickListener赋值。然后每当控件被点击时，都会在performClick()方法里回调被点击控件的onClick方法。</p>
<p>整个事件分发的流程似乎就这样要结束了，不，还有一个要重点说明的是touch事件的层级传递。如果给一个控件注册了touch事件，每次点击它的时候都会触发一系列的ACTION_DOWN，ACTION_MOVE，ACTION_UP等事件，简称为事件流，请注意，如果你在执行ACTION_DOWN的时候返回了false，那么这个事件流就会被中断执行。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个action事件返回true，才会触发后一个action 事件。</p>
</blockquote>
<p><strong>这不是自相矛盾吗？</strong></p>
<blockquote>
<p>前面的例子中，明明在onTouch事件里面返回了false，ACTION_DOWN和ACTION_UP不是都得到执行了吗？其实你只是被假象所迷惑了，仔细分析一下代码，就会知道在前面的例子当中，我们到底返回的是什么。首先在onTouch事件里返回了false，就一定会进入到onTouchEvent方法中，然后我们来看一下onTouchEvent方法的细节。_由于点击了按钮且按钮是可点击的_，就会进入到第14行这个if判断的内部，然后你会发现，不管当前的action是什么，最终都一定会走到第89行，返回一个true。</p>
</blockquote>
<p><strong>是不是有一种被欺骗的感觉？</strong></p>
<blockquote>
<p>明明在onTouch事件里返回了false，系统还是在onTouchEvent方法中帮你返回了true。就因为这个原因，才使得前面的例子中ACTION_UP可以得到执行。_</p>
<p>我们可以换一个控件，将按钮替换成ImageView，然后给它也注册一个touch事件，并返回false。如下所示：</p>
</blockquote>
<pre><code>imageView.setOnTouchListener(new OnTouchListener() {  
    @Override  
    public boolean onTouch(View v, MotionEvent event) {  
        Log.d(&quot;TAG&quot;, &quot;onTouch execute, action &quot; + event.getAction());  
        return false;  
    }  
});  
</code></pre><blockquote>
<p>运行程序，点击ImageView，结果如下</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130617193504328" alt=""></p>
<blockquote>
<p>在ACTION_DOWN执行完后，后面的一系列action事件都不会得到执行了。这又是为什么呢？因为ImageView和按钮不同，它是默认不可点击的，因此在onTouchEvent的第14行判断时无法进入到if的内部，直接跳到第91行返回了false，也就导致后面其它的action都无法执行了。View的事件分发，就到这里。</p>
</blockquote>
<hr>
<h2 id="ViewGroup的事件分发"><a href="#ViewGroup的事件分发" class="headerlink" title="ViewGroup的事件分发"></a>ViewGroup的事件分发</h2><blockquote>
<p>首先，自定义一个布局为MyLayout，继承自LinearLayout，如下：</p>
</blockquote>
<pre><code>public class MyLayout extends LinearLayout {  
    public MyLayout(Context context, AttributeSet attrs) {  
        super(context, attrs);  
    }  
}  
</code></pre><blockquote>
<p>然后，打开布局文件activity_main.xml，在其中加入自定义的布局MyLayout，如下：</p>
</blockquote>
<pre><code>&lt;com.example.viewgrouptouchevent.MyLayout 
        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:id=&quot;@+id/my_layout&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    android:orientation=&quot;vertical&quot; &gt;  
    &lt;Button  
        android:id=&quot;@+id/button1&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Button1&quot; /&gt;  
    &lt;Button  
        android:id=&quot;@+id/button2&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Button2&quot; /&gt;  
&lt;/com.example.viewgrouptouchevent.MyLayout&gt;  
</code></pre><blockquote>
<p>在MyLayout中添加了两个按钮，最后在MainActivity中为这两个按钮和MyLayout注册监听事件：</p>
</blockquote>
<pre><code>myLayout.setOnTouchListener(new OnTouchListener() {  
    @Override  
    public boolean onTouch(View v, MotionEvent event) {  
        Log.d(&quot;TAG&quot;, &quot;myLayout on touch&quot;);  
        return false;  
    }  
});  
button1.setOnClickListener(new OnClickListener() {  
    @Override  
    public void onClick(View v) {  
        Log.d(&quot;TAG&quot;, &quot;You clicked button1&quot;);  
    }  
});  
button2.setOnClickListener(new OnClickListener() {  
    @Override  
    public void onClick(View v) {  
        Log.d(&quot;TAG&quot;, &quot;You clicked button2&quot;);  
    }  
});  
</code></pre><blockquote>
<p>运行项目，分别点击一下Button1、Button2和空白区域，打印结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130629144048875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<blockquote>
<p>当点击按钮的时，MyLayout注册的onTouch方法并不会执行，只有点击空白区域的时候才会执行该方法。可以先暂时理解成Button的onClick方法将事件消费掉了，因此事件不会再继续向下传递。</p>
<p>Android中的touch事件是先传递到View，再传递到ViewGroup的？</p>
</blockquote>
<p><strong>结论下的太早，做个实验</strong></p>
<blockquote>
<p>ViewGroup中有一个onInterceptTouchEvent方法，我们来看一下这个方法的源码：</p>
</blockquote>
<pre><code>public boolean onInterceptTouchEvent(MotionEvent ev) {  
    return false;  
} 
</code></pre><p><strong>还是这么短(注释已略去)</strong></p>
<blockquote>
<p>只有一行代码，返回一个false！既然是布尔型的返回，那么只有两种可能，我们在MyLayout中重写这个方法，然后分布返回一个true和false试试，代码如下所示：</p>
</blockquote>
<pre><code>public class MyLayout extends LinearLayout {  
    public MyLayout(Context context, AttributeSet attrs) {  
        super(context, attrs);  
    }  
    @Override  
    public boolean onInterceptTouchEvent(MotionEvent ev) {  
        return true;  
    }  
}  
</code></pre><blockquote>
<p>运行项目，分别Button1、Button2和空白区域，打印结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130629145544984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<blockquote>
<p>奇怪了，不管点哪里，永远都只会触发MyLayout的touch事件了，按钮的点击事件完全被屏蔽掉了！</p>
</blockquote>
<p><strong>这是为什么？</strong></p>
<blockquote>
<p>如果Android中的touch事件是先传递到View，再传递到ViewGroup的，那么MyLayout又怎么可能屏蔽掉Button的点击事件呢？</p>
<p>看来只有通过源码，才能搞清Android中ViewGroup的事件分发机制，解决心中疑惑，不过结论一定是：<strong>Android中touch事件的传递，绝对是先传递到ViewGroup，再传递到View的。</strong></p>
<p>在上一小节中，我们说过只要你触摸了任何控件，就一定会调用该控件的dispatchTouchEvent方法。这个说法没错，只不过还不完整而已。实际是，当你点击了某个控件，首先会去调用该控件所在布局的dispatchTouchEvent方法，然后在布局的dispatchTouchEvent方法中找到被点击的相应控件，再去调用该控件的dispatchTouchEvent方法。如果我们点击了MyLayout中的按钮，会先去调用MyLayout的dispatchTouchEvent方法，可是你会发现MyLayout中并没有这个方法，那就去到它的父类LinearLayout中找，发现也没有这个方法，那就继续再找LinearLayout的父类ViewGroup，终于在ViewGroup中看到了这个方法，按钮的dispatchTouchEvent方法就是在这里调用的。</p>
<p>ViewGroup中的dispatchTouchEvent方法的源码如下：</p>
</blockquote>
<pre><code>1.  public boolean dispatchTouchEvent(MotionEvent ev) {  
2.      final int action = ev.getAction();  
3.      final float xf = ev.getX();  
4.      final float yf = ev.getY();  
5.      final float scrolledXFloat = xf + mScrollX;  
6.      final float scrolledYFloat = yf + mScrollY;  
7.      final Rect frame = mTempRect;  
8.      boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;  
9.      if (action == MotionEvent.ACTION_DOWN) {  
10.         if (mMotionTarget != null) {  
11.             mMotionTarget = null;  
12.         }  
13.         if (disallowIntercept || !onInterceptTouchEvent(ev)) {  
14.             ev.setAction(MotionEvent.ACTION_DOWN);  
15.             final int scrolledXInt = (int) scrolledXFloat;  
16.             final int scrolledYInt = (int) scrolledYFloat;  
17.             final View[] children = mChildren;  
18.             final int count = mChildrenCount;  
19.             for (int i = count - 1; i &gt;= 0; i--) {  
20.                 final View child = children[i];  
21.                 if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE  
22.                         || child.getAnimation() != null) {  
23.                     child.getHitRect(frame);  
24.                     if (frame.contains(scrolledXInt, scrolledYInt)) {  
25.                         final float xc = scrolledXFloat - child.mLeft;  
26.                         final float yc = scrolledYFloat - child.mTop;  
27.                         ev.setLocation(xc, yc);  
28.                         child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
29.                         if (child.dispatchTouchEvent(ev))  {  
30.                             mMotionTarget = child;  
31.                             return true;  
32.                         }  
33.                     }  
34.                 }  
35.             }  
36.         }  
37.     }  
38.     boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  
39.             (action == MotionEvent.ACTION_CANCEL);  
40.     if (isUpOrCancel) {  
41.         mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;  
42.     }  
43.     final View target = mMotionTarget;  
44.     if (target == null) {  
45.         ev.setLocation(xf, yf);  
46.         if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) {  
47.             ev.setAction(MotionEvent.ACTION_CANCEL);  
48.             mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
49.         }  
50.         return super.dispatchTouchEvent(ev);  
51.     }  
52.     if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) {  
53.         final float xc = scrolledXFloat - (float) target.mLeft;  
54.         final float yc = scrolledYFloat - (float) target.mTop;  
55.         mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
56.         ev.setAction(MotionEvent.ACTION_CANCEL);  
57.         ev.setLocation(xc, yc);  
58.         if (!target.dispatchTouchEvent(ev)) {  
59.         }  
60.         mMotionTarget = null;  
61.         return true;  
62.     }  
63.     if (isUpOrCancel) {  
64.         mMotionTarget = null;  
65.     }  
66.     final float xc = scrolledXFloat - (float) target.mLeft;  
67.     final float yc = scrolledYFloat - (float) target.mTop;  
68.     ev.setLocation(xc, yc);  
69.     if ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) {  
70.         ev.setAction(MotionEvent.ACTION_CANCEL);  
71.         target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
72.         mMotionTarget = null;  
73.     }  
74.     return target.dispatchTouchEvent(ev);  
75. }  
</code></pre><p><strong>挑重点看</strong></p>
<blockquote>
<p>首先，在第13行处有一个条件判断，如果disallowIntercept和!onInterceptTouchEvent(ev)两者有一个为true，就会进入到这个条件判断中。disallowIntercept是指是否禁用掉事件拦截的功能，默认是false，也可以通过调用requestDisallowInterceptTouchEvent方法对这个值进行修改。那么当第一个值为false的时候就会完全依赖第二个值来决定是否可以进入到条件判断的内部，第二个值是什么呢？竟然就是对onInterceptTouchEvent方法的返回值取反！也就是说如果我们在onInterceptTouchEvent方法中返回false，就会让第二个值为true，从而进入到条件判断的内部，如果我们在onInterceptTouchEvent方法中返回true，就会让第二个值为false，从而跳出了这个条件判断。</p>
<p>由于我们在MyLayout中重写了onInterceptTouchEvent方法，让这个方法返回true，导致所有按钮的点击事件都被屏蔽了，那我们就完全有理由相信，按钮点击事件的处理就是在第13行条件判断的内部进行的！那重点看下条件判断的内部是怎么实现的。在第19行通过一个for循环，遍历了当前ViewGroup下的所有子View，然后在第24行判断当前遍历的View是不是正在点击的View，如果是的话就会进入到该条件判断的内部，然后在第29行调用了该View的dispatchTouchEvent，之后就是上节讲的View的事件分发了。</p>
<p>然后需要注意，调用子View的dispatchTouchEvent后是有返回值的。我们已经知道，如果一个控件是可点击的，那么点击该控件时，dispatchTouchEvent的返回值必定是true。因此会导致第29行的条件判断成立，于是在第31行给ViewGroup的dispatchTouchEvent方法直接返回了true。这样就导致后面的代码无法执行到了，也是印证了我们前面的Demo打印的结果，如果按钮的点击事件得到执行，就会把MyLayout的touch事件拦截掉。</p>
<p>如果我们点击的不是按钮，而是空白区域呢？这种情况就一定不会在第31行返回true了，而是会继续执行后面的代码。那我们继续往后看，在第44行，如果target等于null，就会进入到该条件判断内部，这里一般情况下target都会是null，因此会在第50行调用super.dispatchTouchEvent(ev)。这句代码会调用到哪里呢？当然是View中的dispatchTouchEvent方法了，因为ViewGroup的父类就是View。之后的处理逻辑又和前面所说的是一样的了，也因此MyLayout中注册的onTouch方法会得到执行。之后的代码在一般情况下是走不到的了，我们也就不再继续往下分析。</p>
<p>ViewGroup事件分发过程的流程图如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130629200236578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<blockquote>
<p>现在整个ViewGroup的事件分发流程的分析也就到此结束了，我们最后再来简单梳理一下吧。</p>
</blockquote>
<ol>
<li>Android事件分发是先传递到ViewGroup，再由ViewGroup传递到View的。</li>
<li>在ViewGroup中可以通过onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。</li>
<li>子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>onTouch和onTouchEvent区别，如何使用？</li>
</ol>
<blockquote>
<p>这两个方法都是在View的dispatchTouchEvent中调用的，onTouch先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一，mOnTouchListener的值不能为空，第二，当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。</p>
</blockquote>
<ol>
<li>为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？</li>
</ol>
<blockquote>
<blockquote>
<p>滑动菜单的功能是通过给ListView注册了一个touch事件来实现的。如果你在onTouch方法里处理完了滑动逻辑后返回true，那么ListView本身的滚动事件就被屏蔽了，自然也就无法滑动，因此解决办法就是在onTouch方法里返回false。</p>
</blockquote>
</blockquote>
<ol>
<li>为什么图片轮播器里的图片使用Button而不用ImageView？</li>
</ol>
<blockquote>
<p>因为Button是可点击的，而ImageView是不可点击的。如果想要使用ImageView，可以有两种改法。第一，在ImageView的onTouch方法里返回true，这样可以保证ACTION_DOWN之后的其它action都能得到执行，才能实现图片滚动的效果。第二，在布局文件里面给ImageView增加一个android:clickable=”true”的属性，这样ImageView变成可点击的之后，即使在onTouch里返回了false，ACTION_DOWN之后的其它action也是可以得到执行的。</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h3><p><a href="http://blog.csdn.net/sinyu890807/article/details/9097463" target="_blank" rel="external">http://blog.csdn.net/sinyu890807/article/details/9097463</a><br><a href="http://blog.csdn.net/sinyu890807/article/details/9153747" target="_blank" rel="external">http://blog.csdn.net/sinyu890807/article/details/9153747</a><br>《Android开发艺术探索》—— <a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="external">任玉刚</a><br>《Android群英传》——<a href="http://blog.csdn.net/eclipsexys" target="_blank" rel="external"> 徐宜生</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;ViewGroup是一组View的集合，它包含很多的子View和子VewGroup，是Android中所有布局的父类或间接父类，像LinearLayout、RelativeLayout等都是继承自ViewGroup的。但ViewGroup实际上也是一个Vie
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android消息处理机制 — 实用易懂</title>
    <link href="http://yoursite.com/2016/08/05/Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%20%E2%80%94%20%E5%AE%9E%E7%94%A8%E6%98%93%E6%87%82/"/>
    <id>http://yoursite.com/2016/08/05/Android消息处理机制 — 实用易懂/</id>
    <published>2016-08-05T09:40:41.000Z</published>
    <updated>2016-10-04T07:31:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="四个核心类"><a href="#四个核心类" class="headerlink" title="四个核心类"></a>四个核心类</h3><ul>
<li>Looper </li>
<li>Handler </li>
<li>Message </li>
<li>MessageQueue(MQ被封装到Looper里面了，我们不会直接与MQ打交道)</li>
</ul>
<h3 id="核心类详解"><a href="#核心类详解" class="headerlink" title="核心类详解"></a>核心类详解</h3><h4 id="线程控制者Looper"><a href="#线程控制者Looper" class="headerlink" title="线程控制者Looper"></a>线程控制者Looper</h4><blockquote>
<p>Looper的字面意思是“循环者”，它被设计用来使一个普通线程变成Looper线程。所谓Looper线程就是循环工作的线程。在程序开发中（尤其是GUI开发中），我们经常会需要一个线程不断循环，一旦有新任务则执行，执行完继续等待下一个任务，这就是Looper线程。使用Looper类创建Looper线程很简单：</p>
</blockquote>
<pre><code>public class LooperThread extends Thread {
    @Override
    public void run() {
        // 将当前线程初始化为Looper线程
        Looper.prepare();

        // ...其他处理，如实例化handler

        // 开始循环处理消息队列
        Looper.loop();
    }
}
</code></pre><blockquote>
<p>通过上面两行核心代码，你的线程就升级为Looper线程了！！！是不是很神奇？让我们放慢镜头，看看这两行代码各自做了什么。</p>
</blockquote>
<ul>
<li>Looper.prepare()</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/Looper.prepare().png" alt=""></p>
<blockquote>
<p>通过上图可以看到，现在你的线程中有一个Looper对象，它的内部维护了一个消息队列MQ。注意，一个Thread只能有一个Looper对象，为什么呢？咱们来看源码。</p>
</blockquote>
<pre><code>public class Looper {
    // 每个线程中的Looper对象其实是一个ThreadLocal，即线程本地存储(TLS)对象
    private static final ThreadLocal sThreadLocal = new ThreadLocal();
    // Looper内的消息队列
    final MessageQueue mQueue;
    // 当前线程
    Thread mThread;
    // 。。。其他属性

    // 每个Looper对象中有它的消息队列，和它所属的线程
    private Looper() {
        mQueue = new MessageQueue();
        mRun = true;
        mThread = Thread.currentThread();
    }

    // 我们调用该方法会在调用线程的TLS中创建Looper对象
    public static final void prepare() {
        if (sThreadLocal.get() != null) {
            // 试图在有Looper的线程中再次创建Looper将抛出异常
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper());
    }
    // 其他方法
}
</code></pre><blockquote>
<p>通过源码，prepare()背后的工作方式一目了然，其核心就是将looper对象定义为ThreadLocal。</p>
</blockquote>
<ul>
<li>Looper.loop()<br><img src="http://o9zgq2ik9.bkt.clouddn.com/Looper.loop().png" alt=""></li>
</ul>
<blockquote>
<p>调用loop方法后，Looper线程就开始真正工作了，它不断从自己的MQ中取出队头的消息(也叫任务)执行。其源码分析如下：</p>
</blockquote>
<pre><code>public static final void loop() {
        Looper me = myLooper();  //得到当前线程Looper
        MessageQueue queue = me.mQueue;  //得到当前looper的MQ

        // 这两行没看懂= = 不过不影响理解
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();
        // 开始循环
        while (true) {
            Message msg = queue.next(); // 取出message
            if (msg != null) {
                if (msg.target == null) {
                    // message没有target为结束信号，退出循环
                    return;
                }
                // 日志。。。
                if (me.mLogging!= null) me.mLogging.println(
                        &quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot;
                        + msg.callback + &quot;: &quot; + msg.what
                        );
                // 非常重要！将真正的处理工作交给message的target，即后面要讲的handler
                msg.target.dispatchMessage(msg);
                // 还是日志。。。
                if (me.mLogging!= null) me.mLogging.println(
                        &quot;&lt;&lt;&lt;&lt;&lt; Finished to    &quot; + msg.target + &quot; &quot;
                        + msg.callback);

                // 下面没看懂，同样不影响理解
                final long newIdent = Binder.clearCallingIdentity();
                if (ident != newIdent) {
                    Log.wtf(&quot;Looper&quot;, &quot;Thread identity changed from 0x&quot;
                            + Long.toHexString(ident) + &quot; to 0x&quot;
                            + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                            + msg.target.getClass().getName() + &quot; &quot;
                            + msg.callback + &quot; what=&quot; + msg.what);
                }
                // 回收message资源
                msg.recycle();
            }
        }
    }
</code></pre><blockquote>
<p>除了prepare()和loop()方法，Looper类还提供了一些有用的方法，比如Looper.myLooper()得到当前线程looper对象：</p>
</blockquote>
<pre><code>public static final Looper myLooper() {
    // 在任意线程调用Looper.myLooper()返回的都是那个线程的looper
    return (Looper)sThreadLocal.get();
}
</code></pre><blockquote>
<p>getThread()得到looper对象所属线程：</p>
</blockquote>
<pre><code>public Thread getThread() {
    return mThread;
}
</code></pre><blockquote>
<p>quit()方法结束looper循环：</p>
</blockquote>
<pre><code>public void quit() {
    // 创建一个空的message，它的target为NULL，表示结束循环消息
    Message msg = Message.obtain();
    // 发出消息
    mQueue.enqueueMessage(msg, 0);
}
</code></pre><blockquote>
<p>到此为止，你应该对Looper有了基本的了解，总结几点：</p>
</blockquote>
<ul>
<li>每个线程有且最多只能有一个Looper对象，它是一个ThreadLocal</li>
<li>Looper内部有一个消息队列，loop()方法调用后线程开始不断从队列中取出消息执行</li>
<li>Looper使一个线程变成Looper线程。</li>
</ul>
<blockquote>
<p>那么，我们如何往MQ上添加消息呢？下面有请Handler！</p>
</blockquote>
<h4 id="异步处理者Handler"><a href="#异步处理者Handler" class="headerlink" title="异步处理者Handler"></a>异步处理者Handler</h4><blockquote>
<p>什么是Handler？Handler扮演了往MQ上添加消息和处理消息的角色（只处理由自己发出的消息），即通知MQ它要执行一个任务(sendMessage)，并在loop到自己的时候执行该任务(handleMessage)，整个过程是异步的。Handler创建时会关联一个looper，默认的构造方法将关联当前线程的looper，不过这也是可以set的。默认的构造方法：</p>
</blockquote>
<pre><code>public class Handler {
    final MessageQueue mQueue;  // 关联的MQ
    final Looper mLooper;  // 关联的looper
    final Callback mCallback; 
    // 其他属性

    public Handler() {
        // 没看懂，直接略过，，，
        if (FIND_POTENTIAL_LEAKS) {
            final Class&lt;? extends Handler&gt; klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                    klass.getCanonicalName());
            }
        }
        // 默认将关联当前线程的looper
        mLooper = Looper.myLooper();
        // looper不能为空，即该默认的构造方法只能在looper线程中使用
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);
        }
        // 重要！！！直接把关联looper的MQ作为自己的MQ，因此它的消息将发送到关联looper的MQ上
        mQueue = mLooper.mQueue;
        mCallback = null;
    }

    // 其他方法
}
</code></pre><blockquote>
<p>下面我们就可以为之前的LooperThread类加入Handler：</p>
</blockquote>
<pre><code>public class LooperThread extends Thread {
    private Handler handler1;
    private Handler handler2;

    @Override
    public void run() {
        // 将当前线程初始化为Looper线程
        Looper.prepare();

        // 实例化两个handler
        handler1 = new Handler();
        handler2 = new Handler();

        // 开始循环处理消息队列
        Looper.loop();
    }
}
</code></pre><blockquote>
<p>加入handler后的效果如下图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/%E5%8A%A0%E5%85%A5handler%E5%90%8E%E7%9A%84%E6%95%88%E6%9E%9C.png" alt=""></p>
<blockquote>
<p>可以看到，一个线程可以有多个Handler，但是只能有一个Looper！</p>
</blockquote>
<h5 id="Handler发送消息"><a href="#Handler发送消息" class="headerlink" title="Handler发送消息"></a>Handler发送消息</h5><blockquote>
<p>有了handler之后，我们就可以使用 post(Runnable), postAtTime(Runnable, long), postDelayed(Runnable, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long)和sendMessageDelayed(Message, long)这些方法向MQ上发送消息了。光看这些API你可能会觉得handler能发两种消息，一种是Runnable对象，一种是message对象，这是直观的理解，但其实post发出的Runnable对象最后都被封装成message对象了，见源码：</p>
</blockquote>
<pre><code>// 此方法用于向关联的MQ上发送Runnable对象，它的run方法将在handler关联的looper线程中执行
    public final boolean post(Runnable r)
    {
       // 注意getPostMessage(r)将runnable封装成message
       return  sendMessageDelayed(getPostMessage(r), 0);
    }

    private final Message getPostMessage(Runnable r) {
        Message m = Message.obtain();  //得到空的message
        m.callback = r;  //将runnable设为message的callback，
        return m;
    }

    public boolean sendMessageAtTime(Message msg, long uptimeMillis)
    {
        boolean sent = false;
        MessageQueue queue = mQueue;
        if (queue != null) {
            msg.target = this;  // message的target必须设为该handler！
            sent = queue.enqueueMessage(msg, uptimeMillis);
        }
        else {
            RuntimeException e = new RuntimeException(
                this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
        }
        return sent;
    }
</code></pre><blockquote>
<p>其他方法就不罗列了，总之通过handler发出的message有如下特点：</p>
</blockquote>
<ul>
<li><p>message.target为该handler对象，这确保了looper执行到该message时能找到处理它的handler，即loop()方法中的关键代码<br>  msg.target.dispatchMessage(msg);</p>
</li>
<li><p>post发出的message，其callback为Runnable对象</p>
</li>
</ul>
<h5 id="Handler处理消息"><a href="#Handler处理消息" class="headerlink" title="Handler处理消息"></a>Handler处理消息</h5><blockquote>
<p>说完了消息的发送，再来看下handler如何处理消息。消息的处理是通过核心方法dispatchMessage(Message msg)与钩子方法handleMessage(Message msg)完成的，见源码</p>
</blockquote>
<pre><code>// 处理消息，该方法由looper调用
    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            // 如果message设置了callback，即runnable消息，处理callback！
            handleCallback(msg);
        } else {
            // 如果handler本身设置了callback，则执行callback
            if (mCallback != null) {
                 /* 这种方法允许让activity等来实现Handler.Callback接口，避免了自己编写handler重写handleMessage方法。见http://alex-yang-xiansoftware-com.iteye.com/blog/850865 */
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            // 如果message没有callback，则调用handler的钩子方法handleMessage
            handleMessage(msg);
        }
    }

    // 处理runnable消息
    private final void handleCallback(Message message) {
        message.callback.run();  //直接调用run方法！
    }
    // 由子类实现的钩子方法
    public void handleMessage(Message msg) {
    }
</code></pre><blockquote>
<p>可以看到，除了handleMessage(Message msg)和Runnable对象的run方法由开发者实现外（实现具体逻辑），handler的内部工作机制对开发者是透明的。这正是handler API设计的精妙之处！</p>
</blockquote>
<h5 id="Handler的用处"><a href="#Handler的用处" class="headerlink" title="Handler的用处"></a>Handler的用处</h5><blockquote>
<p>我在小标题中将handler描述为“异步处理大师”，这归功于Handler拥有下面两个重要的特点：</p>
</blockquote>
<ul>
<li>handler可以在任意线程发送消息，这些消息会被添加到关联的MQ上。</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/%E4%BB%BB%E6%84%8F%E7%BA%BF%E7%A8%8B%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.png" alt=""></p>
<ul>
<li>handler是在它关联的looper线程中处理消息的</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/%E5%85%B3%E8%81%94%E7%9A%84looper%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF.png" alt=""></p>
<blockquote>
<p>这就解决了android最经典的不能在其他非主线程中更新UI的问题。<em>android的主线程也是一个looper线程</em>(looper在android中运用很广)，我们在其中创建的handler默认将关联主线程MQ。因此，利用handler的一个solution就是在activity中创建handler并将其引用传递给worker thread，worker thread执行完任务后使用handler发送消息通知activity更新UI。(过程如图)</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/%E6%9B%B4%E6%96%B0UI.png" alt=""></p>
<blockquote>
<p>下面给出sample代码，仅供参考：</p>
</blockquote>
<pre><code>public class TestDriverActivity extends Activity {
    private TextView textview;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        textview = (TextView) findViewById(R.id.textview);
        // 创建并启动工作线程
        Thread workerThread = new Thread(new SampleTask(new MyHandler()));
        workerThread.start();
    }

    public void appendText(String msg) {
        textview.setText(textview.getText() + &quot;\n&quot; + msg);
    }

    class MyHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            String result = msg.getData().getString(&quot;message&quot;);
            // 更新UI
            appendText(result);
        }
    }
}

public class SampleTask implements Runnable {
    private static final String TAG = SampleTask.class.getSimpleName();
    Handler handler;

    public SampleTask(Handler handler) {
        super();
        this.handler = handler;
    }
    @Override
    public void run() {
        try {  // 模拟执行某项任务，下载等
            Thread.sleep(5000);
            // 任务完成后通知activity更新UI
            Message msg = prepareMessage(&quot;task completed!&quot;);
            // message将被添加到主线程的MQ中
            handler.sendMessage(msg);
        } catch (InterruptedException e) {
            Log.d(TAG, &quot;interrupted!&quot;);
        }

    }

    private Message prepareMessage(String str) {
        Message result = handler.obtainMessage();
        Bundle data = new Bundle();
        data.putString(&quot;message&quot;, str);
        result.setData(data);
        return result;
    }
}
</code></pre><blockquote>
<p>当然，handler能做的远远不仅如此，由于它能post Runnable对象，它还能与Looper配合实现经典的Pipeline Thread(流水线线程)模式</p>
</blockquote>
<h4 id="封装任务Message"><a href="#封装任务Message" class="headerlink" title="封装任务Message"></a>封装任务Message</h4><blockquote>
<p>在整个消息处理机制中，message又叫task，封装了任务携带的信息和处理该任务的handler。message的用法比较简单，这里不做总结了。但是有这么几点需要注意（待补充）：</p>
<ul>
<li>尽管Message有public的默认构造方法，但是你应该通过Message.obtain()来从消息池中获得空消息对象，以节省资源。</li>
<li>如果你的message只需要携带简单的int信息，请优先使用Message.arg1和Message.arg2来传递信息，这比用Bundle更省内存</li>
<li>擅用message.what来标识信息，以便用不同方式处理message。</li>
</ul>
</blockquote>
<p><strong>参考资料</strong><br><a href="http://www.cnblogs.com/codingmyworld/archive/2011/09/12/2174255.html" target="_blank" rel="external">博文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;四个核心类&quot;&gt;&lt;a href=&quot;#四个核心类&quot; class=&quot;headerlink&quot; title=&quot;四个核心类&quot;&gt;&lt;/a&gt;四个核心类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Looper &lt;/li&gt;
&lt;li&gt;Handler &lt;/li&gt;
&lt;li&gt;Message &lt;/li&gt;
&lt;li
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android的线程和线程池</title>
    <link href="http://yoursite.com/2016/07/01/Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2016/07/01/Android的线程和线程池/</id>
    <published>2016-07-01T02:36:34.000Z</published>
    <updated>2016-10-03T15:21:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>线程：在操作系统（OS）中，线程是OS调度的最小单元，同时又是一种受限的系统资源，不可能无限制的产生，并且其创建和销毁都会有一定的开销。当OS中存在大量的线程时，OS会通过时间片轮询的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数目小于等于CPU的核心数，一般是不可能的。</p>
<p>线程池：在一个进程中频繁地创建和销毁线程不是一种高效的做法，正确地做法是使用线程池。线程池中会缓存一定数目的线程，然后通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。Android中的线程池来源于Java，主要是通过Executor来派生特定类型的线程池，不同类型的线程池又具有不同的特性。</p>
<p>按用途来划分，线程有两种：</p>
</blockquote>
<ul>
<li>主线程：处理和界面有关的事情</li>
<li>子线程：执行耗时的一些操作</li>
</ul>
<blockquote>
<p>由于Android的特性，如果在主线程中执行耗时操作，系统会无法及时地响应，并抛出ANR（应用程序无响应），因此，耗时操作必须要放在子线程中执行。</p>
<p>除了传统的Java中的Thread类表示线程外，在Android中，系统提供了自己特有的可以扮演线程角色的类，如AsyncTask，IntentService，HandlerThread（一种特殊的线程）等，需要注意的是这些类本质上仍是创痛的线程，AsyncTask底层用到了Java中的线程池，而IntentService和HandlerThread的底层则直接使用了Thread线程类。</p>
</blockquote>
<ul>
<li>AsyncTask封装了线程池和Handler，主要是方便开发者在子线程中更新UI。</li>
<li>HandlerThread是一个具有消息循环的线程，在它的内部可以使用Handler。</li>
<li>IntentService是一个服务，系统对其进行了封装，使其可以方便地执行后台任务，IntentService内部采用HandlerThread来执行任务，任务执行完毕后，其会自动退出。从任务执行的角度来看，IntentService的作用很像一个后台线程，但是IntentService是一种服务，它是不容易被系统杀死的，从而尽量保证任务的执行，而如果是一个后台线程的话，由于这个时候进程中没有活动的四大组件，那么这个进程的优先级就会非常低，会很容易被系统杀死，这是IntentService的优点。</li>
</ul>
<h3 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h3><blockquote>
<p>Android沿用Java的线程模型。</p>
</blockquote>
<h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><blockquote>
<p>主线程(UI线程)是指进程所拥有的线程，在Java中默认情况下一个进程只有一个线程，这个线程就是主线层。主线程的主要任务是处理于界面的交互相关的逻辑，在Android中就是运行四大组件以及处理和它们的交互，因为用户随时会和界面发生交互，因此主线程在任何时候都必须具有较高的响应速度，否则就会造成界面卡顿，用户体验不好。</p>
</blockquote>
<h4 id="子线程"><a href="#子线程" class="headerlink" title="子线程"></a>子线程</h4><blockquote>
<p>为了保持较高的响应速度，在主线程中就不应该执行耗时任务，这个时候子线程的作用就体现出来了。子线程又被称为工作线程，除了主线程外，其他的都是子线程。子线程就是要执行耗时任务，如网络请求，I/O操作等。Android3.0以后的系统都要求网络访问必须在子线程中进行，否则就会访问失败并抛出NetworkOnMainThreadException异常，这么做主要是避免主线程被耗时任务阻塞，造成ANR。</p>
</blockquote>
<h3 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h3><blockquote>
<p>除去传统的Thread， Android中的线程形态有AsyncTask，IntentService，HandlerThread三种，它们的底层实现也是线程，只是它们具有特殊的表现形式，同时在使用上也各有优缺点。</p>
</blockquote>
<h4 id="AsyncTask及其原理"><a href="#AsyncTask及其原理" class="headerlink" title="AsyncTask及其原理"></a>AsyncTask及其原理</h4><blockquote>
<p>为了简化子线程中访问UI的过程，系统提供了AsyncTask。不同版本API的AsyncTask具有不同的表现，尤其是在多任务并发执行上。</p>
<p>AsyncTask是一种轻量级的异步任务类，可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程中更新UI。从实现上说，AsyncTask封装了Thread和Handler，并通过AsyncTask可以更加方便的执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合执行特别耗时的后台任务，对于特别耗时的任务，建议使用线程池。</p>
<p>AsyncTask是一个抽象范型类，使用时要通过子类继承，其提供了Params，Progress，Result三个范型参数，其中Params表示参数的类型，Progress表示后台任务执行进度的类型，Result表示后台任务的返回结果类型，如果AsyncTask确实不需要传递任何参数，这三个范型参数可以使用Void来代替。AysncTask的类声明如下：</p>
</blockquote>
<pre><code>public abstract class AsyncTask&lt;Params, Progress, Result&gt;
</code></pre><blockquote>
<p>AsyncTask提供了4个核心方法，具体解释如下：</p>
</blockquote>
<ol>
<li>onProExecute(), 在主线程中执行，在异步任务执行之前，此方法会被调用，一般用于一些准备工作。</li>
<li>doInBackground(Params … params), 在线程池中执行，用于执行异步任务，params参数表示异步任务的输入参数。在此方法中可以通过调用publishProgress()方法来更新任务的进度， publishProgress()方法会触发onProgressUpdate()方法的调用。另外此方法需要返回计算结果给onPostExecute()方法。</li>
<li>onProgressUpdate(Progress … values), 在主线程中执行，当后台任务的执行进度发生改变时，此方法通过publishProgress()方法被调用。</li>
<li>onPostExecute(Result result), 在主线程中执行，当后台异步任务执行完毕之后，此方法会被调用，其中，result参数时后台异步任务的返回值，即doInBackground方法的返回值。</li>
</ol>
<blockquote>
<p>4个方法的执行顺序是：onPreExecute, doInBackground, onPostExecute. onProgressUpdate方法看情况执行，如果publishProgress方法在doInBackground方法中被调用，其执行顺序就在onPostExecute之前，否则，其不执行。除了上述4个方法外，AsyncTask也提供onCancelled()方法，当异步任务被取消时，onCancelled()方法会在主线程中被调用执行，这个时候onPostExecute方法就不会再被调用。</p>
</blockquote>
<p><strong>典型案例</strong></p>
<pre><code>private class DownLoadAsyncTask extends AsyncTask&lt;URL, Integer, Long&gt; {
    protected Long doInBackground(URL ... urls) {
        int count = urls.length;
        long totalsize = 0;
        for(int i = 0; i &lt; count; i++) {
            totalsize += Downloader.down(urls[i]);
            publishProgress((int) ((i / (float) count * 100));
            // Escape early if cancel() is called
            if(isCancelled()) {
                break;
            }
        }
        return totalsize;
    }
    protected void onProgressUpdate(Integer ... progress) {
        setProgressPercent(progress[0]);
    }
    protected void onPostExecute(Long result) {
        showDialog(&quot;Downloaded&quot; + result + &quot;bytes&quot;);
    }
}
</code></pre><blockquote>
<p>上面实现了一个具体的AsyncTask类，主要功能时模拟文件下载的过程，输入参数类型为URL，后台任务进程参数为Integer，后台任务的返回结果为Long类型。注意一点：括号中的 … 表示参数个数不定，它代表一种数组型的参数，在这点上Java和C是一致的。</p>
<p>具体的AsyncTask类定义完成后，当要执行下载任务时，通过下面方式完成：</p>
</blockquote>
<pre><code>AsyncTask task = new DownloadAsyncTask();
task.execute(url1,url2,url3);
</code></pre><p><strong>AsyncTask在具体的使用过程中的一些条件限制：</strong></p>
<ol>
<li>AsyncTask的类必须在主线程中加载，这意味着第一次访问AsyncTask必须发生在主线程，当然这个过程在Android4.1及以上的版本中已经被系统自动完成。在5.0的源码中，可以看到在ActivityThread的main方法中会调用AsyncTask的init方法，这就满足了这个限制条件。至于为什么必须满足这个条件，在下面小节的原理分析中会给予解答。<ol>
<li>AsyncTask实现类的对象必须在主线程中创建。</li>
<li>AsyncTask实现类的execute()方法也必须在主线程中被调用。</li>
<li>不要在程序中手动直接调用onPreExecute(), doInBackground(), onPostExecute(), onProgressUpdate()这四个方法。</li>
<li>一个AsyncTask实现类对象只能执行一次，即只能调用一次execute()方法，否则会报异常。</li>
<li>Android1.6之前，AsyncTask是串行执行任务的，1.6的时候开始采用线程池处理并行任务，但是从3.0开始，为了避免AsyncTask所带来的并发错误，其又再一次采用一个线程来串行执行任务。尽管如此，3.0以后的版本中，我们仍然可以通过AsyncTask的executeOnExecuter方法来并行执行任务。</li>
</ol>
</li>
</ol>
<h4 id="AsyncTask的工作原理"><a href="#AsyncTask的工作原理" class="headerlink" title="AsyncTask的工作原理"></a>AsyncTask的工作原理</h4><blockquote>
<p>待完成</p>
</blockquote>
<h4 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h4><blockquote>
<p>HandlerThread继承了Thread，是一种可以使用Handler的Thread，它的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了。</p>
<p>HandlerThread的run方法如下所示：</p>
</blockquote>
<pre><code>public void run() {
    mTid = Process.myTid();
    Looper.prepare();
    synchrinized(this) {
        mLooper = Looper.myLooper();
        notifyAll();
    }
    Process.setThreadPriority(mPriority);
    onLooperPrepared();
    Looper.loop();
    mTid = -1;
}
</code></pre><blockquote>
<p>从HandlerThread的实现来看，它和普通的Thread有显著的不同，普通的Thread主要用于在run方法中执行一个耗时任务，而HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式来通知HandlerThread执行一个具体的任务。HandlerThread类是一个很有用的类，它在Android中的一个具体应用场景就是IntentService，将在下节介绍。由于HandlerThread的run方法是一个无限循环，因此当明确不需要再使用的时候，可以通过它的quit或者quitSafely方法来终止线程的执行，好的编程习惯。</p>
</blockquote>
<h4 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h4><blockquote>
<p>Todo</p>
</blockquote>
<h3 id="Android中的线程池"><a href="#Android中的线程池" class="headerlink" title="Android中的线程池"></a>Android中的线程池</h3><p><strong>线程池的优点</strong></p>
<ol>
<li>重用线程池中的线程，避免因为创建线程和销毁线程带来不必要的内存开销。</li>
<li>能有效控制线程池中的最大并发数，避免大量的线程之间因互相抢占资源而导致的阻塞现象。</li>
<li>能够对线程池进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ol>
<blockquote>
<p>Android中线程池的概念来自Java中的Executer，Executer是一个接口，真正的线程池实现为ThreadPoolExecuter，其提供了一系列的参数来配置线程池，通过不同的参数可以查创建不同的线程池。从线程池的功能特性上来说，Android的线程池有4类，并且可以通过Executers所提供的工厂方法来得到。</p>
</blockquote>
<h4 id="ThreadPoolExecuter"><a href="#ThreadPoolExecuter" class="headerlink" title="ThreadPoolExecuter"></a>ThreadPoolExecuter</h4><blockquote>
<p>ThreadPoolExecuter是线程池的真正实现，它的构造方法提供了一系列参数来配置线程池。下面是其一个比较常用的构造方法，构造方法中的参数会直接影响线程池的功能特性。</p>
</blockquote>
<pre><code>public ThreadPoolExecutor(
        int corePoolSize, 
        int maximumPoolSize, 
        long keepAliveTime, 
        TimeUnit unit, 
        BlockingQueue&lt;Runnable&gt; workQueue, 
        ThreadFactory threadFactory
)
</code></pre><blockquote>
<p>下面会介绍各个参数的具体用法</p>
</blockquote>
<ul>
<li>corePoolSize</li>
</ul>
<blockquote>
<p>线程池的核心线程数目，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔由keepAliveTime所指定，当等待时间超过keepAliveTime所指定的时长后，核心线程就会被终止。</p>
</blockquote>
<ul>
<li>maximumPoolSize</li>
</ul>
<blockquote>
<p>线程池所能容纳的最大线程数，当活动线程数达到这个数值后，后续的新任务将会被阻塞。</p>
</blockquote>
<ul>
<li>keepAliveTime</li>
</ul>
<blockquote>
<p>非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。当ThreadPoolExecutor的allowCoreThreadTimeOut这个属性设置为true时，keepAliveTime同样会作用于核心线程。</p>
</blockquote>
<ul>
<li>unit</li>
</ul>
<blockquote>
<p>用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的TimeUnit.MILLISECONDS(毫秒), TimeUnit.SECONDS(秒), TimeUnit.MINUTES(分钟)等。</p>
</blockquote>
<ul>
<li>workQueue</li>
</ul>
<blockquote>
<p>线程池中的任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中。</p>
</blockquote>
<ul>
<li>threadFactory</li>
</ul>
<blockquote>
<p>线程工厂，为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个方法，Thread  newThread(Runnable r).</p>
<p>除了上面的这些主要参数外，还有一个不常用的参数RejectedExecutionHandler handler。当线程池无法执行新任务时，这可能是由于任务队列已满或者是无法成功执行任务，这个时候ThreadPoolExecutor会调用handler的rejectedExecution方法来通知调用者，默认情况下rejectedExecution方法会直接抛出一个RejectedExecutionException。ThreadPoolExecutor为RejectedExecutionHandler提供了几个可选值：CallerRunsPolicy，AbortPolicy，DiscardPolicy和DiscardOldestPolicy，其中AbortPolicy是默认值，它会直接抛出RejectedExecutionException。</p>
<p>ThreadPoolExecutor执行任务时大致遵循如下规则：</p>
</blockquote>
<ol>
<li>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li>
<li>如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</li>
<li>如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</li>
<li>如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。</li>
</ol>
<blockquote>
<p>ThreadPoolExecutor的参数配置在AsyncTask中有明显的体现，如下：</p>
</blockquote>
<pre><code>private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
private static final int CORE_POOL_SIZE = CPU_COUNT + 1;
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE = 1;

private static final ThreadFactory sThreadFactory = new ThreadFactory() {
    private final AtomicInteger mCount = new AtomicInteger(1);
    public Thread newThread(Runnable r) {
        return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement());
    }
}

private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);

/**
 * An Executor that can be used to execute tasks in parallel
 **/
public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);
</code></pre><blockquote>
<p>从上面的代码可以知道，AsyncTask对THREAD_POOL_EXECUTOR这个线程池进行了配置，配置后的线程池规格如下：</p>
</blockquote>
<ul>
<li>核心线程池等于CPU核心数+1</li>
<li>线程池的最大线程数为CPU核心数的2倍+1</li>
<li>核心线程无超时机制，非核心线程在闲置时的超时时间为1秒</li>
<li>任务队列的容量为128</li>
</ul>
<h4 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h4><blockquote>
<p>Android中常见的四类不同功能特性的线程池，都是通过直接或间接的配置ThreadPoolExecutor的参数来实现具有不同功能特性的线程池。</p>
</blockquote>
<h5 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h5><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre><blockquote>
</blockquote>
<h5 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h5><pre><code>public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L,TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre><h5 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h5><pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
}

public static ScheduledThreadPoolExecutor (int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0 ,NANOSECONDS, new DelayedWorkQueue());
}
</code></pre><h5 id="SingleThreadPool"><a href="#SingleThreadPool" class="headerlink" title="SingleThreadPool"></a>SingleThreadPool</h5><pre><code>public static ExecutorService newSingleThreadPool() {
        return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre><p><strong>系统预置的四种线程池的典型使用方法</strong></p>
<pre><code>Runnable command = new Runnable() {
        @Override
        public void run() {
            SystemClock.sleep(2000);
        }
}

ExecutorService fixedThreadPool = Executors.newFixedThreadPool(4);
fixedThreadPool.execute(command);

ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
cachedThreadPool.execute(command);

ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(4);
// 2000ms后执行command
scheduledThreadPool.schedule(command, 2000, TimeUnit.MILLISECONDS);
// 延迟10ms后，每隔1000ms执行一次command
scheduledThreadPool.scheduleAtFixedRate(command, 10, 1000, TimeUnit.MILLISECONDS);

ExecutorService singleThreadPool = Executors.newSingleThreadPool();
singleThreadPool.execute(command);
</code></pre><p><strong>参考资料</strong></p>
<p>《Android开发艺术探索》 —  任玉刚</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;线程：在操作系统（OS）中，线程是OS调度的最小单元，同时又是一种受限的系统资源，不可能无限制的产生，并且其创建和
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
