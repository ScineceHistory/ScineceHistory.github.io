<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sh2zqp</title>
  <subtitle>Keep Learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-10T13:13:17.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>QinPeng Zhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Homebrew的安装及使用</title>
    <link href="http://yoursite.com/2017/10/10/Homebrew%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/10/10/Homebrew的安装及使用/</id>
    <published>2017-10-10T12:51:19.000Z</published>
    <updated>2017-10-10T13:13:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">官网</a><br><a href="https://zh.wikipedia.org/wiki/Homebrew" target="_blank" rel="external">维基百科</a><br><a href="http://www.jianshu.com/p/4e80b42823d5" target="_blank" rel="external">Homebrew的安装及使用</a><br><a href="https://palemoky.github.io/2016/12/09/Mac%E4%B8%ADHomebrew%E6%95%99%E7%A8%8B/" target="_blank" rel="external">Mac中Homebrew教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://brew.sh/index_zh-cn.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Homebrew&quot; targ
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="软件包依赖管理工具" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
      <category term="brew" scheme="http://yoursite.com/tags/brew/"/>
    
  </entry>
  
  <entry>
    <title>WebView详解</title>
    <link href="http://yoursite.com/2017/08/12/WebView%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/08/12/WebView详解/</id>
    <published>2017-08-12T02:36:57.000Z</published>
    <updated>2017-08-14T14:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="WebView简介"><a href="#WebView简介" class="headerlink" title="WebView简介"></a>WebView简介</h3><blockquote>
<p>为了方便开发者实现在<strong>app内展示网页</strong>并<strong>与网页交互的需求</strong>，Android SDK提供了<strong>WebView组件</strong>。它继承自AbsoluteLayout，<strong>展示网页</strong>的同时，也可以在其中<strong>放入其他的子View</strong>。现如今，<strong>Hybrid(混合)应用</strong>似乎占据的<strong>APP的主流类型</strong>，那么关于WebView的使用就变得越发的重要。</p>
<p>从<strong>Android 4.4（KitKat）</strong>开始，原本<strong>基于WebKit的WebView</strong>开始<strong>基于Chromium内核</strong>，这一改动大大<strong>提升了WebView组件的性能</strong>以及<strong>对HTML5,CSS3,JavaScript的支持</strong>。不过它的<strong>API却没有很大的改动</strong>，在兼容低版本的同时只引进了<strong>少部分新的API</strong>，并不需要你做很大的改动。不过有几点改变需要注意，但我尝试着翻译了下，发现还是英文原文说得好，<a href="https://developer.android.com/guide/webapps/migrating.html" target="_blank" rel="external">Migrating to WebView in Android 4.4</a>。</p>
<p>在WebView中，有几个地方是我们可以使用来定制我们的WebView各种行为的，分别是：<strong>WebSettings</strong>、<strong>JavaScriptInterface</strong>、<strong>WebViewClient</strong>以及<strong>WebChromeClient</strong>。这些我都会在接下来的文章中一一介绍。</p>
</blockquote>
<h3 id="WebView基本使用"><a href="#WebView基本使用" class="headerlink" title="WebView基本使用"></a>WebView基本使用</h3><blockquote>
<p>下面简单介绍下 WebView 的基本使用：</p>
<p>首先，新建一个工程，在 layout 文件里放入一个 WebView 控件（当然也可以通过Java代码动态放入，这里不演示了）</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;
    &lt;WebView
        android:id=&quot;@+id/web_view&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;/&gt;
&lt;/LinearLayout&gt;
</code></pre><blockquote>
<p>然后，在Activity的onCreate方法里写入如下代码：</p>
</blockquote>
<pre><code>String url = &quot;https://www.google.com&quot;;
WebView webView = (WebView) findViewById(R.id.web_view);
webView.loadUrl(url);
</code></pre><blockquote>
<p>接着，在AndroidManifest声明访问网络的权限：</p>
</blockquote>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
</code></pre><blockquote>
<p>Done，这时运行app，它已经可以<strong>访问指定地址的网页</strong>了。</p>
<p>上面提到了WebView继承自AbsoluteLayout，可以在其中<strong>放入一些子View</strong>，那也顺手来一下。Layout文件改为：</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  android:layout_width=&quot;match_parent&quot;
  android:layout_height=&quot;match_parent&quot;&gt;
  &lt;WebView
      android:id=&quot;@+id/web_view&quot;
      android:layout_width=&quot;match_parent&quot;
      android:layout_height=&quot;match_parent&quot;&gt;
      &lt;Button
          android:id=&quot;@+id/button&quot;
          android:layout_width=&quot;wrap_content&quot;
          android:layout_height=&quot;wrap_content&quot;
          android:layout_x=&quot;170dp&quot;
          android:layout_y=&quot;400dp&quot;
          android:background=&quot;@color/colorAccent&quot;
          android:text=&quot;@string/app_name&quot; /&gt;
  &lt;/WebView&gt;
&lt;/LinearLayout&gt;
</code></pre><blockquote>
<p>Activity的onCreate里加上：</p>
</blockquote>
<pre><code>Button button = (Button) findViewById(R.id.button);
button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        Toast.makeText(getApplicationContext(), &quot;系好安全带!&quot;, Toast.LENGTH_SHORT).show();
    }});
</code></pre><blockquote>
<p>这时，运行app，里面就会多出一个Button，但如果你真的运行的话，你就会发现，<strong>app会自动跳到浏览器</strong>并打开指定的网页，而并非在app内展示网页，那这就与我们的初衷背道而驰了，那么要如何实现网页在App内打开呢?这就引出了下面的章节会提到的东西：<strong>WebViewClient</strong>。我先将代码贴出，具体实现原理留到下节说明。</p>
<p>最终XML布局就如上面那样，Java代码（最终）如下：</p>
</blockquote>
<pre><code>public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        String url = &quot;https://www.google.com&quot;;
        WebView webView = (WebView) findViewById(R.id.web_view);
        webView.loadUrl(url);

        webView.setWebViewClient(new WebViewClient() {
            @Override
            public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
                view.loadUrl(request.toString());
                return true;
            }
        });

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Toast.makeText(getApplicationContext(), &quot;系好安全带!&quot;, Toast.LENGTH_SHORT).show();
            }
        });
    }}
</code></pre><h3 id="WebView常用方法"><a href="#WebView常用方法" class="headerlink" title="WebView常用方法"></a>WebView常用方法</h3><blockquote>
<p>接下来再介绍一些<strong>WebView的常用方法</strong>，具体演示会在后面章节的代码里统一展示。</p>
</blockquote>
<ul>
<li>String getUrl()：获取当前页面的URL。</li>
<li>reload()：重新reload当前的URL，即刷新。</li>
<li>boolean canGoBack()：用来确认WebView里是否还有可回退的历史记录。通常我们会在WebView里重写返回键的点击事件，通过该方法判断WebView里是否还有历史记录，若有则返回上一页。</li>
<li>boolean canGoForward()：用来确认WebView是否还有可向前的历史记录。</li>
<li>boolean canGoBackOrForward(int steps)：以当前的页面为起始点，用来确认WebView的历史记录是否足以后退或前进给定的步数，正数为前进，负数为后退。</li>
<li>goBack()：在WebView历史记录后退到上一项。</li>
<li>goForward()：在WebView历史记录里前进到下一项。</li>
<li>goBackOrForward(int steps)：以当前页面为起始点，前进或后退历史记录中指定的步数，正数为前进，负数为后退。</li>
<li>clearCache(boolean includeDiskFiles)：清空网页访问留下的缓存数据。需要注意的是，由于缓存是全局的，所以只要是WebView用到的缓存都会被清空，即便其他地方也会使用到。该方法接受一个参数，从命名即可看出作用。若设为false，则只清空内存里的资源缓存，而不清空磁盘里的。</li>
<li>clearHistory()：清除当前webview访问的历史记录。</li>
<li>clearFormData()：清除自动完成填充的表单数据。需要注意的是，该方法仅仅清除当前表单域自动完成填充的表单数据，并不会清除WebView存储到本地的数据。</li>
<li>onPause()：当页面被失去焦点被切换到后台不可见状态，需要执行onPause操作，该操作会通知内核安全地暂停所有动作，比如动画的执行或定位的获取等。需要注意的是该方法并不会暂停JavaScript的执行，若要暂停JavaScript的执行请使用接下来的这个方法。</li>
<li>onResume()：在先前调用onPause()后，我们可以调用该方法来恢复WebView的运行。</li>
<li>pauseTimers()：该方法面向全局整个应用程序的webview，它会暂停所有webview的layout，parsing，JavaScript Timer。当程序进入后台时，该方法的调用可以降低CPU功耗。</li>
<li>resumeTimers()：恢复pauseTimers时的所有操作。</li>
<li><p>destroy()：销毁WebView。需要注意的是：这个方法的调用应在WebView从父容器中被remove掉之后。我们可以手动地调用</p>
<p>  rootLayout.removeView(webView);<br>  webView.destroy();</p>
</li>
<li><p>getScrollY()：该方法返回的当前可见区域的顶端距整个页面顶端的距离，也就是当前内容滚动的距离。</p>
</li>
<li>getHeight()：方法都返回当前WebView这个容器的高度。其实以上两个方法都属于View。</li>
<li><p>getContentHeight()：该方法返回整个HTML页面的高度，但该高度值并不等同于当前整个页面的高度，因为WebView有缩放功能， 所以当前整个页面的高度实际上应该是原始HTML的高度再乘上缩放比例。因此，准确的判断方法应该是  </p>
<p>  if (webView.getContentHeight() * webView.getScale() == (webView.getHeight() + webView.getScrollY())) {</p>
<pre><code>//已经处于底端}if(webView.getScrollY() == 0){
//处于顶端}
</code></pre></li>
<li><p>pageUp(boolean top)：将WebView展示的页面滑动至顶部。</p>
</li>
<li>pageDown(boolean bottom)：将WebView展示的页面滑动至底部。</li>
</ul>
<h3 id="WebSettings"><a href="#WebSettings" class="headerlink" title="WebSettings"></a>WebSettings</h3><blockquote>
<p>WebSettings是用来管理WebView配置的类。当WebView第一次创建时，内部会包含一个默认配置的集合。若我们想更改这些配置，便可以通过WebSettings里的方法来进行设置。</p>
<p>WebSettings对象可以通过<strong>WebView.getSettings()</strong>获得，它的生命周期是与它的WebView本身息息相关的，如果WebView被销毁了，那么任何由WebSettings调用的方法也同样不能使用。</p>
<p>获取WebSettings对象</p>
</blockquote>
<pre><code>WebSettings webSettings = webView.getSettings();
</code></pre><blockquote>
<p>WebSettings常用方法</p>
<p>（几乎所有的set方法都有相应的get方法，这里就只介绍set了。另，所有未写方法返回值类型的皆为空类型）</p>
</blockquote>
<ul>
<li>setJavaScriptEnabled(boolean flag)：设置WebView是否可以运行JavaScript。</li>
<li>setJavaScriptCanOpenWindowsAutomatically(boolean flag)：设置WebView是否可以由JavaScript自动打开窗口，默认为false，通常与JavaScript的window.open()配合使用。</li>
<li>setAllowFileAccess(boolean allow)：启用或禁用WebView访问文件数据。</li>
<li>setBlockNetworkImage(boolean flag)：禁止或允许WebView从网络上加载图片。需要注意的是，如果设置是从禁止到允许的转变的话，图片数据并不会在设置改变后立刻去获取，而是在WebView调用reload()的时候才会生效。  </li>
</ul>
<blockquote>
<p>这个时候，需要确保这个app拥有访问Internet的权限，否则会抛出安全异常。</p>
<p>通常没有禁止图片加载的需求的时候，完全不用管这个方法，因为当我们的app拥有访问Internet的权限时，这个flag的默认值就是false。</p>
</blockquote>
<ul>
<li>setSupportZoom(boolean support)：设置是否支持缩放。</li>
<li>setBuiltInZoomControls(boolean enabled)：显示或不显示缩放按钮（wap网页不支持）。</li>
<li>setSupportMultipleWindows(boolean support)：设置WebView是否支持多窗口。</li>
<li>setLayoutAlgorithm(WebSettings.LayoutAlgorithm l)：指定WebView的页面布局显示形式，调用该方法会引起页面重绘。默认值为LayoutAlgorithm#NARROW_COLUMNS。</li>
<li>setNeedInitialFocus(boolean flag)：通知WebView是否需要设置一个节点获取焦点当WebView#requestFocus(int,android.graphics.Rect)被调用时，默认为true。</li>
<li>setAppCacheEnabled(boolean flag)：启用或禁用应用缓存。</li>
<li>setAppCachePath(String appCachePath)：设置应用缓存路径，这个路径必须是可以让app写入文件的。该方法应该只被调用一次，重复调用会被无视</li>
<li>setCacheMode(int mode)：用来设置WebView的缓存模式。当我们加载页面或从上一个页面返回的时候，会按照设置的缓存模式去检查并使用（或不使用）缓存。  </li>
</ul>
<blockquote>
<p>缓存模式有四种：</p>
</blockquote>
<ul>
<li>LOAD_DEFAULT：默认的缓存使用模式。在进行页面前进或后退的操作时，如果缓存可用并未过期就优先加载缓存，否则从网络上加载数据。这样可以减少页面的网络请求次数。</li>
<li>LOAD_CACHE_ELSE_NETWORK：只要缓存可用就加载缓存，哪怕它们已经过期失效。如果缓存不可用就从网络上加载数据。</li>
<li>LOAD_NO_CACHE：不加载缓存，只从网络加载数据。</li>
<li>LOAD_CACHE_ONLY：不从网络加载数据，只从缓存加载数据。  </li>
</ul>
<blockquote>
<p>通常我们可以根据网络情况将这几种模式结合使用，比如有网的时候使用LOAD_DEFAULT，离线时使用LOAD_CACHE_ONLY、LOAD_CACHE_ELSE_NETWORK，让用户不至于在离线时啥都看不到。</p>
</blockquote>
<ul>
<li>setDatabaseEnabled(boolean flag)：启用或禁用数据库缓存。</li>
<li>setDomStorageEnabled(boolean flag)：启用或禁用DOM缓存。</li>
<li>setUserAgentString(String ua)：设置WebView的UserAgent值。</li>
<li>setDefaultEncodingName(String encoding)：设置编码格式，通常都设为“UTF-8”。</li>
<li>setStandardFontFamily(String font)：设置标准的字体族，默认“sans-serif”。</li>
<li>setCursiveFontFamily：设置草书字体族，默认“cursive”。</li>
<li>setFantasyFontFamily：设置CursiveFont字体族，默认“cursive”。</li>
<li>setFixedFontFamily：设置混合字体族，默认“monospace”。</li>
<li>setSansSerifFontFamily：设置梵文字体族，默认“sans-serif”。</li>
<li>setSerifFontFamily：设置衬线字体族，默认“sans-serif”</li>
<li>setDefaultFixedFontSize(int size)：设置默认填充字体大小，默认16，取值区间为<a href="">1-72</a>，超过范围，使用其上限值。</li>
<li>setDefaultFontSize(int size)：设置默认字体大小，默认16，取值区间<a href="">1-72</a>，超过范围，使用其上限值。<br>98- setMinimumFontSize：设置最小字体，默认8. 取值区间<a href="">1-72</a>，超过范围，使用其上限值。</li>
<li>setMinimumLogicalFontSize：设置最小逻辑字体，默认8. 取值区间<a href="">1-72</a>，超过范围，使用其上限值。  </li>
</ul>
<blockquote>
<p>以上就是一些WebSettings的常用方法，具体的使用以及一些缓存的问题会在接下来的代码以及文章中有更加直观的说明。</p>
</blockquote>
<h3 id="WebViewClient"><a href="#WebViewClient" class="headerlink" title="WebViewClient"></a>WebViewClient</h3><blockquote>
<p>从名字上不难理解，这个类就像<strong>WebView的委托人</strong>一样，是帮助WebView处理各种通知和请求事件的，我们可以称他为WebView的“内政大臣”。</p>
</blockquote>
<ul>
<li>onLoadResource(WebView view, String url)：该方法在加载页面资源时会回调，每一个资源（比如图片）的加载都会调用一次。</li>
<li>onPageStarted(WebView view, String url, Bitmap favicon)：该方法在WebView开始加载页面且仅在Main frame loading（即整页加载）时回调，一次Main frame的加载只会回调该方法一次。我们可以在这个方法里设定开启一个加载的动画，告诉用户程序在等待网络的响应。</li>
<li>onPageFinished(WebView view, String url)：该方法只在WebView完成一个页面加载时调用一次（同样也只在Main frame loading时调用），我们可以可以在此时关闭加载动画，进行其他操作。</li>
<li>onReceivedError(WebView view, WebResourceRequest request, WebResourceError error)：该方法在web页面加载错误时回调，这些错误通常都是由无法与服务器正常连接引起的，最常见的就是网络问题。 这个方法有两个地方需要注意：  </li>
</ul>
<blockquote>
<p>1.这个方法只在与服务器无法正常连接时调用，类似于服务器返回错误码的那种错误（即HTTP ERROR），该方法是不会回调的，因为你已经和服务器正常连接上了（全怪官方文档(︶^︶)）；</p>
<p>2.这个方法是新版本的<strong>onReceivedError()</strong>方法，从<strong>API23</strong>开始引进，与旧方法onReceivedError(WebView view,int errorCode,String description,String failingUrl)不同的是，新方法在页面局部加载发生错误时也会被调用（比如页面里两个子Tab或者一张图片）。这就意味着该方法的调用频率可能会更加频繁，所以我们应该在该方法里执行尽量少的操作。</p>
</blockquote>
<ul>
<li>onReceivedHttpError(WebView view, WebResourceRequest request, WebResourceResponse errorResponse)：上一个方法提到onReceivedError并不会在服务器返回错误码时被回调，那么当我们需要捕捉HTTP ERROR并进行相应操作时应该怎么办呢？<strong>API23</strong>便引入了该方法。当服务器返回一个HTTP ERROR并且它的status code>=400时，该方法便会回调。这个方法的作用域并不局限于Main Frame，任何资源的加载引发HTTP ERROR都会引起该方法的回调，所以我们也应该在该方法里执行尽量少的操作，只进行非常必要的错误处理等。</li>
<li>onReceivedSslError(WebView view, SslErrorHandler handler, SslError error)：当WebView加载某个资源引发SSL错误时会回调该方法，这时WebView要么执行<strong>handler.cancel()取消加载</strong>，要么执行handler.proceed()方法继续加载（默认为cancel）。需要注意的是，这个决定可能会被保留并在将来再次遇到SSL错误时执行同样的操作。</li>
<li>WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request)：当WebView需要请求某个数据时，这个方法可以拦截该请求来告知app并且允许app本身返回一个数据来替代我们原本要加载的数据。  </li>
</ul>
<blockquote>
<p>比如你对web的某个js做了本地缓存，希望在加载该js时不再去请求服务器而是可以直接读取本地缓存的js，这个方法就可以帮助你完成这个需求。你可以写一些逻辑检测这个request，并返回相应的数据，你返回的数据就会被WebView使用，如果你返回null，WebView会继续向服务器请求。</p>
</blockquote>
<ul>
<li>boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request)：哈~ 终于到了这个方法，在最开始的基础演示时我们用到了这个方法。从实践中我们知道，当我们没有给WebView提供WebViewClient时，WebView如果要加载一个url会向ActivityManager寻求一个适合的处理者来加载该url（比如系统自带的浏览器），这通常是我们不想看到的。于是我们需要给WebView提供一个WebViewClient，并重写该方法返回true来告知WebView url的加载就在app中进行。这时便可以实现在app内访问网页。</li>
<li>onScaleChanged(WebView view, float oldScale, float newScale)：当WebView得页面Scale值发生改变时回调。</li>
<li>boolean shouldOverrideKeyEvent(WebView view, KeyEvent event)：默认值为false，重写此方法并return true可以让我们在WebView内处理按键事件。</li>
</ul>
<h3 id="WebChromeClient"><a href="#WebChromeClient" class="headerlink" title="WebChromeClient"></a>WebChromeClient</h3><blockquote>
<p>如果说 WebViewClient 是帮助 WebView 处理各种通知、请求事件的“内政大臣”的话，那么WebChromeClient就是辅助WebView处理Javascript的对话</p>
</blockquote>
<ul>
<li>onProgressChanged(WebView view, int newProgress)：当页面加载的进度发生改变时回调，用来告知主程序当前页面的加载进度。</li>
<li>onReceivedIcon(WebView view, Bitmap icon)：用来接收web页面的icon，我们可以在这里将该页面的icon设置到Toolbar。</li>
<li>onReceivedTitle(WebView view, String title)：用来接收web页面的title，我们可以在这里将页面的title设置到Toolbar。  </li>
</ul>
<blockquote>
<p>以下两个方法是为了支持web页面进入全屏模式而存在的（比如播放视频），如果不实现这两个方法，该web上的内容便不能进入全屏模式。</p>
</blockquote>
<ul>
<li>onShowCustomView(View view, WebChromeClient.CustomViewCallback callback)：该方法在当前页面进入全屏模式时回调，主程序必须提供一个包含当前web内容（视频 or Something）的自定义的View。</li>
<li>onHideCustomView()：该方法在当前页面退出全屏模式时回调，主程序应在这时隐藏之前show出来的View。</li>
<li>Bitmap getDefaultVideoPoster()：当我们的Web页面包含视频时，我们可以在HTML里为它设置一个预览图，WebView会在绘制页面时根据它的宽高为它布局。而当我们处于弱网状态下时，我们没有比较快的获取该图片，那WebView绘制页面时的gitWidth()方法就会报出空指针异常~ 于是app就crash了。。  </li>
</ul>
<blockquote>
<p>这时我们就需要重写该方法，在我们尚未获取web页面上的video预览图时，给予它一个本地的图片，避免空指针的发生。</p>
</blockquote>
<ul>
<li>View getVideoLoadingProgressView()：重写该方法可以在视频loading时给予一个自定义的View，可以是加载圆环 or something。</li>
<li>boolean onJsAlert(WebView view, String url, String message, JsResult result)：处理Javascript中的Alert对话框。</li>
<li>boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result)：处理Javascript中的Prompt对话框。</li>
<li>boolean onJsConfirm(WebView view, String url, String message, JsResult result)：处理Javascript中的Confirm对话框</li>
<li>boolean onShowFileChooser(WebView webView, ValueCallback filePathCallback, WebChromeClient.FileChooserParams fileChooserParams)：该方法在用户进行了web上某个需要上传文件的操作时回调。我们应该在这里打开一个文件选择器，如果要取消这个请求我们可以调用filePathCallback.onReceiveValue(null)并返回true。</li>
<li>onPermissionRequest(PermissionRequest request)：该方法在web页面请求某个尚未被允许或拒绝的权限时回调，主程序在此时调用grant(String <a href=""></a>)或deny()方法。如果该方法没有被重写，则默认拒绝web页面请求的权限。</li>
<li>onPermissionRequestCanceled(PermissionRequest request)：该方法在web权限申请权限被取消时回调，这时应该隐藏任何与之相关的UI界面。  </li>
</ul>
<h3 id="JavaScript与WebView交互"><a href="#JavaScript与WebView交互" class="headerlink" title="JavaScript与WebView交互"></a>JavaScript与WebView交互</h3><blockquote>
<p>既然<strong>嗨鸟</strong>应用大行其道，那么毫无疑问Android与JavaScript的交互我们也必须了解清楚，下面来介绍一下JavaScript与Android是如何互相调用的。</p>
</blockquote>
<p><strong>利用WebView调用网页上的JavaScript代码</strong></p>
<blockquote>
<p>在WebView中调用Js的基本格式为</p>
</blockquote>
<pre><code>webView.loadUrl(&quot;javascript:methodName(parameterValues)&quot;);
</code></pre><blockquote>
<p>现有以下这段JavaScript代码</p>
</blockquote>
<pre><code> function readyToGo() {
     alert(&quot;Hello&quot;)
}

 function alertMessage(message) {
     alert(message)
}

 function getYourCar(){
     return &quot;Car&quot;;
 }
</code></pre><ol>
<li><p>WebView调用JavaScript无参无返回值函数</p>
<p> String call = “javascript:readyToGo()”;<br> webView.loadUrl(call);</p>
</li>
<li><p>WebView调用JavaScript有参无返回值函数</p>
<p> String call = “javascript:alertMessage(\”” + “content” + “\”)”;<br> webView.loadUrl(call);</p>
</li>
<li><p>WebView调用JavaScript有参数有返回值的函数</p>
<p> @TargetApi(Build.VERSION_CODES.KITKAT)<br> private void evaluateJavaScript(WebView webView){</p>
<pre><code>webView.evaluateJavascript(&quot;getYourCar()&quot;, new ValueCallback&lt;String&gt;() {
    @Override
    public void onReceiveValue(String s) {
        Log.d(&quot;findCar&quot;,s);
    }
</code></pre><p>  });}</p>
</li>
</ol>
<p><strong>JavaScript通过WebView调用Java代码</strong></p>
<blockquote>
<p>从API19开始，Android提供了<strong>@JavascriptInterface</strong>对象注解的方式来建立起Javascript对象和Android原生对象的绑定，提供给JavaScript调用的函数必须带有@JavascriptInterface。</p>
<p>演示一 JavaScript调用Android Toast方法</p>
</blockquote>
<ol>
<li><p>编写Java原生方法并用使用@JavascriptInterface注解</p>
<p> @JavascriptInterface<br> public void show(String s){</p>
<pre><code>Toast.makeText(getApplication(), s, Toast.LENGTH_SHORT).show();
</code></pre><p> }</p>
</li>
<li><p>注册JavaScriptInterface</p>
<p> webView.addJavascriptInterface(this, “android”);</p>
</li>
</ol>
<blockquote>
<p>addJavascriptInterface的作用是把this所代表的类映射为JavaScript中的android对象。</p>
</blockquote>
<ol>
<li><p>编写JavaScript代码</p>
<p> function toastClick(){</p>
<pre><code>window.android.show(&quot;JavaScript called~!&quot;);
</code></pre><p> }</p>
</li>
</ol>
<blockquote>
<p>演示二 JavaScript调用有返回值的Java方法</p>
</blockquote>
<ol>
<li><p>定义一个带返回值的Java方法，并使用@JavaInterface：</p>
<p> @JavaInterface<br> public String getMessage(){</p>
<pre><code>return &quot;Hello,boy\~”;
</code></pre><p> }</p>
</li>
<li><p>添加JavaScript的映射</p>
<p> webView.addJavaScriptInterface(this,”Android”);</p>
</li>
<li><p>通过JavaScript调用Java方法</p>
<p> function showHello(){</p>
<pre><code>var str=window.Android.getMessage();
console.log(str);
</code></pre><p> }</p>
</li>
</ol>
<blockquote>
<p>以上就是Js与WebView交互的一些介绍，希望能对你有帮助。</p>
</blockquote>
<h3 id="WebView加载优化"><a href="#WebView加载优化" class="headerlink" title="WebView加载优化"></a>WebView加载优化</h3><blockquote>
<p>当WebView的<strong>使用频率变得频繁</strong>的时候，对于其各方面的<strong>优化</strong>就变得逐渐重要了起来。可以知道的是，我们每加载一个<strong> H5页面</strong>，都会有很多的请求。除了HTML主URL自身的请求外，HTML外部引用的 JS、CSS、字体文件、图片都是一个个独立的<strong>HTTP 请求</strong>，虽然<strong>请求是并发的</strong>，但当网页整体数量达到一定程度的时候，再加上浏览器解析、渲染的时间，Web整体的加载时间变得很长。同时请求文件越多，消耗的流量也会越多。那么对于<strong>加载的优化</strong>就变得非常重要，这方面的经验我也没有什么别的，大概三个方面：</p>
</blockquote>
<p><strong>一个，就是资源本地化的问题</strong></p>
<blockquote>
<p>首先可以明确的是，以目前的网络条件，通过网络去服务器获取资源的速度是远远比不上从本地读取的。谈论各种优化策略其实恰恰忽略了“需要加载”才是阻挡速度提升的最大绊脚石。所以我们的思路一，就是将一些较重的资源比如js、css、图片甚至HTML本身进行<strong>本地化处理</strong>，在每次加载到这些资源的时候，从本地读取进行加载，可以简单记忆为“<strong>存·取·更</strong>”。</p>
<p>具体实现思路为：</p>
</blockquote>
<ol>
<li><p>“存”——将上述<strong>重量级资源</strong>打包进apk文件，每次加载相应文件时时从本地取即可。也可不打包，在第一次加载时以及接下来的若干间隔时间里动态下载存储，将所有的资源文件都存在Android的asset目录下；  </p>
</li>
<li><p>“取”——重写WebViewClient的WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request)方法，通过一定的判别方法（例如正则表达式）拦截相应的请求，从本地读取相应资源并返回；  </p>
</li>
<li><p>“更”——建立起Cache Control机制，定期或使用API通知的形式控制本地资源的更新，保证本地资源是最新和可用的。  </p>
</li>
</ol>
<blockquote>
<p>这里附上一篇博客链接，非常棒可供参考：caching-web-resources-in-the-android-device</p>
</blockquote>
<p><strong>第二个，就是缓存的问题</strong></p>
<blockquote>
<p>倘若你不采用或不完全采用第一条资源本地化的思路，那么你的WebView缓存是必须要开启的（虽然这一思路和第一条有重合的地方）。</p>
</blockquote>
<pre><code>WebSettings settings = webView.getSettings();
settings.setAppCacheEnabled(true);
settings.setDatabaseEnabled(true);
settings.setDomStorageEnabled(true); //开启DOM缓存
settings.setCacheMode(WebSettings.LOAD_DEFAULT);
</code></pre><blockquote>
<p>在网络正常时，采用默认缓存策略，在缓存可获取并且没有过期的情况下加载缓存，否则通过网络获取资源以减少页面的网络请求次数。</p>
<p>这里值得提起的是，我们经常在app里用WebView展示页面时，并不想让用户觉得他是在访问一个网页。因为倘若我们的app里网页非常多，而我们给用户的感觉又都像在访问网页的话，我们的app便失去了意义。（我的意思是为什么用户不直接使用浏览器呢？）</p>
<p>所以这时，离线缓存的问题就值得我们注意。我们需要让用户在没有网的时候，依然能够操作我们的app，而不是面对一个和浏览器里的网络错误一样的页面，哪怕他能进行的操作十分有限。</p>
<p>这里我的思路是，在开启缓存的前提下，WebView在加载页面时检测网络变化，倘若在加载页面时用户的网络突然断掉，我们应当更改WebView的缓存策略。</p>
</blockquote>
<pre><code>ConnectivityManager connectivityManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
if(networkInfo.isAvailable()) {
   settings.setCacheMode(WebSettings.LOAD_DEFAULT);//网络正常时使用默认缓存策略
} else {
   settings.setCacheMode(WebSettings.LOAD_CACHE_ONLY);//网络不可用时只使用缓存
}
</code></pre><blockquote>
<p>既然有<strong>缓存</strong>，就要有<strong>缓存控制</strong>，与一相似的是我们也要建立缓存控制机制，定期或接受服务器通知来进行缓存的清空或更新。</p>
</blockquote>
<p><strong>第三个，就是延迟加载和执行js</strong></p>
<blockquote>
<p>在WebView中，onPageFinished()的回调意味着页面加载的完成。但该方法会在JavScript脚本执行完成后才会触发，倘若我们要加载的页面使用了JQuery，会在处理完DOM对象，执行完$(document).ready(function() {})后才会渲染并显示页面。这是不可接受的，所以我们需要<strong>对Js进行延迟加载</strong>，当然这部分是Web前端的工作。</p>
</blockquote>
<p><strong>如果说还有什么</strong></p>
<blockquote>
<p>那就是<strong>JsBridge</strong>一律不得滥用，这个对页面加载的完成速度是有很大影响的，倘若一个页面很多操作都通过JSbridge来控制，再怎么优化也无济于事（因为毕竟有那么多操作要实际执行）。同时要注意的是，不管你是否对资源进行缓存，都请将资源在服务器端进行压缩。因为无论是资源的获取和更新，都是要从服务器获取的，所以对于资源文件的压缩其实是最直接也最应该做的事情之一，但是一般服务器端都会做好，所以主要就是上面这三件事。</p>
</blockquote>
<h3 id="驾照考试"><a href="#驾照考试" class="headerlink" title="驾照考试"></a>驾照考试</h3><blockquote>
<p>介绍了这么多，希望能对你有点帮助。接下来时纯实战时间，我会将上面所介绍的很多知识点在接下来的代码里实际应用一遍，希望能够带给你更加直观的使用感受。</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;

        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;?attr/actionBarSize&quot;
            android:background=&quot;?attr/colorPrimary&quot;
            app:theme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;

    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;FrameLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;WebView
            android:id=&quot;@+id/web_view&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot; /&gt;

        &lt;ProgressBar
            android:id=&quot;@+id/progress_bar&quot;
            android:layout_width=&quot;50dp&quot;
            android:layout_height=&quot;50dp&quot;
            android:layout_gravity=&quot;center&quot;
            android:visibility=&quot;gone&quot; /&gt;
    &lt;/FrameLayout&gt;&lt;/LinearLayout&gt;
</code></pre><p><strong>Java部分</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {

  private WebView mWebView;
  private ProgressBar mProgressbar;
  private Toolbar mToolbar;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
      supportRequestWindowFeature(Window.FEATURE_NO_TITLE);
      super.onCreate(savedInstanceState);
      setContentView(R.layout.activity_main);

      initAppBar();//初始化Toolbar

      initWebView();//初始化WebView
      initWebSettings();//初始化WebSettings
      initWebViewClient();//初始化WebViewClient
      initWebChromeClient();//初始化WebChromeClient
  }

  private void initAppBar() {
      mToolbar = (Toolbar) findViewById(R.id.toolbar);
      mToolbar.setTitle(&quot;载入中..&quot;);
      mToolbar.setTitleTextColor(getResources().getColor(R.color.colorWhite));
      setSupportActionBar(mToolbar);
      getSupportActionBar().setDisplayHomeAsUpEnabled(false);
  }

  private void initWebView() {
      mWebView = (WebView) findViewById(R.id.web_view);
      mProgressbar = (ProgressBar) findViewById(R.id.progress_bar);
      String url = &quot;https://www.google.com&quot;;
      mWebView.loadUrl(url);
  }

  private void initWebSettings() {
      WebSettings settings = mWebView.getSettings();
      //支持获取手势焦点
      mWebView.requestFocusFromTouch();
      //支持JS
      settings.setJavaScriptEnabled(true);
      //支持插件
      settings.setPluginState(WebSettings.PluginState.ON);
      //设置适应屏幕
      settings.setUseWideViewPort(true);
      settings.setLoadWithOverviewMode(true);
      //支持缩放
      settings.setSupportZoom(false);
      //隐藏原生的缩放控件
      settings.setDisplayZoomControls(false);
      //支持内容重新布局
      settings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN);
      settings.supportMultipleWindows();
      settings.setSupportMultipleWindows(true);
      //设置缓存模式
      settings.setDomStorageEnabled(true);
      settings.setDatabaseEnabled(true);
      settings.setCacheMode(WebSettings.LOAD_DEFAULT);
      settings.setAppCacheEnabled(true);
      settings.setAppCachePath(mWebView.getContext().getCacheDir().getAbsolutePath());

      //设置可访问文件
      settings.setAllowFileAccess(true);
      //当webview调用requestFocus时为webview设置节点
      settings.setNeedInitialFocus(true);
      //支持自动加载图片
      if (Build.VERSION.SDK_INT &gt;= 19) {
          settings.setLoadsImagesAutomatically(true);
      } else {
          settings.setLoadsImagesAutomatically(false);
      }
      settings.setNeedInitialFocus(true);
      //设置编码格式
      settings.setDefaultTextEncodingName(&quot;UTF-8&quot;);
  }

  private void initWebViewClient() {
      mWebView.setWebViewClient(new WebViewClient() {

          //页面开始加载时
          @Override
          public void onPageStarted(WebView view, String url, Bitmap favicon) {
              super.onPageStarted(view, url, favicon);
              mProgressbar.setVisibility(View.VISIBLE);
          }


          //页面完成加载时
          @Override
          public void onPageFinished(WebView view, String url) {
              super.onPageFinished(view, url);
              mProgressbar.setVisibility(View.GONE);
          }

          //是否在WebView内加载新页面
          @Override
          public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
              view.loadUrl(request.toString());
              return true;
          }

          //网络错误时回调的方法
          @Override
          public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) {
              super.onReceivedError(view, request, error);
              /**
               * 在这里写网络错误时的逻辑,比如显示一个错误页面
               *
               * 这里我偷个懒不写了
               * */
          }

          @TargetApi(Build.VERSION_CODES.M)
          @Override
          public void onReceivedHttpError(WebView view, WebResourceRequest request, WebResourceResponse errorResponse) {
              super.onReceivedHttpError(view, request, errorResponse);
          }
      });
  }

  private void initWebChromeClient() {

      mWebView.setWebChromeClient(new WebChromeClient() {

          private Bitmap mDefaultVideoPoster;//默认的视频展示图

          @Override
          public void onReceivedTitle(WebView view, String title) {
              super.onReceivedTitle(view, title);
              setToolbarTitle(title);
          }

          @Override
          public Bitmap getDefaultVideoPoster() {
              if (mDefaultVideoPoster == null) {
                  mDefaultVideoPoster = BitmapFactory.decodeResource(
                          getResources(), R.drawable.video_default
                  );
                  return mDefaultVideoPoster;
              }
              return super.getDefaultVideoPoster();
          }
      });
  }

  /**
   * 设置Toolbar标题
   *
   * @param title
   */
  private void setToolbarTitle(final String title) {
      Log.d(&quot;setToolbarTitle&quot;, &quot; WebDetailActivity &quot; + title);
      if (mToolbar != null) {
          mToolbar.post(new Runnable() {
              @Override
              public void run() {
                  mToolbar.setTitle(TextUtils.isEmpty(title) ? getString(R.string.loading) : title);
              }
          });
      }
  }

  @Override
  public boolean onCreateOptionsMenu(Menu menu) {
      getMenuInflater().inflate(R.menu.menu_main, menu);
      return super.onCreateOptionsMenu(menu);
  }

  @Override
  public boolean onOptionsItemSelected(MenuItem item) {
      switch (item.getItemId()) {
          case R.id.page_up:
              Toast.makeText(getApplicationContext(), &quot;页面向上&quot;, Toast.LENGTH_SHORT).show();
              mWebView.pageUp(true);
              break;
          case R.id.page_down:
              Toast.makeText(getApplicationContext(), &quot;页面向下&quot;, Toast.LENGTH_SHORT).show();
              mWebView.pageDown(true);
              break;
          case R.id.refresh:
              Toast.makeText(getApplicationContext(), &quot;刷新~&quot;, Toast.LENGTH_SHORT).show();
              mWebView.reload();
          default:
              return super.onOptionsItemSelected(item);
      }
      return super.onOptionsItemSelected(item);
  }

  @Override
  public boolean onKeyDown(int keyCode, KeyEvent event) {

      //如果按下的是回退键且历史记录里确实还有页面
      if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) {
          mWebView.goBack();
          return true;
      } else {
          Toast.makeText(getApplicationContext(), &quot;考试结束,恭喜您考试合格!&quot;, Toast.LENGTH_LONG).show();
      }
      return super.onKeyDown(keyCode, event);
  }}
</code></pre><p><strong>参考博文</strong></p>
<p><a href="https://jiandanxinli.github.io/2016-08-31.html" target="_blank" rel="external">WebView·开车指南</a><br><a href="https://developer.android.com/guide/index.html" target="_blank" rel="external">Android官方文档</a><br><a href="http://tutorials.jenkov.com/android/android-web-apps-using-android-webview.html" target="_blank" rel="external">Android Web Apps Using Android WebView</a><br><a href="https://yq.aliyun.com/articles/32559" target="_blank" rel="external">史上最全webview详解</a><br><a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=267" target="_blank" rel="external">H5 缓存机制浅析 移动端 Web 加载性能优化</a><br><a href="http://www.jianshu.com/p/427600ca2107" target="_blank" rel="external">WebView加载速度优化</a><br><a href="http://www.jianshu.com/p/3fcf8ba18d7f" target="_blank" rel="external">史上最全WebView使用，附送Html5Activity一份</a><br><a href="https://juejin.im/entry/5914770f128fe1005ca599ce" target="_blank" rel="external">WebView 全面使用攻略</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;WebView简介&quot;&gt;&lt;a href=&quot;#WebView简介&quot; class=&quot;headerlink&quot; title=&quot;WebView简介&quot;&gt;&lt;/a&gt;WebView简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;为了方便开发者实现在&lt;strong&gt;app内展示网页&lt;/s
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="WebView" scheme="http://yoursite.com/tags/WebView/"/>
    
      <category term="Html5" scheme="http://yoursite.com/tags/Html5/"/>
    
      <category term="混合开发" scheme="http://yoursite.com/tags/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/08/04/%E5%8D%9A%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2017/08/04/博文阅读记录/</id>
    <published>2017-08-04T11:10:19.000Z</published>
    <updated>2017-08-12T02:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.jianshu.com/p/fa41fb80d2b8" target="_blank" rel="external">谈谈为什么写单元测试</a><br><a href="http://www.jianshu.com/p/bc99678b1d6e" target="_blank" rel="external">Android单元测试 - 如何开始？</a><br><a href="http://www.jianshu.com/p/f5d197a4d83a" target="_blank" rel="external">Android单元测试 - 几个重要问题</a><br><a href="http://www.jianshu.com/p/03118c11c199" target="_blank" rel="external">在Android Studio中进行单元测试和UI测试</a><br><a href="https://developer.android.com/training/testing/unit-testing/index.html" target="_blank" rel="external">Building Effective Unit Tests</a><br><a href="https://developer.android.com/topic/libraries/testing-support-library/index.html" target="_blank" rel="external">Android Testing Support Library 测试支持库 </a></p>
<p><a href="https://juejin.im/entry/5914770f128fe1005ca599ce" target="_blank" rel="external">WebView 全面使用攻略</a><br><a href="https://juejin.im/entry/598c0c776fb9a03c5b04c0b8" target="_blank" rel="external">WebView 开车指南之最全实用案例</a><br><a href="http://www.jianshu.com/p/3fcf8ba18d7f" target="_blank" rel="external">史上最全WebView使用，附送Html5Activity一份</a><br><a href="http://blog.csdn.net/leehong2005/article/details/11808557" target="_blank" rel="external">Android WebView的Js对象注入漏洞解决方案</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/fa41fb80d2b8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;谈谈为什么写单元测试&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/bc9967
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/08/03/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/08/03/Java反射机制详解/</id>
    <published>2017-08-03T13:33:37.000Z</published>
    <updated>2017-08-03T14:16:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反射机制是什么"><a href="#反射机制是什么" class="headerlink" title="反射机制是什么"></a>反射机制是什么</h3><blockquote>
<p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p>
</blockquote>
<h3 id="反射机制能做什么"><a href="#反射机制能做什么" class="headerlink" title="反射机制能做什么"></a>反射机制能做什么</h3><blockquote>
<p>反射机制主要提供了以下功能： </p>
</blockquote>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时调用任意一个对象的方法；</li>
<li>生成动态代理。  </li>
</ul>
<h3 id="反射机制的相关API"><a href="#反射机制的相关API" class="headerlink" title="反射机制的相关API"></a>反射机制的相关API</h3><h4 id="通过一个对象获得完整的包名和类名"><a href="#通过一个对象获得完整的包名和类名" class="headerlink" title="通过一个对象获得完整的包名和类名"></a>通过一个对象获得完整的包名和类名</h4><pre><code>object.getClass().getName();
</code></pre><h4 id="实例化Class类对象"><a href="#实例化Class类对象" class="headerlink" title="实例化Class类对象"></a>实例化Class类对象</h4><pre><code>Class&lt;?&gt; class1 = null;
Class&lt;?&gt; class2 = null;
Class&lt;?&gt; class3 = null;
// 一般采用这种形式
class1 = Class.forName(&quot;net.xsoftlab.baike.TestReflect&quot;);
class2 = new TestReflect().getClass();
class3 = TestReflect.class;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;反射机制是什么&quot;&gt;&lt;a href=&quot;#反射机制是什么&quot; class=&quot;headerlink&quot; title=&quot;反射机制是什么&quot;&gt;&lt;/a&gt;反射机制是什么&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android支持库</title>
    <link href="http://yoursite.com/2017/07/30/Android%E6%94%AF%E6%8C%81%E5%BA%93/"/>
    <id>http://yoursite.com/2017/07/30/Android支持库/</id>
    <published>2017-07-30T12:59:03.000Z</published>
    <updated>2017-07-30T13:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随着Android系统版本的不断更新，出现了越来越多的新特性，为了使这些新特性能够兼容之前的版本，所以Android也推出了一些兼容包，在低版本的系统上使用这些兼容包就可以使用新版本系统中的一些新特性了，下面我们来具体说说有哪些兼容包。"><a href="#随着Android系统版本的不断更新，出现了越来越多的新特性，为了使这些新特性能够兼容之前的版本，所以Android也推出了一些兼容包，在低版本的系统上使用这些兼容包就可以使用新版本系统中的一些新特性了，下面我们来具体说说有哪些兼容包。" class="headerlink" title="随着Android系统版本的不断更新，出现了越来越多的新特性，为了使这些新特性能够兼容之前的版本，所以Android也推出了一些兼容包，在低版本的系统上使用这些兼容包就可以使用新版本系统中的一些新特性了，下面我们来具体说说有哪些兼容包。"></a>随着<strong>Android系统版本</strong>的不断更新，出现了越来越多的<strong>新特性</strong>，为了使这些新特性能够<strong>兼容之前的版本</strong>，所以Android也推出了一些<strong>兼容包</strong>，在<strong>低版本的系统</strong>上使用这些<strong>兼容包</strong>就可以<strong>使用新版本系统</strong>中的一些<strong>新特性</strong>了，下面我们来具体说说有哪些<strong>兼容包</strong>。</h2><h3 id="support-v4支持库"><a href="#support-v4支持库" class="headerlink" title="support-v4支持库"></a>support-v4支持库</h3><blockquote>
<p>特点：可以使用在<strong>Android 1.6 (API level 4)</strong>及其以上的系统上，也就是可以兼容到Android 1.6系统。</p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:support-v4:25.3.1&apos;
</code></pre><blockquote>
<p>包含内容如下：</p>
</blockquote>
<pre><code>android.support.v4.accessibilityservice  
android.support.v4.app  
android.support.v4.content  
android.support.v4.content.pm  
android.support.v4.content.res  
android.support.v4.database  
android.support.v4.graphics  
android.support.v4.graphics.drawable  
android.support.v4.hardware.display  
android.support.v4.hardware.fingerprint  
android.support.v4.media  
android.support.v4.media.session  
android.support.v4.net  
android.support.v4.os  
android.support.v4.print  
android.support.v4.provider  
android.support.v4.text  
android.support.v4.util  
android.support.v4.view  
android.support.v4.view.accessibility  
android.support.v4.view.animation  
android.support.v4.widget  
</code></pre><blockquote>
<p>关键类：</p>
</blockquote>
<pre><code>App Components:Fragment,NotificationCompat,LocalBroadcastManager
User Interface:ViewPager,PagerTitleStrip,PagerTabStrip,DrawerLayout,SlidingPaneLayout
Accessibility:ExploreByTouchHelper,AccessibilityEventCompat,AccessibilityNodeInfoCompat,AccessibilityNodeProviderCompat,AccessibilityDelegateCompat
Contents:Loader,FileProvider
</code></pre><h3 id="Multidex支持库"><a href="#Multidex支持库" class="headerlink" title="Multidex支持库"></a>Multidex支持库</h3><blockquote>
<p>特点：我们知道，应用的<strong>dex方法数是不能超过65536的</strong>，Multidex支持库就可供了一种解决方案，<strong>支持应用中包含多个dex文件</strong>。</p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库=</p>
</blockquote>
<pre><code>compile &apos;com.android.support:multidex:1.0.0&apos;
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.multidex  
</code></pre><h3 id="support-v7支持库"><a href="#support-v7支持库" class="headerlink" title="support-v7支持库"></a>support-v7支持库</h3><blockquote>
<p>特点：可以使用在<strong>Android 2.1 (API level 7)</strong>及其以上的系统上，也就是它可以兼容到Android 2.1系统。</p>
<p>v7支持库包含一下几个部分：</p>
</blockquote>
<h4 id="v7-appcompat-library"><a href="#v7-appcompat-library" class="headerlink" title="v7 appcompat library"></a>v7 appcompat library</h4><blockquote>
<p>特点：支持Action Bar以及material design，并且这个库依赖于<strong>v4支持库</strong>。</p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:appcompat-v7:25.3.1&apos;
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.v7.app  
android.support.v7.appcompat  
android.support.v7.graphics.drawable  
android.support.v7.view  
android.support.v7.widget  
android.support.v7.widget.helper  
android.support.v7.widget.util  
</code></pre><blockquote>
<p>关键类：</p>
</blockquote>
<pre><code>ActionBar,AppCompatActivity,AppCompatDialog,ShareActionProvider
</code></pre><h4 id="v7-cardview-library"><a href="#v7-cardview-library" class="headerlink" title="v7 cardview library"></a>v7 cardview library</h4><blockquote>
<p>特点：支持<strong>CardView</strong></p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:cardview-v7:25.3.1&apos;
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.v7.cardview  
android.support.v7.widget 
</code></pre><h4 id="v7-gridlayout-library"><a href="#v7-gridlayout-library" class="headerlink" title="v7 gridlayout library"></a>v7 gridlayout library</h4><blockquote>
<p>特点：支持<strong>GridLayout</strong></p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:gridlayout-v7:25.3.1&apos;
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.v7.gridlayout  
android.support.v7.widget 
</code></pre><h4 id="v7-mediarouter-library"><a href="#v7-mediarouter-library" class="headerlink" title="v7 mediarouter library"></a>v7 mediarouter library</h4><blockquote>
<p>特点：提供了<strong>MediaRouter, MediaRouteProvider</strong>类和相关媒体类。</p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:mediarouter-v7:25.3.1&apos;
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.v7.app  
android.support.v7.media  
android.support.v7.mediarouter  
</code></pre><h4 id="v7-palette-library"><a href="#v7-palette-library" class="headerlink" title="v7 palette library"></a>v7 palette library</h4><blockquote>
<p>特点：提供了<strong>Palette类</strong></p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:palette-v7:25.3.1&apos;
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.v7.graphics  
</code></pre><h4 id="v7-recyclerview-library"><a href="#v7-recyclerview-library" class="headerlink" title="v7 recyclerview library"></a>v7 recyclerview library</h4><blockquote>
<p>特点：支持<strong>RecyclerView</strong></p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:recyclerview-v7:25.3.1&apos;  
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.v7.recyclerview  
android.support.v7.util  
android.support.v7.widget  
</code></pre><h4 id="v7-Preference-Support-Library"><a href="#v7-Preference-Support-Library" class="headerlink" title="v7 Preference Support Library"></a>v7 Preference Support Library</h4><blockquote>
<p>特点：可以<strong>添加引用对象</strong>，例如CheckBoxPreference 和 ListPreference。</p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:preference-v7:25.3.1&apos;  
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.v7.preference  
</code></pre><h3 id="support-v8支持库"><a href="#support-v8支持库" class="headerlink" title="support-v8支持库"></a>support-v8支持库</h3><blockquote>
<p>特点：可以使用在<strong>Android 2.2 (API level 8)</strong>及其以上的系统上，也就是可以兼容到Android 2.2系统。</p>
<p>它主要包含下面库:</p>
</blockquote>
<h4 id="v8-renderscript-library"><a href="#v8-renderscript-library" class="headerlink" title="v8 renderscript library"></a>v8 renderscript library</h4><blockquote>
<p>特点：支持RenderScript计算框架。</p>
<p>使用方法：</p>
</blockquote>
<pre><code>defaultConfig {  
   renderscriptTargetApi 18  
   renderscriptSupportModeEnabled true  
}  
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.v8.renderscript  
</code></pre><h3 id="support-v13支持库"><a href="#support-v13支持库" class="headerlink" title="support-v13支持库"></a>support-v13支持库</h3><blockquote>
<p>特点：可以使用在<strong>Android 3.2 (API level 13)</strong>及其以上的系统上，也就是可以兼容到Android 3.2系统。提供了对<strong>Fragment</strong>的一些支持。</p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:support-v13:25.3.1&apos;  
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.v13.app  
</code></pre><h3 id="v14引用支持库"><a href="#v14引用支持库" class="headerlink" title="v14引用支持库"></a>v14引用支持库</h3><blockquote>
<p>特点：支持<strong>引用接口和引用类</strong>。</p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:preference-v14:25.3.1&apos;
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.v14.preference  
</code></pre><h3 id="v17引用支持库"><a href="#v17引用支持库" class="headerlink" title="v17引用支持库"></a>v17引用支持库</h3><blockquote>
<p>特点：<strong>使用在TV中</strong>。</p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:preference-leanback-v17:25.3.1&apos;
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.v17.preference  
</code></pre><h3 id="v17-Leanback-Library"><a href="#v17-Leanback-Library" class="headerlink" title="v17 Leanback Library"></a>v17 Leanback Library</h3><blockquote>
<p>特点：使用在<strong>TV</strong>上，提供了一些<strong>用户接口和组件</strong></p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:leanback-v17:25.3.1&apos;
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.v17.leanback  
android.support.v17.leanback.app  
android.support.v17.leanback.database  
android.support.v17.leanback.graphics  
android.support.v17.leanback.system  
android.support.v17.leanback.widget  
android.support.v17.leanback.widget.picker  
</code></pre><blockquote>
<p>关键类：</p>
</blockquote>
<pre><code>BrowseFragment,DetailsFragment,PlaybackOverlayFragment,SearchFragment
</code></pre><h3 id="注解支持库-support-annotations"><a href="#注解支持库-support-annotations" class="headerlink" title="注解支持库(support-annotations)"></a>注解支持库(support-annotations)</h3><blockquote>
<p>特点：支持一些注解</p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:support-annotations:25.3.1&apos;  
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.annotation 
</code></pre><h3 id="设计支持库"><a href="#设计支持库" class="headerlink" title="设计支持库"></a>设计支持库</h3><blockquote>
<p>特点：提供了<strong>material design</strong>的组件</p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:design:25.3.1&apos;  
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.design  
android.support.design.widget  
</code></pre><h3 id="自定义Tab支持库"><a href="#自定义Tab支持库" class="headerlink" title="自定义Tab支持库"></a>自定义Tab支持库</h3><blockquote>
<p>特点：提供了对<strong>Tab的管理</strong></p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:customtabs:25.3.1&apos;
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.customtabs  
</code></pre><h3 id="百分比支持库"><a href="#百分比支持库" class="headerlink" title="百分比支持库"></a>百分比支持库</h3><blockquote>
<p>特点：<strong>支持百分比布局</strong></p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:percent:25.3.1&apos;  
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.percent 
</code></pre><h3 id="App-Recommendation支持库"><a href="#App-Recommendation支持库" class="headerlink" title="App Recommendation支持库"></a>App Recommendation支持库</h3><blockquote>
<p>特点：使用在<strong>TV</strong>中</p>
<p>使用方法：在Android Studio的Gradle文件中引入下面这个库</p>
</blockquote>
<pre><code>compile &apos;com.android.support:recommendation:25.3.1&apos;  
</code></pre><blockquote>
<p>包含内容：</p>
</blockquote>
<pre><code>android.support.app.recommendation  
</code></pre><p><strong>参考文献</strong></p>
<p><a href="http://blog.csdn.net/hp910315/article/details/51173139" target="_blank" rel="external">http://blog.csdn.net/hp910315/article/details/51173139</a><br><a href="https://developer.android.com/topic/libraries/support-library/features.html?hl=zh-cn#v4" target="_blank" rel="external">https://developer.android.com/topic/libraries/support-library/features.html?hl=zh-cn#v4</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;随着Android系统版本的不断更新，出现了越来越多的新特性，为了使这些新特性能够兼容之前的版本，所以Android也推出了一些兼容包，在低版本的系统上使用这些兼容包就可以使用新版本系统中的一些新特性了，下面我们来具体说说有哪些兼容包。&quot;&gt;&lt;a href=&quot;#随着
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="支持库" scheme="http://yoursite.com/tags/%E6%94%AF%E6%8C%81%E5%BA%93/"/>
    
      <category term="Support Library" scheme="http://yoursite.com/tags/Support-Library/"/>
    
  </entry>
  
  <entry>
    <title>Android Version &amp; API Level</title>
    <link href="http://yoursite.com/2017/07/29/Android%20Version%20&amp;%20API%20Level/"/>
    <id>http://yoursite.com/2017/07/29/Android Version &amp; API Level/</id>
    <published>2017-07-29T03:24:34.000Z</published>
    <updated>2017-07-29T04:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Android目前为止所有发布的版本以及对应的API等级</strong></p>
<h2 id="Android-SDK版本"><a href="#Android-SDK版本" class="headerlink" title="Android SDK版本"></a>Android SDK版本</h2><h3 id="两个预发布的内部版本"><a href="#两个预发布的内部版本" class="headerlink" title="两个预发布的内部版本"></a>两个预发布的内部版本</h3><h2 id="gt-Android-alpha-Astro·原子小金刚"><a href="#gt-Android-alpha-Astro·原子小金刚" class="headerlink" title="&gt; Android alpha (Astro·原子小金刚)"></a>&gt; Android alpha (Astro·原子小金刚)</h2><blockquote>
<p>Android beta   (Bender·机器人班亭)<br><em>@2007.11.05</em></p>
</blockquote>
<h3 id="初期过渡版本"><a href="#初期过渡版本" class="headerlink" title="初期过渡版本"></a>初期过渡版本</h3><blockquote>
<p>Android 1.0<br><strong>[API 1]</strong> </p>
<h2 id="2008-09-23"><a href="#2008-09-23" class="headerlink" title="@2008.09.23"></a><em>@2008.09.23</em></h2><p>Android 1.1<br><strong> [API 2]</strong><br><em>@2009.02.09</em></p>
</blockquote>
<h3 id="甜点版本代号"><a href="#甜点版本代号" class="headerlink" title="甜点版本代号"></a>甜点版本代号</h3><blockquote>
<p>Android 1.5 (Cupcake·纸杯蛋糕)<br><strong> [API 3]</strong></p>
<h2 id="2009-04-27"><a href="#2009-04-27" class="headerlink" title="@2009.04.27"></a><em>@2009.04.27</em></h2><p>Android 1.6 (Donut·甜甜圈)<br><strong> [API 4]</strong></p>
<h2 id="2009-09-15"><a href="#2009-09-15" class="headerlink" title="@2009.09.15"></a><em>@2009.09.15</em></h2><p>Android 2.0 (Eclair· 泡芙)<br><strong>[API 5]</strong></p>
<h2 id="2009-10-26"><a href="#2009-10-26" class="headerlink" title="@2009.10.26"></a><em>@2009.10.26</em></h2><p>Android 2.0.1 (Eclair· 泡芙)<br><strong>[API 6]</strong></p>
<h2 id="2009-12-03"><a href="#2009-12-03" class="headerlink" title="@2009.12.03"></a><em>@2009.12.03</em></h2><p>Android 2.1 (Eclair· 泡芙)<br><strong>[API 7]</strong></p>
<h2 id="2010-01-12"><a href="#2010-01-12" class="headerlink" title="@2010.01.12"></a><em>@2010.01.12</em></h2><p>Android 2.2/2.2.1/2.2.2/2.2.3 (Froyo·冻酸奶)<br><strong> [API 8]</strong></p>
<h2 id="2010-05-20-2011-01-18-2011-01-22-2011-11-21"><a href="#2010-05-20-2011-01-18-2011-01-22-2011-11-21" class="headerlink" title="@2010.05.20/2011.01.18/2011.01.22/2011.11.21"></a><em>@2010.05.20/2011.01.18/2011.01.22/2011.11.21</em></h2><p>Android 2.3/2.3.1/2.3.2 (Gingerbread·姜饼)<br><strong> [API 9]</strong></p>
<h2 id="2010-12-06-2010-12-15-2011-01-09"><a href="#2010-12-06-2010-12-15-2011-01-09" class="headerlink" title="@2010.12.06/2010.12.15/2011.01.09"></a><em>@2010.12.06/2010.12.15/2011.01.09</em></h2><p>Android 2.3.3/2.3.4/2.3.5/2.3.6/2.3.7 (Gingerbread·姜饼)<br><strong> [API 10]</strong></p>
<h2 id="2011-02-09-2011-04-28-2011-07-25-2011-09-02-2011-09-21"><a href="#2011-02-09-2011-04-28-2011-07-25-2011-09-02-2011-09-21" class="headerlink" title="@2011.02.09/2011.04.28/2011.07.25/2011.09.02/2011.09.21"></a><em>@2011.02.09/2011.04.28/2011.07.25/2011.09.02/2011.09.21</em></h2><p>Android 3.0 (Honeycomb·蜂巢)<br><strong> [API 11]</strong></p>
<h2 id="2011-02-22"><a href="#2011-02-22" class="headerlink" title="@2011.02.22"></a><em>@2011.02.22</em></h2><p>Android 3.1 (Honeycomb·蜂巢)<br><strong> [API 12]</strong></p>
<h2 id="2011-05-10"><a href="#2011-05-10" class="headerlink" title="@2011.05.10"></a><em>@2011.05.10</em></h2><p>Android 3.2/3.2.1/3.2.2/3.2.3/3.2.4/3.2.5/3.2.6 (Honeycomb·蜂巢)<br><strong> [API 13]</strong></p>
<h2 id="2011-07-15-…-…-…-2011-12-04-2012-01-14-2012-02-22"><a href="#2011-07-15-…-…-…-2011-12-04-2012-01-14-2012-02-22" class="headerlink" title="@2011.07.15/…/…/…/2011.12.04/2012.01.14/2012.02.22"></a><em>@2011.07.15/…/…/…/2011.12.04/2012.01.14/2012.02.22</em></h2><p>Android 4.0/4.0.1/4.0.2 (Ice Cream Sandwich·冰淇淋三明治)<br><strong> [API 14]</strong></p>
<h2 id="2011-10-18-2011-10-21-2011-11-28"><a href="#2011-10-18-2011-10-21-2011-11-28" class="headerlink" title="@2011.10.18/2011.10.21/2011.11.28"></a><em>@2011.10.18/2011.10.21/2011.11.28</em></h2><p>Android 4.0.3/4.0.4 (Ice Cream Sandwich·冰淇淋三明治)<br><strong> [API 15]</strong></p>
<h2 id="2011-12-16-2012-03-29"><a href="#2011-12-16-2012-03-29" class="headerlink" title="@2011.12.16/2012.03.29"></a><em>@2011.12.16/2012.03.29</em></h2><p>Android 4.1/4.1.1/4.1.2 (Jelly Bean·果冻豆)<br><strong> [API 16]</strong></p>
<h2 id="2012-07-09-2012-07-11-2012-10-09"><a href="#2012-07-09-2012-07-11-2012-10-09" class="headerlink" title="@2012.07.09/2012.07.11/2012.10.09"></a><em>@2012.07.09/2012.07.11/2012.10.09</em></h2><p>Android 4.2/4.2.1/4.2.2 (Jelly Bean·果冻豆)<br><strong> [API 17]</strong></p>
<h2 id="2012-11-13-2012-11-27-2013-02-11"><a href="#2012-11-13-2012-11-27-2013-02-11" class="headerlink" title="@2012.11.13/2012.11.27/2013.02.11"></a><em>@2012.11.13/2012.11.27/2013.02.11</em></h2><p>Android 4.3/4.3.1 (Jelly Bean·果冻豆)<br><strong> [API 18]</strong></p>
<h2 id="2013-07-24-2013-10-03"><a href="#2013-07-24-2013-10-03" class="headerlink" title="@2013.07.24/2013.10.03"></a><em>@2013.07.24/2013.10.03</em></h2><p>Android 4.4/4.4.1/4.4.2/4.4.3/4.4.4 (KitKat·奇巧巧克力)<br><strong> [API 19]</strong></p>
<h2 id="2013-10-31-2013-12-05-2013-12-09-2014-06-02-2014-06-20"><a href="#2013-10-31-2013-12-05-2013-12-09-2014-06-02-2014-06-20" class="headerlink" title="@2013.10.31/2013.12.05/2013.12.09/2014.06.02/2014.06.20"></a><em>@2013.10.31/2013.12.05/2013.12.09/2014.06.02/2014.06.20</em></h2><p>Android 4.4W/4.4W.1/4.4W.2 (KitKat·奇巧巧克力)<br><strong> [API 20]</strong></p>
<h2 id="2014-06-25-2014-09-06-2014-10-21"><a href="#2014-06-25-2014-09-06-2014-10-21" class="headerlink" title="@2014.06.25/2014.09.06~2014.10.21"></a><em>@2014.06.25/2014.09.06~2014.10.21</em></h2><p>Android 5.0/5.0.1/5.0.2 (Lollipop·棒棒糖)<br><strong> [API 21]</strong></p>
<h2 id="2014-11-12-2014-12-02-2014-12-19"><a href="#2014-11-12-2014-12-02-2014-12-19" class="headerlink" title="@2014.11.12~2014.12.02/2014.12.19"></a><em>@2014.11.12~2014.12.02/2014.12.19</em></h2><p>Android 5.1/5.1.1 (Lollipop·棒棒糖)<br><strong> [API 22]</strong></p>
<h2 id="2015-03-10-2015-04-22"><a href="#2015-03-10-2015-04-22" class="headerlink" title="@2015.03.10/2015.04.22"></a><em>@2015.03.10/2015.04.22</em></h2><p>Android 6.0/6.0.1 (Marshmallow·棉花糖)<br><strong> [API 23]</strong></p>
<h2 id="2015-10-05-2015-12-07"><a href="#2015-10-05-2015-12-07" class="headerlink" title="@2015.10.05/2015.12.07"></a><em>@2015.10.05/2015.12.07</em></h2><p>Android 7.0 (Nougat·牛轧糖)<br><strong> [API 24]</strong></p>
<h2 id="2016-08-22"><a href="#2016-08-22" class="headerlink" title="_@2016.08.22"></a>_@2016.08.22</h2><p>Android 7.1.1/7.1.2 (Nougat·牛轧糖)<br><strong> [API 25]</strong></p>
<h2 id="2016-12-05-2017-04-04"><a href="#2016-12-05-2017-04-04" class="headerlink" title="@2016.12.05/2017.04.04"></a><em>@2016.12.05/2017.04.04</em></h2><p>Android 8.0  O(预览版)<br><strong> [API 26]</strong><br><em>@2017.03.21</em></p>
</blockquote>
<h2 id="Android-SDK版本用处"><a href="#Android-SDK版本用处" class="headerlink" title="Android SDK版本用处"></a>Android SDK版本用处</h2><h3 id="获取版本号"><a href="#获取版本号" class="headerlink" title="获取版本号"></a>获取版本号</h3><ul>
<li>为什么要获取版本号?</li>
</ul>
<blockquote>
<p>有时候发布的APP出现异常，我们捕获异常，需要将异常携带该设备的SDK版本号上传到服务器，方便开发者进行异常分析。</p>
</blockquote>
<ul>
<li><p>如何获取发布版本号以及API Level?</p>
<p> /**</p>
<ul>
<li><p>获取Android发布的版本<br>*/<br>public static String getVersion() {<br>return android.os.Build.VERSION.RELEASE;<br>}</p>
<p>/**</p>
</li>
<li>获取SDK的API Level<br>*/<br>public static int getSDK() {<br>return android.os.Build.VERSION.SDK_INT;<br>}</li>
</ul>
</li>
</ul>
<h3 id="根据版本号来适配"><a href="#根据版本号来适配" class="headerlink" title="根据版本号来适配"></a>根据版本号来适配</h3><ul>
<li><p>Android 6.0的权限系统</p>
<p>  protected boolean hasPermission(String permission) {</p>
<pre><code>if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.LOLLIPOP_MR1)
    return (checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED);
return true;
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>判断是否有权限，如果版本大于5.1才需要判断（即6.0以上），其他则不需要判断。Build.VERSION.SDK_INT是指当前设备的API Level。</p>
</blockquote>
<ul>
<li><p>通知的部分属性</p>
<p>  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) {</p>
<pre><code>builder.setSubText(&quot;it is really basic&quot;);
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>通知的副标题需要API Level 16才能使用。</p>
<p>当然API Level也可以直接写成数字,不过不建议大家这样做，这里你可能记得16数字的含义，可是在其他地方使用数字你可能就不记得了，所以为了规范还是写VERSION_CODES吧，毕竟这样逼格也更高！</p>
</blockquote>
<pre><code>if (Build.VERSION.SDK_INT &gt;= 16) {    
    builder.setSubText(&quot;it is really basic&quot;);
}
</code></pre><p><strong>参考文献</strong></p>
<p><a href="https://zh.wikipedia.org/wiki/Android%E6%AD%B7%E5%8F%B2%E7%89%88%E6%9C%AC" target="_blank" rel="external">https://zh.wikipedia.org/wiki/Android%E6%AD%B7%E5%8F%B2%E7%89%88%E6%9C%AC</a><br><a href="http://www.cnblogs.com/kangjianwei101/p/5220035.html" target="_blank" rel="external">http://www.cnblogs.com/kangjianwei101/p/5220035.html</a><br><a href="http://www.jianshu.com/p/830d0eb44a56" target="_blank" rel="external">http://www.jianshu.com/p/830d0eb44a56</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Android目前为止所有发布的版本以及对应的API等级&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Android-SDK版本&quot;&gt;&lt;a href=&quot;#Android-SDK版本&quot; class=&quot;headerlink&quot; title=&quot;Android SDK版本
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Android版本" scheme="http://yoursite.com/tags/Android%E7%89%88%E6%9C%AC/"/>
    
      <category term="API等级" scheme="http://yoursite.com/tags/API%E7%AD%89%E7%BA%A7/"/>
    
      <category term="SDK版本适配" scheme="http://yoursite.com/tags/SDK%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android开发人员不得不收集的代码(持续更新中)</title>
    <link href="http://yoursite.com/2017/07/29/Android%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%94%B6%E9%9B%86%E7%9A%84%E4%BB%A3%E7%A0%81(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD)/"/>
    <id>http://yoursite.com/2017/07/29/Android开发人员不得不收集的代码(持续更新中)/</id>
    <published>2017-07-29T03:17:18.000Z</published>
    <updated>2017-07-29T03:21:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Blankj/AndroidUtilCode/master/art/logo.png" alt=""></p>
<p><a href="https://github.com/Blankj/AndroidUtilCode" target="_blank" rel="external"><img src="https://img.shields.io/badge/AndroidUtilCode-v1.7.1-brightgreen.svg" alt="auc"></a> <a href="https://android-arsenal.com/api?level=15" target="_blank" rel="external"><img src="https://img.shields.io/badge/API-15+-brightgreen.svg" alt="api"></a> <a href="https://travis-ci.org/Blankj/AndroidUtilCode" target="_blank" rel="external"><img src="https://travis-ci.org/Blankj/AndroidUtilCode.svg?branch=master" alt="build"></a> <a href="https://insight.io/github.com/Blankj/AndroidUtilCode" target="_blank" rel="external"><img src="https://www.insight.io/repoBadge/github.com/Blankj/AndroidUtilCode" alt="Insight"></a> <a href="https://github.com/Blankj/AndroidUtilCode/blob/master/LICENSE" target="_blank" rel="external"><img src="https://img.shields.io/badge/License-Apache--2.0-brightgreen.svg" alt="License"></a></p>
<p><a href="https://github.com/Blankj/AndroidUtilCode" target="_blank" rel="external">README of English</a></p>
<p><strong>API</strong></p>
<ul>
<li><p>Activity相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/ActivityUtils.java" target="_blank" rel="external">ActivityUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/ActivityActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  isActivityExists   : 判断是否存在Activity<br>  startActivity      : 打开Activity<br>  getLauncherActivity: 获取入口activity<br>  getTopActivity     : 获取栈顶Activity</p>
</li>
<li><p>App相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/AppUtils.java" target="_blank" rel="external">AppUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/AppActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  isInstallApp         : 判断App是否安装<br>  installApp           : 安装App（支持7.0）<br>  installAppSilent     : 静默安装App<br>  uninstallApp         : 卸载App<br>  uninstallAppSilent   : 静默卸载App<br>  isAppRoot            : 判断App是否有root权限<br>  launchApp            : 打开App<br>  getAppPackageName    : 获取App包名<br>  getAppDetailsSettings: 获取App具体设置<br>  getAppName           : 获取App名称<br>  getAppIcon           : 获取App图标<br>  getAppPath           : 获取App路径<br>  getAppVersionName    : 获取App版本号<br>  getAppVersionCode    : 获取App版本码<br>  isSystemApp          : 判断App是否是系统应用<br>  isAppDebug           : 判断App是否是Debug版本<br>  getAppSignature      : 获取App签名<br>  getAppSignatureSHA1  : 获取应用签名的的SHA1值<br>  isAppForeground      : 判断App是否处于前台<br>  getForegroundApp     : 获取前台应用包名<br>  getAppInfo           : 获取App信息<br>  getAppsInfo          : 获取所有已安装App信息</p>
</li>
<li><p>栏相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/BarUtils.java" target="_blank" rel="external">BarUtils.java</a></p>
<p>  setTransparentStatusBar: 设置透明状态栏（api大于19方可使用）<br>  hideStatusBar          : 隐藏状态栏<br>  getStatusBarHeight     : 获取状态栏高度<br>  isStatusBarExists      : 判断状态栏是否存在<br>  getActionBarHeight     : 获取ActionBar高度<br>  showNotificationBar    : 显示通知栏<br>  hideNotificationBar    : 隐藏通知栏</p>
</li>
<li><p>缓存相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/CacheUtils.java" target="_blank" rel="external">CacheUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/test/java/com/blankj/utilcode/util/CacheUtilsTest.java" target="_blank" rel="external">Test</a></p>
<p>  getInstance    : 获取缓存实例<br>  put            : 缓存中写入数据<br>  getBytes       : 缓存中读取字节数组<br>  getString      : 缓存中读取String<br>  getJSONObject  : 缓存中读取JSONObject<br>  getJSONArray   : 缓存中读取JSONArray<br>  getBitmap      : 缓存中读取Bitmap<br>  getDrawable    : 缓存中读取Drawable<br>  getParcelable  : 缓存中读取Parcelable<br>  getSerializable: 缓存中读取Serializable<br>  getCacheSize   : 获取缓存大小<br>  getCacheCount  : 获取缓存个数<br>  remove         : 根据键值移除缓存<br>  clear          : 清除所有缓存</p>
</li>
<li><p>清除相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/CleanUtils.java" target="_blank" rel="external">CleanUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/CleanActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  cleanInternalCache   : 清除内部缓存<br>  cleanInternalFiles   : 清除内部文件<br>  cleanInternalDbs     : 清除内部数据库<br>  cleanInternalDbByName: 根据名称清除数据库<br>  cleanInternalSP      : 清除内部SP<br>  cleanExternalCache   : 清除外部缓存<br>  cleanCustomCache     : 清除自定义目录下的文件</p>
</li>
<li><p>剪贴板相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/ClipboardUtils.java" target="_blank" rel="external">ClipboardUtils.java</a></p>
<p>  copyText  : 复制文本到剪贴板<br>  getText   : 获取剪贴板的文本<br>  copyUri   : 复制uri到剪贴板<br>  getUri    : 获取剪贴板的uri<br>  copyIntent: 复制意图到剪贴板<br>  getIntent : 获取剪贴板的意图</p>
</li>
<li><p>关闭相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/CloseUtils.java" target="_blank" rel="external">CloseUtils.java</a></p>
<p>  closeIO       : 关闭IO<br>  closeIOQuietly: 安静关闭IO</p>
</li>
<li><p>转换相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/ConvertUtils.java" target="_blank" rel="external">ConvertUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/test/java/com/blankj/utilcode/util/ConvertUtilsTest.java" target="_blank" rel="external">Test</a></p>
<p>  bytes2HexString, hexString2Bytes        : byteArr与hexString互转<br>  chars2Bytes, bytes2Chars                : charArr与byteArr互转<br>  memorySize2Byte, byte2MemorySize        : 以unit为单位的内存大小与字节数互转<br>  byte2FitMemorySize                      : 字节数转合适内存大小<br>  timeSpan2Millis, millis2TimeSpan        : 以unit为单位的时间长度与毫秒时间戳互转<br>  millis2FitTimeSpan                      : 毫秒时间戳转合适时间长度<br>  bytes2Bits, bits2Bytes                  : bytes与bits互转<br>  input2OutputStream, output2InputStream  : inputStream与outputStream互转<br>  inputStream2Bytes, bytes2InputStream    : inputStream与byteArr互转<br>  outputStream2Bytes, bytes2OutputStream  : outputStream与byteArr互转<br>  inputStream2String, string2InputStream  : inputStream与string按编码互转<br>  outputStream2String, string2OutputStream: outputStream与string按编码互转<br>  bitmap2Bytes, bytes2Bitmap              : bitmap与byteArr互转<br>  drawable2Bitmap, bitmap2Drawable        : drawable与bitmap互转<br>  drawable2Bytes, bytes2Drawable          : drawable与byteArr互转<br>  view2Bitmap                             : view转Bitmap<br>  dp2px, px2dp                            : dp与px互转<br>  sp2px, px2sp                            : sp与px互转</p>
</li>
<li><p>崩溃相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/CrashUtils.java" target="_blank" rel="external">CrashUtils.java</a></p>
<p>  init: 初始化</p>
</li>
<li><p>设备相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/DeviceUtils.java" target="_blank" rel="external">DeviceUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/DeviceActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  isDeviceRooted   : 判断设备是否rooted<br>  getSDKVersion    : 获取设备系统版本号<br>  getAndroidID     : 获取设备AndroidID<br>  getMacAddress    : 获取设备MAC地址<br>  getManufacturer  : 获取设备厂商<br>  getModel         : 获取设备型号<br>  shutdown         : 关机<br>  reboot           : 重启<br>  reboot2Recovery  : 重启到recovery<br>  reboot2Bootloader: 重启到bootloader</p>
</li>
<li><p>判空相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/EmptyUtils.java" target="_blank" rel="external">EmptyUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/test/java/com/blankj/utilcode/util/EmptyUtilsTest.java" target="_blank" rel="external">Test</a></p>
<p>  isEmpty   : 判断对象是否为空<br>  isNotEmpty: 判断对象是否非空</p>
</li>
<li><p>编码解码相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/EncodeUtils.java" target="_blank" rel="external">EncodeUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/test/java/com/blankj/utilcode/util/EncodeUtilsTest.java" target="_blank" rel="external">Test</a></p>
<p>  urlEncode          : URL编码<br>  urlDecode          : URL解码<br>  base64Encode       : Base64编码<br>  base64Encode2String: Base64编码<br>  base64Decode       : Base64解码<br>  base64UrlSafeEncode: Base64URL安全编码<br>  htmlEncode         : Html编码<br>  htmlDecode         : Html解码</p>
</li>
<li><p>加密解密相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/EncryptUtils.java" target="_blank" rel="external">EncryptUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/test/java/com/blankj/utilcode/util/EncryptUtilsTest.java" target="_blank" rel="external">Test</a></p>
<p>  encryptMD2, encryptMD2ToString                        : MD2加密<br>  encryptMD5, encryptMD5ToString                        : MD5加密<br>  encryptMD5File, encryptMD5File2String                 : MD5加密文件<br>  encryptSHA1, encryptSHA1ToString                      : SHA1加密<br>  encryptSHA224, encryptSHA224ToString                  : SHA224加密<br>  encryptSHA256, encryptSHA256ToString                  : SHA256加密<br>  encryptSHA384, encryptSHA384ToString                  : SHA384加密<br>  encryptSHA512, encryptSHA512ToString                  : SHA512加密<br>  encryptHmacMD5, encryptHmacMD5ToString                : HmacMD5加密<br>  encryptHmacSHA1, encryptHmacSHA1ToString              : HmacSHA1加密<br>  encryptHmacSHA224, encryptHmacSHA224ToString          : HmacSHA224加密<br>  encryptHmacSHA256, encryptHmacSHA256ToString          : HmacSHA256加密<br>  encryptHmacSHA384, encryptHmacSHA384ToString          : HmacSHA384加密<br>  encryptHmacSHA512, encryptHmacSHA512ToString          : HmacSHA512加密<br>  encryptDES, encryptDES2HexString, encryptDES2Base64   : DES加密<br>  decryptDES, decryptHexStringDES, decryptBase64DES     : DES解密<br>  encrypt3DES, encrypt3DES2HexString, encrypt3DES2Base64: 3DES加密<br>  decrypt3DES, decryptHexString3DES, decryptBase64_3DES : 3DES解密<br>  encryptAES, encryptAES2HexString, encryptAES2Base64   : AES加密<br>  decryptAES, decryptHexStringAES, decryptBase64AES     : AES解密</p>
</li>
<li><p>文件相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/FileIOUtils.java" target="_blank" rel="external">FileIOUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/test/java/com/blankj/utilcode/util/FileIOUtilsTest.java" target="_blank" rel="external">Test</a></p>
<p>  writeFileFromIS            : 将输入流写入文件<br>  writeFileFromBytesByStream : 将字节数组写入文件<br>  writeFileFromBytesByChannel: 将字节数组写入文件<br>  writeFileFromBytesByMap    : 将字节数组写入文件<br>  writeFileFromString        : 将字符串写入文件<br>  readFile2List              : 读取文件到字符串链表中<br>  readFile2String            : 读取文件到字符串中<br>  readFile2BytesByStream     : 读取文件到字节数组中<br>  readFile2BytesByChannel    : 读取文件到字节数组中<br>  readFile2BytesByMap        : 读取文件到字节数组中<br>  setBufferSize              : 设置缓冲区尺寸</p>
</li>
<li><p>文件相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/FileUtils.java" target="_blank" rel="external">FileUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/test/java/com/blankj/utilcode/util/FileUtilsTest.java" target="_blank" rel="external">Test</a></p>
<p>  getFileByPath            : 根据文件路径获取文件<br>  isFileExists             : 判断文件是否存在<br>  rename                   : 重命名文件<br>  isDir                    : 判断是否是目录<br>  isFile                   : 判断是否是文件<br>  createOrExistsDir        : 判断目录是否存在，不存在则判断是否创建成功<br>  createOrExistsFile       : 判断文件是否存在，不存在则判断是否创建成功<br>  createFileByDeleteOldFile: 判断文件是否存在，存在则在创建之前删除<br>  copyDir                  : 复制目录<br>  copyFile                 : 复制文件<br>  moveDir                  : 移动目录<br>  moveFile                 : 移动文件<br>  deleteDir                : 删除目录<br>  deleteFile               : 删除文件<br>  listFilesInDir           : 获取目录下所有文件<br>  listFilesInDir           : 获取目录下所有文件包括子目录<br>  listFilesInDirWithFilter : 获取目录下所有后缀名为suffix的文件<br>  listFilesInDirWithFilter : 获取目录下所有后缀名为suffix的文件包括子目录<br>  listFilesInDirWithFilter : 获取目录下所有符合filter的文件<br>  listFilesInDirWithFilter : 获取目录下所有符合filter的文件包括子目录<br>  searchFileInDir          : 获取目录下指定文件名的文件包括子目录<br>  getFileLastModified      : 获取文件最后修改的毫秒时间戳<br>  getFileCharsetSimple     : 简单获取文件编码格式<br>  getFileLines             : 获取文件行数<br>  getDirSize               : 获取目录大小<br>  getFileSize              : 获取文件大小<br>  getDirLength             : 获取目录长度<br>  getFileLength            : 获取文件长度<br>  getFileMD5               : 获取文件的MD5校验码<br>  getFileMD5ToString       : 获取文件的MD5校验码<br>  getDirName               : 根据全路径获取最长目录<br>  getFileName              : 根据全路径获取文件名<br>  getFileNameNoExtension   : 根据全路径获取文件名不带拓展名<br>  getFileExtension         : 根据全路径获取文件拓展名</p>
</li>
<li><p>Fragment相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/FragmentUtils.java" target="_blank" rel="external">FragmentUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/FragmentActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  addFragment              : 新增fragment<br>  hideAddFragment          : 先隐藏后新增fragment<br>  addFragments             : 新增多个fragment<br>  removeFragment           : 移除fragment<br>  removeToFragment         : 移除到指定fragment<br>  removeFragments          : 移除同级别fragment<br>  removeAllFragments       : 移除所有fragment<br>  replaceFragment          : 替换fragment<br>  popFragment              : 出栈fragment<br>  popToFragment            : 出栈到指定fragment<br>  popFragments             : 出栈同级别fragment<br>  popAllFragments          : 出栈所有fragment<br>  popAddFragment           : 先出栈后新增fragment<br>  hideFragment             : 隐藏fragment<br>  hideFragments            : 隐藏同级别fragment<br>  showFragment             : 显示fragment<br>  hideShowFragment         : 先隐藏后显示fragment<br>  getLastAddFragment       : 获取同级别最后加入的fragment<br>  getLastAddFragmentInStack: 获取栈中同级别最后加入的fragment<br>  getTopShowFragment       : 获取顶层可见fragment<br>  getTopShowFragmentInStack: 获取栈中顶层可见fragment<br>  getFragments             : 获取同级别fragment<br>  getFragmentsInStack      : 获取栈中同级别fragment<br>  getAllFragments          : 获取所有fragment<br>  getAllFragmentsInStack   : 获取栈中所有fragment<br>  getPreFragment           : 获取目标fragment的前一个fragment<br>  findFragment             : 查找fragment<br>  dispatchBackPress        : 处理fragment回退键<br>  setBackgroundColor       : 设置背景色<br>  setBackgroundResource    : 设置背景资源<br>  setBackground            : 设置背景</p>
</li>
<li><p>图片相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/ImageUtils.java" target="_blank" rel="external">ImageUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/ImageActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  bitmap2Bytes, bytes2Bitmap      : bitmap与byteArr互转<br>  drawable2Bitmap, bitmap2Drawable: drawable与bitmap互转<br>  drawable2Bytes, bytes2Drawable  : drawable与byteArr互转<br>  getBitmap                       : 获取bitmap<br>  scale                           : 缩放图片<br>  clip                            : 裁剪图片<br>  skew                            : 倾斜图片<br>  rotate                          : 旋转图片<br>  getRotateDegree                 : 获取图片旋转角度<br>  toRound                         : 转为圆形图片<br>  toRoundCorner                   : 转为圆角图片<br>  fastBlur                        : 快速模糊<br>  renderScriptBlur                : renderScript模糊图片<br>  stackBlur                       : stack模糊图片<br>  addFrame                        : 添加颜色边框<br>  addReflection                   : 添加倒影<br>  addTextWatermark                : 添加文字水印<br>  addImageWatermark               : 添加图片水印<br>  toAlpha                         : 转为alpha位图<br>  toGray                          : 转为灰度图片<br>  save                            : 保存图片<br>  isImage                         : 根据文件名判断文件是否为图片<br>  getImageType                    : 获取图片类型<br>  compressByScale                 : 按缩放压缩<br>  compressByQuality               : 按质量压缩<br>  compressBySampleSize            : 按采样大小压缩</p>
</li>
<li><p>意图相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/IntentUtils.java" target="_blank" rel="external">IntentUtils.java</a></p>
<p>  getInstallAppIntent        : 获取安装App（支持6.0）的意图<br>  getUninstallAppIntent      : 获取卸载App的意图<br>  getLaunchAppIntent         : 获取打开App的意图<br>  getAppDetailsSettingsIntent: 获取App具体设置的意图<br>  getShareTextIntent         : 获取分享文本的意图<br>  getShareImageIntent        : 获取分享图片的意图<br>  getComponentIntent         : 获取其他应用组件的意图<br>  getShutdownIntent          : 获取关机的意图<br>  getCaptureIntent           : 获取拍照的意图</p>
</li>
<li><p>键盘相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/KeyboardUtils.java" target="_blank" rel="external">KeyboardUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/KeyboardActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  showSoftInput               : 动态显示软键盘<br>  hideSoftInput               : 动态隐藏软键盘<br>  toggleSoftInput             : 切换键盘显示与否状态<br>  clickBlankArea2HideSoftInput: 点击屏幕空白区域隐藏软键盘</p>
</li>
<li><p>定位相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/LocationUtils.java" target="_blank" rel="external">LocationUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/LocationActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  isGpsEnabled     : 判断Gps是否可用<br>  isLocationEnabled: 判断定位是否可用<br>  openGpsSettings  : 打开Gps设置界面<br>  register         : 注册<br>  unregister       : 注销<br>  getAddress       : 根据经纬度获取地理位置<br>  getCountryName   : 根据经纬度获取所在国家<br>  getLocality      : 根据经纬度获取所在地<br>  getStreet        : 根据经纬度获取所在街道<br>  isBetterLocation : 是否更好的位置<br>  isSameProvider   : 是否相同的提供者</p>
</li>
<li><p>日志相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/LogUtils.java" target="_blank" rel="external">LogUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/LogActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  Builder.setLogSwitch     : 设置log总开关<br>  Builder.setConsoleSwitch : 设置log控制台开关<br>  Builder.setGlobalTag     : 设置log全局tag<br>  Builder.setLogHeadSwitch : 设置log头部信息开关<br>  Builder.setLog2FileSwitch: 设置log文件开关<br>  Builder.setDir           : 设置log文件存储目录<br>  Builder.setBorderSwitch  : 设置log边框开关<br>  Builder.setConsoleFilter : 设置log控制台过滤器<br>  Builder.setFileFilter    : 设置log文件过滤器<br>  v                        : Verbose日志<br>  d                        : Debug日志<br>  i                        : Info日志<br>  w                        : Warn日志<br>  e                        : Error日志<br>  a                        : Assert日志<br>  file                     : log到文件<br>  json                     : log字符串之json<br>  xml                      : log字符串之xml</p>
</li>
<li><p>网络相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/NetworkUtils.java" target="_blank" rel="external">NetworkUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/NetworkActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  openWirelessSettings  : 打开网络设置界面<br>  isConnected           : 判断网络是否连接<br>  isAvailableByPing     : 判断网络是否可用<br>  getDataEnabled        : 判断移动数据是否打开<br>  setDataEnabled        : 打开或关闭移动数据<br>  is4G                  : 判断网络是否是4G<br>  getWifiEnabled        : 判断wifi是否打开<br>  setWifiEnabled        : 打开或关闭wifi<br>  isWifiConnected       : 判断wifi是否连接状态<br>  isWifiAvailable       : 判断wifi数据是否可用<br>  getNetworkOperatorName: 获取移动网络运营商名称<br>  getNetworkType        : 获取当前网络类型<br>  getIPAddress          : 获取IP地址<br>  getDomainAddress      : 获取域名ip地址</p>
</li>
<li><p>手机相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/PhoneUtils.java" target="_blank" rel="external">PhoneUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/PhoneActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  isPhone            : 判断设备是否是手机<br>  getIMEI            : 获取IMEI码<br>  getIMSI            : 获取IMSI码<br>  getPhoneType       : 获取移动终端类型<br>  isSimCardReady     : 判断sim卡是否准备好<br>  getSimOperatorName : 获取Sim卡运营商名称<br>  getSimOperatorByMnc: 获取Sim卡运营商名称<br>  getPhoneStatus     : 获取手机状态信息<br>  dial               : 跳至拨号界面<br>  call               : 拨打phoneNumber<br>  sendSms            : 跳至发送短信界面<br>  sendSmsSilent      : 发送短信<br>  getAllContactInfo  : 获取手机联系人<br>  getContactNum      : 打开手机联系人界面点击联系人后便获取该号码<br>  getAllSMS          : 获取手机短信并保存到xml中</p>
</li>
<li><p>拼音相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/PinyinUtils.java" target="_blank" rel="external">PinyinUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/test/java/com/blankj/utilcode/util/PinyinUtilsTest.java" target="_blank" rel="external">Test</a></p>
<p>  ccs2Pinyin           : 汉字转拼音<br>  ccs2Pinyin           : 汉字转拼音<br>  getPinyinFirstLetter : 获取第一个汉字首字母<br>  getPinyinFirstLetters: 获取所有汉字的首字母<br>  getSurnamePinyin     : 根据名字获取姓氏的拼音<br>  getSurnameFirstLetter: 根据名字获取姓氏的首字母</p>
</li>
<li><p>进程相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/ProcessUtils.java" target="_blank" rel="external">ProcessUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/ProcessActivity.java" target="_blank" rel="external">Demo</a> </p>
<p>  getForegroundProcessName  : 获取前台线程包名<br>  killAllBackgroundProcesses: 杀死所有的后台服务进程<br>  killBackgroundProcesses   : 杀死后台服务进程</p>
</li>
<li><p>正则相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/RegexUtils.java" target="_blank" rel="external">RegexUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/test/java/com/blankj/utilcode/util/RegexUtilsTest.java" target="_blank" rel="external">Test</a></p>
<p>  isMobileSimple : 验证手机号（简单）<br>  isMobileExact  : 验证手机号（精确）<br>  isTel          : 验证电话号码<br>  isIDCard15     : 验证身份证号码15位<br>  isIDCard18     : 验证身份证号码18位<br>  isEmail        : 验证邮箱<br>  isURL          : 验证URL<br>  isZh           : 验证汉字<br>  isUsername     : 验证用户名<br>  isDate         : 验证yyyy-MM-dd格式的日期校验，已考虑平闰年<br>  isIP           : 验证IP地址<br>  isMatch        : 判断是否匹配正则<br>  getMatches     : 获取正则匹配的部分<br>  getSplits      : 获取正则匹配分组<br>  getReplaceFirst: 替换正则匹配的第一部分<br>  getReplaceAll  : 替换所有正则匹配的部分</p>
</li>
<li><p>屏幕相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/ScreenUtils.java" target="_blank" rel="external">ScreenUtils.java</a></p>
<p>  getScreenWidth         : 获取屏幕的宽度（单位：px）<br>  getScreenHeight        : 获取屏幕的高度（单位：px）<br>  setLandscape           : 设置屏幕为横屏<br>  setPortrait            : 设置屏幕为竖屏<br>  isLandscape            : 判断是否横屏<br>  isPortrait             : 判断是否竖屏<br>  getScreenRotation      : 获取屏幕旋转角度<br>  captureWithStatusBar   : 获取当前屏幕截图，包含状态栏<br>  captureWithoutStatusBar: 获取当前屏幕截图，不包含状态栏<br>  isScreenLock           : 判断是否锁屏</p>
</li>
<li><p>SD卡相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/SDCardUtils.java" target="_blank" rel="external">SDCardUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/SDCardActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  isSDCardEnable: 判断SD卡是否可用<br>  getSDCardPath : 获取SD卡路径<br>  getDataPath   : 获取SD卡Data路径<br>  getFreeSpace  : 计算SD卡的剩余空间<br>  getSDCardInfo : 获取SD卡信息</p>
</li>
<li><p>服务相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/ServiceUtils.java" target="_blank" rel="external">ServiceUtils.java</a></p>
<p>  getAllRunningService: 获取所有运行的服务<br>  startService        : 启动服务<br>  stopService         : 停止服务<br>  bindService         : 绑定服务<br>  unbindService       : 解绑服务<br>  isServiceRunning    : 判断服务是否运行</p>
</li>
<li><p>Shell相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/ShellUtils.java" target="_blank" rel="external">ShellUtils.java</a></p>
<p>  execCmd: 是否是在root下执行命令</p>
</li>
<li><p>尺寸相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/SizeUtils.java" target="_blank" rel="external">SizeUtils.java</a></p>
<p>  dp2px, px2dp     : dp与px转换<br>  sp2px, px2sp     : sp与px转换<br>  applyDimension   : 各种单位转换<br>  forceGetViewSize : 在onCreate中获取视图的尺寸<br>  measureView      : 测量视图尺寸<br>  getMeasuredWidth : 获取测量视图宽度<br>  getMeasuredHeight: 获取测量视图高度</p>
</li>
<li><p>Snackbar相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/SnackbarUtils.java" target="_blank" rel="external">SnackbarUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/SnackbarActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  with           : 设置snackbar依赖view<br>  setMessage     : 设置消息<br>  setMessageColor: 设置消息颜色<br>  setBgColor     : 设置背景色<br>  setBgResource  : 设置背景资源<br>  setDuration    : 设置显示时长<br>  setAction      : 设置行为<br>  setBottomMargin: 设置底边距<br>  show           : 显示snackbar<br>  showSuccess    : 显示预设成功的snackbar<br>  showWarning    : 显示预设警告的snackbar<br>  showError      : 显示预设错误的snackbar<br>  dismiss        : 消失snackbar<br>  getView        : 获取snackbar视图<br>  addView        : 添加snackbar视图</p>
</li>
<li><p>SpannableString相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/SpanUtils.java" target="_blank" rel="external">SpanUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/SpanActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  setFlag           : 设置标识<br>  setForegroundColor: 设置前景色<br>  setBackgroundColor: 设置背景色<br>  setLineHeight     : 设置行高<br>  setQuoteColor     : 设置引用线的颜色<br>  setLeadingMargin  : 设置缩进<br>  setBullet         : 设置列表标记<br>  setIconMargin     : 设置图标<br>  setFontSize       : 设置字体尺寸<br>  setFontProportion : 设置字体比例<br>  setFontXProportion: 设置字体横向比例<br>  setStrikethrough  : 设置删除线<br>  setUnderline      : 设置下划线<br>  setSuperscript    : 设置上标<br>  setSubscript      : 设置下标<br>  setBold           : 设置粗体<br>  setItalic         : 设置斜体<br>  setBoldItalic     : 设置粗斜体<br>  setFontFamily     : 设置字体系列<br>  setTypeface       : 设置字体<br>  setAlign          : 设置对齐<br>  setClickSpan      : 设置点击事件<br>  setUrl            : 设置超链接<br>  setBlur           : 设置模糊<br>  setShader         : 设置着色器<br>  setShadow         : 设置阴影<br>  setSpans          : 设置样式<br>  append            : 追加样式字符串<br>  appendLine        : 追加一行样式字符串<br>  appendImage       : 追加图片<br>  appendSpace       : 追加空白<br>  create            : 创建样式字符串</p>
</li>
<li><p>SP相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/SPUtils.java" target="_blank" rel="external">SPUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/test/java/com/blankj/utilcode/util/SPUtilsTest.java" target="_blank" rel="external">Test</a></p>
<p>  getInstance: 获取SP实例<br>  put        : SP中写入数据<br>  getString  : SP中读取String<br>  getInt     : SP中读取int<br>  getLong    : SP中读取long<br>  getFloat   : SP中读取float<br>  getBoolean : SP中读取boolean<br>  getAll     : SP中获取所有键值对<br>  contains   : SP中是否存在该key<br>  remove     : SP中移除该key<br>  clear      : SP中清除所有数据</p>
</li>
<li><p>字符串相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/StringUtils.java" target="_blank" rel="external">StringUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/test/java/com/blankj/utilcode/util/StringUtilsTest.java" target="_blank" rel="external">Test</a></p>
<p>  isEmpty         : 判断字符串是否为null或长度为0<br>  isTrimEmpty     : 判断字符串是否为null或全为空格<br>  isSpace         : 判断字符串是否为null或全为空白字符<br>  equals          : 判断两字符串是否相等<br>  equalsIgnoreCase: 判断两字符串忽略大小写是否相等<br>  null2Length0    : null转为长度为0的字符串<br>  length          : 返回字符串长度<br>  upperFirstLetter: 首字母大写<br>  lowerFirstLetter: 首字母小写<br>  reverse         : 反转字符串<br>  toDBC           : 转化为半角字符<br>  toSBC           : 转化为全角字符</p>
</li>
<li><p>线程池相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/ThreadPoolUtils.java" target="_blank" rel="external">ThreadPoolUtils.java</a></p>
<p>  ThreadPoolUtils       : ThreadPoolUtils构造函数<br>  execute               : 在未来某个时间执行给定的命令<br>  execute               : 在未来某个时间执行给定的命令链表<br>  shutDown              : 待以前提交的任务执行完毕后关闭线程池<br>  shutDownNow           : 试图停止所有正在执行的活动任务<br>  isShutDown            : 判断线程池是否已关闭<br>  isTerminated          : 关闭线程池后判断所有任务是否都已完成<br>  awaitTermination      : 请求关闭、发生超时或者当前线程中断<br>  submit                : 提交一个Callable任务用于执行<br>  submit                : 提交一个Runnable任务用于执行<br>  invokeAll, invokeAny  : 执行给定的任务<br>  schedule              : 延迟执行Runnable命令<br>  schedule              : 延迟执行Callable命令<br>  scheduleWithFixedRate : 延迟并循环执行命令<br>  scheduleWithFixedDelay: 延迟并以固定休息时间循环执行命令</p>
</li>
<li><p>时间相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/TimeUtils.java" target="_blank" rel="external">TimeUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/test/java/com/blankj/utilcode/util/TimeUtilsTest.java" target="_blank" rel="external">Test</a></p>
<p>  millis2String           : 将时间戳转为时间字符串<br>  string2Millis           : 将时间字符串转为时间戳<br>  string2Date             : 将时间字符串转为Date类型<br>  date2String             : 将Date类型转为时间字符串<br>  date2Millis             : 将Date类型转为时间戳<br>  millis2Date             : 将时间戳转为Date类型<br>  getTimeSpan             : 获取两个时间差（单位：unit）<br>  getFitTimeSpan          : 获取合适型两个时间差<br>  getNowMills             : 获取当前毫秒时间戳<br>  getNowString            : 获取当前时间字符串<br>  getNowDate              : 获取当前Date<br>  getTimeSpanByNow        : 获取与当前时间的差（单位：unit）<br>  getFitTimeSpanByNow     : 获取合适型与当前时间的差<br>  getFriendlyTimeSpanByNow: 获取友好型与当前时间的差<br>  getMillis               : 获取与给定时间等于时间差的时间戳<br>  getString               : 获取与给定时间等于时间差的时间字符串<br>  getDate                 : 获取与给定时间等于时间差的Date<br>  getMillisByNow          : 获取与当前时间等于时间差的时间戳<br>  getStringByNow          : 获取与当前时间等于时间差的时间字符串<br>  getDateByNow            : 获取与当前时间等于时间差的Date<br>  isToday                 : 判断是否今天<br>  isLeapYear              : 判断是否闰年<br>  getChineseWeek          : 获取中式星期<br>  getUSWeek               : 获取美式式星期<br>  getWeekIndex            : 获取星期索引<br>  getWeekOfMonth          : 获取月份中的第几周<br>  getWeekOfYear           : 获取年份中的第几周<br>  getChineseZodiac        : 获取生肖<br>  getZodiac               : 获取星座</p>
</li>
<li><p>吐司相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/ToastUtils.java" target="_blank" rel="external">ToastUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/app/src/main/java/com/blankj/androidutilcode/activity/ToastActivity.java" target="_blank" rel="external">Demo</a></p>
<p>  setGravity         : 设置吐司位置<br>  setView            : 设置吐司view<br>  getView            : 获取吐司view<br>  setBgColor         : 设置背景颜色<br>  setBgResource      : 设置背景资源<br>  setMessageColor    : 设置消息颜色<br>  showShortSafe      : 安全地显示短时吐司<br>  showLongSafe       : 安全地显示长时吐司<br>  showShort          : 显示短时吐司<br>  showLong           : 显示长时吐司<br>  showCustomShortSafe: 安全地显示短时自定义吐司<br>  showCustomLongSafe : 安全地显示长时自定义吐司<br>  showCustomShort    : 显示短时自定义吐司<br>  showCustomLong     : 显示长时自定义吐司<br>  cancel             : 取消吐司显示</p>
</li>
<li><p>压缩相关→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/ZipUtils.java" target="_blank" rel="external">ZipUtils.java</a>→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/test/java/com/blankj/utilcode/util/ZipUtilsTest.java" target="_blank" rel="external">Test</a></p>
<p>  zipFiles          : 批量压缩文件<br>  zipFile           : 压缩文件<br>  unzipFiles        : 批量解压文件<br>  unzipFile         : 解压文件<br>  unzipFileByKeyword: 解压带有关键字的文件<br>  getFilesPath      : 获取压缩文件中的文件路径链表<br>  getComments       : 获取压缩文件中的注释链表<br>  getEntries        : 获取压缩文件中的文件对象</p>
</li>
<li><p>更新Log→<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/update_log.md" target="_blank" rel="external">update_log.md</a></p>
</li>
</ul>
<p><strong>About</strong></p>
<ul>
<li><a href="http://www.jianshu.com/u/46702d5c6978" target="_blank" rel="external"><img src="https://img.shields.io/badge/%E7%AE%80%E4%B9%A6-Blankj-34a48e.svg" alt="jianshu"></a> <a href="http://weibo.com/3076228982" target="_blank" rel="external"><img src="https://img.shields.io/badge/weibo-__Blankj-34a48e.svg" alt="weibo"></a>  <a href="http://blankj.com" target="_blank" rel="external"><img src="https://img.shields.io/badge/Blog-Blankj-34a48e.svg" alt="Blog"></a> <a href="https://shang.qq.com/wpa/qunwpa?idkey=62baf2c3ec6b0863155b0c7a10c71bba2608cb0b6532fc18515835e54c69bdd3" target="_blank" rel="external"><img src="https://img.shields.io/badge/QQ0%E7%BE%A4(%E6%BB%A1)-74721490-ff73a3.svg" alt="QQ0Group"></a> <a href="https://shang.qq.com/wpa/qunwpa?idkey=d906789f84484465e2736f7b524366b4c23afeda38733d5c7b10fc3f6e406e9b" target="_blank" rel="external"><img src="https://img.shields.io/badge/QQ1%E7%BE%A4-25206533-ff73a3.svg" alt="QQ1Group"></a></li>
<li>做这份整理是想把它作为Android开发的小字典，当遇到一些琐碎问题时，不用再面向百度或者谷歌查询API的使用，费时费力，这里有的话，大家尽管撸走；同时也希望它能逐日壮大起来，期待大家的Star和完善，当然我也会一直更新发布版本和日志，为了方便大家导入，现已上传jcenter；其中很多代码也是汇四方之精华，谢谢前辈们的提供，当然最终还是要通过单元测试的，如有错误，请及时告之。</li>
</ul>
<p><strong>Download</strong></p>
<p>Gradle:</p>
<pre><code>compile &apos;com.blankj:utilcode:1.7.1&apos;
</code></pre><p><strong>How to use</strong></p>
<pre><code>// init it in the function of onCreate in ur Application
Utils.init(context);
</code></pre><p><strong>Proguard</strong></p>
<pre><code>-keep class com.blankj.utilcode.** { *; }
-keepclassmembers class com.blankj.utilcode.** { *; }
-dontwarn com.blankj.utilcode.**
</code></pre><p><strong>Reference</strong></p>
<p><a href="http://www.jianshu.com/p/72494773aace" target="_blank" rel="external">http://www.jianshu.com/p/72494773aace</a><br><a href="https://github.com/Blankj/AndroidUtilCode" target="_blank" rel="external">https://github.com/Blankj/AndroidUtilCode</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Blankj/AndroidUtilCode/master/art/logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Blankj
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="工具类" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
      <category term="第三方库" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="http://yoursite.com/2017/04/28/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/04/28/Java注解/</id>
    <published>2017-04-28T05:15:10.000Z</published>
    <updated>2017-04-29T03:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h4><blockquote>
<p>注解(Annotation)在<strong>JDK1.5</strong>之后增加的一个新特性，注解的引入意义很大，有很多非常有名的框架，比如Hibernate、Spring等框架中都大量使用注解。注解作为<strong>程序的元数据</strong>嵌入到程序。注解可以被解析工具或编译工具解析，此处注意<strong>注解不同于注释(comment)</strong>。</p>
</blockquote>
<h4 id="本文目标"><a href="#本文目标" class="headerlink" title="本文目标"></a>本文目标</h4><blockquote>
<p>讲述Java Annotation的原理，以及如何自定义Java注解以及通过反射解析注解</p>
</blockquote>
<p><strong>为什么学习注解？</strong><br><strong>学习注解有什么好处？</strong><br><strong>学完之后能做什么？</strong></p>
<ul>
<li>可以读懂大牛们的代码，特别是和框架相关的代码（如：Spring，MyBatis）</li>
<li>让编程更加简洁，让代码更加清晰</li>
</ul>
<h3 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h3><h4 id="按运行机制分类"><a href="#按运行机制分类" class="headerlink" title="按运行机制分类"></a>按运行机制分类</h4><ul>
<li>源码注解: 注解只在源码.java文件中存在，编译成.class文件后就不存在了</li>
<li>编译时注解: 在源码.java文件和.class文件中都存在（如：@Override，@Deprecated，@Suppvisewarnnings）</li>
<li>运行时注解: 在运行阶段还会起作用，甚至会影响运行逻辑的注解（如：@Autowired等）</li>
</ul>
<blockquote>
<p>对于编译器处理的注解，可以使用APT处理。</p>
</blockquote>
<h4 id="按来源来分类"><a href="#按来源来分类" class="headerlink" title="按来源来分类"></a>按来源来分类</h4><ul>
<li>来自JDK的注解</li>
</ul>
<blockquote>
<p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 包中，剩下 4 个在 java.lang.annotation包中</p>
</blockquote>
<p><strong>作用在代码的注解</strong></p>
<ul>
<li><p><em>@Override</em></p>
<pre><code>@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
</code></pre></li>
</ul>
<blockquote>
<p>用途：用于告知编译器，我们需要覆写超类的当前方法。如果某个方法带有该注解但并没有覆写超类相应的方法，则编译器会生成一条错误信息。</p>
<p>注解类型分析：@Override可适用元素为方法，仅仅保留在java源文件中。</p>
</blockquote>
<ul>
<li><p><em>@Deprecated</em></p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
</code></pre></li>
</ul>
<blockquote>
<p>用途：用于告知编译器，某一程序元素(比如方法，成员变量)不建议使用时，如果使用该方法，会报编译警告，此时应该使用这个注解。Java在javadoc中推荐使用该注解，一般应该提供为什么该方法不推荐使用以及相应替代方法。</p>
<p>注解类型分析： @Deprecated可适合用于除注解类型声明之外的所有元素，保留时长为运行时VM。</p>
</blockquote>
<ul>
<li><p><em>@SuppressWarnings</em></p>
<pre><code>@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL\_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
</code></pre></li>
</ul>
<blockquote>
<p>用途：用于告知编译器忽略特定的警告信息，压制警告。例在泛型中使用原生数据类型。</p>
<p>注解类型分析： @SuppressWarnings可适合用于除注解类型声明和包名之外的所有元素，仅仅保留在java源文件中。</p>
<p>该注解有方法value(）,可支持多个字符串参数，例如：<br>    @SuppressWarnings({“uncheck”,”deprecation”})</p>
<p>前面讲的@Override，@Deprecated都是无需参数的，而@SuppressWarnings(压制警告)是需要带有参数的，可用参数如下：</p>
</blockquote>
<ul>
<li>deprecation: 使用了过时的类或方法时的警告</li>
<li>unchecked:执行了未检查的转换时的警告</li>
<li>fallthrough: 当Switch程序块进入进入下一个case而没有Break时的警告</li>
<li>path: 在类路径、源文件路径等有不存在路径时的警告</li>
<li>serial: 当可序列化的类缺少serialVersionUID定义时的警告</li>
<li>finally: 任意finally子句不能正常完成时的警告</li>
<li><p>all: 以上所有情况的警告</p>
<p>  <strong>三种注解的对比</strong></p>
<blockquote>
<p>Override—METHOD(Target)—SOURCE(Retention)<br>SuppressWarnings—除ANNOTATION_TYPE和PACKAGE外的所有(Target)—SOURCE(Retention)<br>Deprecated—除ANNOTATION_TYPE外的所有(Target)—RUNTIME(Retention)</p>
</blockquote>
</li>
</ul>
<p><strong>作用在其他注解的注解(元注解)</strong></p>
<blockquote>
<p>给注解进行注解的注解（注解的注解称为元注解）, 用来进行自定义注解。</p>
</blockquote>
<ul>
<li><p><em>@Retention </em></p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION\_TYPE)
public @interface Retention {
   RetentionPolicy value();
}   
</code></pre></li>
</ul>
<blockquote>
<p>用途：定义自定义注解的生命周期（由RetentionPolicy封装），表示注解类型的存活时长。标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</p>
<p>表示该注解类型的注解保留的时长。当注解类型声明中没有@Retention元注解，则默认保留策略为RetentionPolicy.CLASS。关于保留策略(RetentionPolicy)是枚举类型，共定义3种保留策略.</p>
</blockquote>
<pre><code>// 注解保留策略，用于Retention注解类型
public enum RetentionPolicy {
/**
 * Annotations are to be discarded by the compiler.
 */
SOURCE, // 只在Java源码显示，经过编译器后便丢弃相应的注解
/**
 * Annotations are to be recorded in the class file by the compiler
 * but need not be retained by the VM at run time.  This is the default
 * behavior.
 */
CLASS, // 存在Java源文件，以及经编译器后生成的Class字节码文件，但在运行时VM不再保留注释
/**
 * Annotations are to be recorded in the class file by the compiler and
 * retained by the VM at run time, so they may be read reflectively.
 * @see java.lang.reflect.AnnotatedElement
 */
RUNTIME // 存在源文件、编译生成的Class字节码文件，以及保留在运行时VM中，可通过反射性地读取注解
}
</code></pre><ul>
<li><p><em>@Target </em></p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION\_TYPE)
public @interface Target {
    ElementType[] value();
}
</code></pre></li>
</ul>
<blockquote>
<p>用途：用来定义自定义注解的作用域（作用域由ElementType类封装），表示注解类型所适用的程序元素的种类，标记这个注解应该是哪种Java 成员。</p>
<p>表示该注解类型的所使用的程序元素类型。当注解类型声明中没有@Target元注解，则默认为可适用<strong>所有的程序元素</strong>。如果存在指定的@Target元注解，则编译器强制实施相应的使用限制。关于程序元素(ElementType)是枚举类型，共定义8种程序元素。</p>
</blockquote>
<pre><code>// 程序元素类型，用于Target注解类型
public enum ElementType {  
    /** Class, interface (including annotation type), or enum declaration */
    TYPE, //  类/接口声明
    /** Field declaration (includes enum constants) */
    FIELD, // 字段声明（包括枚举常量）
    /** Method declaration */
    METHOD, // 方法声明
    /** Formal parameter declaration */
    PARAMETER, // 参数声明
    /** Constructor declaration */
    CONSTRUCTOR, // 构造方法声明
    /** Local variable declaration */
    LOCAL_VARIABLE, // 局部变量声明
    /** Annotation type declaration */
    ANNOTATION_TYPE, // 注解类型声明
    /** Package declaration */
    PACKAGE, // 包声明
    /**
     * Type parameter declaration
     * @since 1.8
     */
    TYPE_PARAMETER,
    /**
     * Use of a type
     * @since 1.8
     */
    TYPE_USE
}
</code></pre><blockquote>
<p>上面源码@Target的定义中有一行@Target(ElementType.ANNOTATION_TYPE)，意思是指当前注解的元素类型是注解类型。</p>
</blockquote>
<ul>
<li><p>@Documented - 标记这些注解是否包含在用户文档中。</p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION\_TYPE)
public @interface Documented {
}
</code></pre></li>
</ul>
<blockquote>
<p>用途：生成javadoc时会包含注解信息，表示含有该注解类型的元素(带有注释的)会通过javadoc或类似工具进行文档化</p>
<p>表示拥有该注解的元素可通过javadoc此类的工具进行文档化。该类型应用于注解那些影响客户使用带注释(comment)的元素声明的类型。如果类型声明是用Documented来注解的，这种类型的注解被作为被标注的程序成员的公共API。</p>
<p>上面代码@Retention的定义中有一行@Documented，意思是指当前注解的元素会被javadoc工具进行文档化，那么在查看Java API文档时可查看当该注解元素。</p>
</blockquote>
<ul>
<li><p><em>@Inherited</em> </p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION\_TYPE)
public @interface Inherited {
}
</code></pre></li>
</ul>
<blockquote>
<p>用途：标记这个注解是继承于哪个注解类(默认注解并没有继承于任何子类) ，允许子类继承(接口继承无效),只会继承类上面的注解，表示注解类型能被自动继承。（标识型元注解）</p>
<p>表示该注解类型被自动继承，如果用户在当前类中查询这个元注解类型并且当前类的声明中不包含这个元注解类型，那么也将自动查询当前类的父类是否存在Inherited元注解，这个动作将被重复执行知道这个标注类型被找到，或者是查询到顶层的父类.</p>
</blockquote>
<p><strong>从 Java 7 开始，额外添加了 3 个注解</strong></p>
<ul>
<li><em>@SafeVarargs</em> - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
<li><em>@FunctionalInterface</em> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
<li><em>@Repeatable</em> - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li>
</ul>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><blockquote>
<p>当一个接口直接继承_java.lang.annotation.Annotation_接口时，仍是接口，而并非注解。要想自定义注解类型，只能通过<strong>@interface关键字</strong>的方式，其实通过该方式会隐含地继承Annotation接口。</p>
</blockquote>
<p><strong>自定义注解的语法要求</strong></p>
<pre><code>@Target({ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Description {
    String desc();
    String author();
    int age() default 18;
}
</code></pre><p><strong>说明</strong></p>
<ul>
<li>使用<strong>public @interface</strong>关键字定义注解</li>
<li>成员以<strong>无参无异常</strong>的方式声明（如：String desc();）</li>
<li>注解和接口类似，内部可以定义常量和方法</li>
<li>可以给成员指定一个默认的值（如：int age() default 18;）</li>
<li>成员的类型是受限的，合法的类型包括（原始数据类型(*)，Sting(*)，Class，Annotation，Enumeration）,以及前面这些类型的数组类型</li>
<li>如果注解只有一个成员，则成员名必须取名value()，在使用时可以忽略成员名和赋值号“=”</li>
<li>注解类可以没有成员，没有成员的注解成为<strong>标识注解</strong></li>
</ul>
<p><strong>使用自定义注解</strong></p>
<blockquote>
<p>@\&lt;注解名>(\&lt;成员名1>=\&lt;成员值1>, \&lt;成员名2>=\&lt;成员值2>, …)</p>
</blockquote>
<pre><code>@Decription(desc=&quot;I am eyeColor&quot;, author=&quot;Mooc boy&quot;, age=18)
public String eyeColor() {
   return &quot;red&quot;;
}
</code></pre><blockquote>
<p>当注解只有一个成员时的定义，成员名必须取名value()，在使用时可以忽略成员名和赋值号“=”。</p>
</blockquote>
<pre><code>@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Description {
    String value();
}
</code></pre><p><strong>使用方式</strong></p>
<pre><code>@Decription(&quot;I am eyeColor&quot;)
public String eyeColor() {
   return &quot;red&quot;;
}
</code></pre><p><strong>标识注解</strong></p>
<pre><code>@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Description {
}
</code></pre><p><strong>使用方式</strong></p>
<pre><code>@Decription
public String eyeColor() {
   return &quot;red&quot;;
}
</code></pre><h4 id="来自第三方框架的注解（-）"><a href="#来自第三方框架的注解（-）" class="headerlink" title="来自第三方框架的注解（*）"></a>来自第三方框架的注解（*）</h4><p><strong>Spring</strong></p>
<ul>
<li>@Autowired</li>
<li>@Service</li>
<li>@Repository</li>
</ul>
<p><strong>MyBatis</strong></p>
<ul>
<li>@InsertProvider</li>
<li>@UpdateProvider</li>
<li>@Options</li>
</ul>
<blockquote>
<p>后续再学习Spring和Mybatis框架时在给予解释</p>
</blockquote>
<h3 id="自定义注解解析"><a href="#自定义注解解析" class="headerlink" title="自定义注解解析"></a>自定义注解解析</h3><blockquote>
<p>通过反射技术来解析自定义注解，获取类，函数或成员上的<strong>运行时注解</strong>信息, 从而实现<strong>动态控制</strong>程序运行的逻辑。关于反射类位于包java.lang.reflect，其中有一个接口AnnotatedElement，该接口定义了注释相关的几个核心方法，如下：</p>
</blockquote>
<ul>
<li>T  getAnnotation(Class annotationClass);</li>
</ul>
<blockquote>
<p>当存在该元素的指定类型注解，则返回相应注解，否则返回null</p>
</blockquote>
<ul>
<li>Annotation[]  getAnnotations();</li>
</ul>
<blockquote>
<p>返回此元素上存在的所有注解</p>
</blockquote>
<ul>
<li>Annotation []  getDeclaredAnnotations();</li>
</ul>
<blockquote>
<p>返回直接存在于此元素上的所有注解</p>
</blockquote>
<ul>
<li>boolean  isAnnotationPresent(Class\&lt;? extends Annotation> annotationClass);</li>
</ul>
<blockquote>
<p>当存在该元素的指定类型注解，则返回true，否则返回false</p>
</blockquote>
<pre><code>public class ParseAnnotation {
    public static void main(String[] args) {
        // 1. 使用类加载器加载类
        try {
            Class c = Class.forName(&quot;com.sh2zqp.Man&quot;);
            // 2. 找到类上面的注解
            boolean isCExist =
                    c.isAnnotationPresent(Description.class);// 判断是否存在Description这个注解
            if (isCExist) {
                // 3. 拿到Description注解实例
                Description descriptionAnno = (Description) c.getAnnotation(Description.class);
                System.out.println(descriptionAnno.desc());

                // 4. 解析找到方法上的Description注解
                Method[] declaredMethods = c.getDeclaredMethods();
                for (Method m : declaredMethods) {
                    boolean isMExist = m.isAnnotationPresent(Description.class);
                    if (isMExist) {
                        Description description = m.getAnnotation(Description.class);
                        System.out.println(description.desc());
                    }
                }

                // 另一种解析方法
                for (Method m : declaredMethods) {
                    Annotation[] annotations = m.getAnnotations();
                    for (Annotation a : annotations) {
                        if (a instanceof Description) {
                            System.out.println(((Description) a).desc());
                        }
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h3 id="注解的实战"><a href="#注解的实战" class="headerlink" title="注解的实战"></a>注解的实战</h3><h4 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h4><blockquote>
<p>项目取自一个公司的持久层框架，用来替代Hibernate的解决方案，核心代码就是通过注解来实现的。</p>
</blockquote>
<h4 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h4><ul>
<li>有一张用户表，字段有用户ID，用户名，昵称，年龄，性别，所在城市，邮箱，手机号；</li>
<li>方便对每个字段或字段的组合条件进行检索，并打印出SQL语句；</li>
<li>使用方式足够简单。</li>
</ul>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p><strong><a href="https://github.com/sh2zqp/AnnotationTest" target="_blank" rel="external">代码</a></strong></p>
<p><strong>参考资料</strong></p>
<p><a href="http://www.imooc.com/learn/456" target="_blank" rel="external">全面解析Java注解</a><br><a href="http://gityuan.com/2016/01/23/java-annotation/" target="_blank" rel="external">Java注解(Annotation)</a><br><a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="external">关于注解、反射的内容，可直接查看oracle提供的Java API</a><br><a href="http://www.jianshu.com/p/a08e7e9ed765" target="_blank" rel="external">Java自定义注解</a><br><a href="http://www.importnew.com/10294.html" target="_blank" rel="external">Java中的注解是如何工作的？</a><br><a href="https://zh.wikipedia.org/wiki/Java%E6%B3%A8%E8%A7%A3" target="_blank" rel="external">Java注解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;h4 id=&quot;注解定义&quot;&gt;&lt;a href=&quot;#注解定义&quot; class=&quot;headerlink&quot; title=&quot;注解定义&quot;&gt;&lt;/a&gt;注解定义&lt;/h
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="注解" scheme="http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="http://yoursite.com/2017/04/27/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/04/27/Java反射机制/</id>
    <published>2017-04-27T08:47:05.000Z</published>
    <updated>2017-04-28T09:11:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>通俗地说,反射机制就是可以把一个类,类的成员(函数,属性),当成一个对象来操作,希望读者能理解,也就是说,类,类的成员,我们在运行的时候还可以<strong>动态地去操作</strong>它们.</p>
</blockquote>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><blockquote>
<p>在面向对象对象的世界中，万事万物皆是对象。Java语言中，静态的成员和普通数据类型不是对象(有其相应的包装类)。</p>
<p>万事万物都可以抽象成<strong>类</strong>，而这些类也是_java.lang.Class_的实例对象。</p>
</blockquote>
<p><strong>测试类</strong></p>
<pre><code>public class ClassTest {
    public static void main(String[] args) {
        // Student类的实例对象
        Student student = new Student(); // student就表示了Student类的实例对象

        /*
         * Student这个类本身也是一个实例对象，是Class类的实例对象
         * 但是不能new出来(私有的无参构造器)，只有Java的虚拟机能创建Class类的实例对象
         */

        // 任意一个类都是Class类的实例对象，其表示(获得)方式有如下三种

        // 1 (任何一个类都有一个隐含的静态成员变量class)
        Class s1 = Student.class;
        // 2 (已知该类的实例对象，通过getClass()方法)
        Class s2 = student.getClass();
        // 3 (Class.forName(&quot;com.sh2zqp.Student&quot;))
        Class s3 = null;
        try {
            s3 = Class.forName(&quot;com.sh2zqp.Student&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

        // s1,s2,s3都表示了Student类的类类型(class type)，也就是Class类的实例对象
        // 它们三者是等价的，一个类只可能有Class类的一种实例对象
        System.out.println(s1);
        System.out.println(s2);
        System.out.println(s3);
        System.out.println(s1 == s2); // true
        System.out.println(s2 == s3); // true

        // 我们可以通过Student类的类类型 s1 or s2 or s3 来创建Student类的实例对象
        try {
            Student s = (Student) s1.newInstance(); // Student需要有无参的构造器
            //Student s = (Student) s2.newInstance();
            //Student s = (Student) s3.newInstance();
            s.play();
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}
</code></pre><p><strong>Student</strong></p>
<pre><code>public class Student {

    private int id;
    private String name;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void play() {
        System.out.println(&quot;play......&quot;);
    }
}
</code></pre><h3 id="Java动态加载类"><a href="#Java动态加载类" class="headerlink" title="Java动态加载类"></a>Java动态加载类</h3><p><strong>Class.forName(“类的全路径”)</strong></p>
<blockquote>
<p>上面的式子不仅可以获得类的类类型，还代表了一种类的加载技术，既是动态加载类。</p>
<p><strong>编译</strong>：把.java文件变成.class文件<br><strong>运行</strong>：由java虚拟机来运行.class文件</p>
</blockquote>
<p><strong>编译时加载的类就是静态加载类</strong><br><strong>运行时加载的类就是动态加载类</strong></p>
<blockquote>
<p>不适用IDE，而使用命令行来编译，运行程序</p>
</blockquote>
<p><strong>javac 编译</strong><br><strong>java 运行</strong></p>
<pre><code>class Office {
    public static void main(String[] args) {
        if (&quot;Word&quot;.equals(args[0])) {
            Word word = new Word();
            word.start();
        }
        if (&quot;Excel&quot;.equals(args[0])) {
            Excel excel = new Excel();
            excel.start();
        }
    }       
}
</code></pre><blockquote>
<p>此时编译此文件</p>
</blockquote>
<pre><code>javac Office.java
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/Reflect01.png" alt=""></p>
<blockquote>
<p>Word和Excel类找不到</p>
<p>新建一个Word类</p>
</blockquote>
<pre><code>class Word {
    public void start() {
        System.out.println(&quot;word...start...&quot;);
    }
}

javac Word.java
</code></pre><blockquote>
<p>编译得到Word.class文件，再次编译Office.java</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/Reflect02.png" alt=""></p>
<blockquote>
<p>和Word相关的报错消失</p>
</blockquote>
<p><strong>new创建对象 是静态加载类，在编译时就需要使用可能需要的类，如果我们目前只有Word类，而没有Excel类，就会一直无法使用该程序，所以我们可以通过动态加载类解决上面问题。</strong></p>
<pre><code>public class Office {
    public static void main(String[] args) {
        try {
        // 动态加载类，在运行时加载
            Class c = Class.forName(args[0]);
            // 通过类类型创建类的实例对象
            OfficeAble office = (OfficeAble) c.newInstance();
            office.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

public interface OfficeAble {
    public void start();
}

public class Word implements OfficeAble {
    @Override
    public void start() {
        System.out.println(&quot;Word...Start...&quot;);
    }
}
</code></pre><blockquote>
<p>动态加载运行，各种功能模块互不影响，对以后想添加功能也比较方便。</p>
</blockquote>
<h3 id="基本数据类型以及一些特殊的类类型"><a href="#基本数据类型以及一些特殊的类类型" class="headerlink" title="基本数据类型以及一些特殊的类类型"></a>基本数据类型以及一些特殊的类类型</h3><pre><code>public class BaseDataTypeClassTest {
    public static void main(String[] args) {
        Class c1 = int.class; // int的类类型（int类的字节码）
        Class c2 = float.class;
        Class c3 = Double.class;
        Class c4 = String.class;
        Class c5 = void.class;

        System.out.println(c1);
        System.out.println(c2);
        System.out.println(c3);
        System.out.println(c4);
        System.out.println(c5);

        System.out.println(c1.getName());
        System.out.println(c1.getSimpleName());
        System.out.println(c3.getName());
        System.out.println(c3.getSimpleName());
        System.out.println(c5.getName());
        System.out.println(c5.getSimpleName());
    }
}
</code></pre><blockquote>
<p>运行结果</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/Reflect03.png" alt=""></p>
<h3 id="Class类的基本API"><a href="#Class类的基本API" class="headerlink" title="Class类的基本API"></a>Class类的基本API</h3><p><strong>Method相关</strong></p>
<pre><code>/**
   * Method类，方法的对象
   * 一个成员方法就是一个Method的实例对象
   * c.getMethods()获取所有的public修饰的函数，包括父类继承来的方法
   * c.getDeclaredMethods()获取所有该类自己声明的方法，不考虑访问权限
   */
  Method[] methods = c.getMethods();
  //Method[] declaredMethods = c.getDeclaredMethods();

  for (Method m : methods) {
      // 方法的返回值类型
      Class returnValueType = m.getReturnType();
      System.out.print(returnValueType.getSimpleName() + &quot; &quot;);
      // 方法名
      System.out.print(m.getName());
      // 方法的参数类型
      Class[] parameterTypes = m.getParameterTypes();
      System.out.print(&quot;(&quot;);
      for (Class cl : parameterTypes) {

      }
      for (int i = 0; i &lt; parameterTypes.length; i++) {
          if (i != (parameterTypes.length-1) ) {
              System.out.print(parameterTypes[i].getSimpleName() + &quot;,&quot;);
          } else {
              System.out.print(parameterTypes[i].getSimpleName());
          }
      }
      System.out.println(&quot;)&quot;);
  }
</code></pre><p><strong>Field相关</strong></p>
<pre><code>// 要获取object对象类的信息，先获取object对象的所属类的类类型
        Class c = object.getClass(); // 2
        /**
         * Field类，成员变量也是对象
         * 一个成员变量就是一个Field的实例对象
         * c.getFields()获取所有的public修饰的成员变量，包括父类继承来的成员变量
         * c.getDeclaredFields()获取所有该类自己声明的成员变量，不考虑访问权限
         */
        Field[] fields = c.getFields();
        Field[] declaredFields = c.getDeclaredFields();
        for (Field f : declaredFields) {
            // 得到成员变量类的类类型的名称
            Class fieldClassType = f.getType();
            System.out.print(fieldClassType.getSimpleName() + &quot; &quot;);
            // 得到成员变量的名称
            System.out.println(f.getName());
        }
</code></pre><p><strong>构造函数相关</strong></p>
<pre><code>// 要获取object对象类的信息，先获取object对象的所属类的类类型
        Class c = object.getClass(); // 2
        /**
         * Constructor类，构造函数也是对象
         * 一个构造函数就是一个Constructor的实例对象
         * c.getConstructors()获取所有的public修饰的构造函数
         * c.getDeclaredFields()获取所有该类的构造函数
         */
        //Constructor[] constructors = c.getConstructors();
        Constructor[] declaredConstructors = c.getDeclaredConstructors();
        for (Constructor constructor : declaredConstructors) {
            // 方法名
            System.out.print(constructor.getName());
            // 方法的参数类型
            Class[] parameterTypes = constructor.getParameterTypes();
            System.out.print(&quot;(&quot;);
            for (int i = 0; i &lt; parameterTypes.length; i++) {
                if (i != (parameterTypes.length-1) ) {
                    System.out.print(parameterTypes[i].getSimpleName() + &quot;,&quot;);
                } else {
                    System.out.print(parameterTypes[i].getSimpleName());
                }
            }
            System.out.println(&quot;)&quot;);
        }
</code></pre><p><strong>其他等等，只要获得该类的类类型即可获得全面的类信息</strong></p>
<h3 id="Class中方法的反射操作"><a href="#Class中方法的反射操作" class="headerlink" title="Class中方法的反射操作"></a>Class中方法的反射操作</h3><ul>
<li>如何获取某个方法(方法的名称和方法的参数列表才能唯一的决定某个方法)</li>
<li><p>方法的反射操作</p>
<p>  method.invoke(对象,参数列表)</p>
<p>  public class MethodInvokeTest {</p>
<pre><code>public static void main(String[] args) {
    Student student = new Student();
    // 获取Student类的print(int , int)方法
    // 1. 要获取一个类的方法，就是获取该类的类信息
    Class c = student.getClass();
    // 2. 获取方法的名称和参数列表来决定该方法是否是我们需要的
    try {
        // 获得public方法
        Method cMethod = c.getMethod(&quot;print&quot;, new Class[] {int.class, int.class});
        //Method cMethod = c.getMethod(&quot;print&quot;, int.class, int.class);
        // 获得自己声明的任意方法(不考虑权限)
        //Method cDeclaredMethod = c.getDeclaredMethod();

        // 方法的反射操作
        student.print(11,22); // student对象操作方法print
        // 方法有返回值返回具体的返回值，无返回值则返回null
        Object o = cMethod.invoke(student, 11, 22); // print方法对象cMethod操作对象student
        //Object o = cMethod.invoke(student, new Object[] {11, 22});
        System.out.println(o); // null

        System.out.println(&quot;=====================&quot;);
        Method cMethod1 = c.getMethod(&quot;print&quot;, String.class, String.class);
        cMethod1.invoke(student, &quot;a&quot;, &quot;b&quot;);

        System.out.println(&quot;=====================&quot;);
        //Method cMethod2 = c.getMethod(&quot;print&quot;);
        Method cMethod2 = c.getMethod(&quot;print&quot;, new Class[] {});
        //cMethod2.invoke(student);
        cMethod2.invoke(student, new Object[] {});

        /**
         * 用Java反射机制来调用private方法
         *
         * AccessibleObject类是Field、Method、和Constructor对象的基类。
         * 它提供了将反射的对象标记为在使用时取消默认Java语言访问控制检查的能力。
         * 对于公共成员、默认(打包)访问成员、受保护成员和私有成员，在分别使用
         * Field、Method和Constructor对象来设置或获得字段、调用方法，
         * 或者创建和初始化类的新实例的时候，会执行访问检查。
         * 当反射对象的accessible标志设为true时，则表示反射的对象在使用时应该取消Java语言访问检查。
         * 反之则检查。由于JDK的安全检查耗时较多，所以通过setAccessible(true)的方式关闭安全检查来提升反射速度。
         */
        System.out.println(&quot;=====================&quot;);
        // //getDeclaredMethod可以获取到所有方法，而getMethod只能获取public
        Method cMethodPrivate = c.getDeclaredMethod(&quot;privateMethod&quot;, new Class[] {});
        cMethodPrivate.setAccessible(true);// //压制Java对访问修饰符的检查
        cMethodPrivate.invoke(student, new Object[] {});

    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><p>  }</p>
</li>
</ul>
<h3 id="反射在集合泛型中的应用（本质）"><a href="#反射在集合泛型中的应用（本质）" class="headerlink" title="反射在集合泛型中的应用（本质）"></a>反射在集合泛型中的应用（本质）</h3><p><strong>通过Class，Method来认识泛型的本质，什么是泛型(防止输入错误的数据类型)，泛型什么时候有效</strong></p>
<pre><code>public class GenericClassTest {
    public static void main(String[] args) {
        ArrayList list1 = new ArrayList();
        ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();

        list2.add(&quot;aaaa&quot;);
        // list2.add(20); // 错误

        Class c1 = list1.getClass();
        Class c2 = list2.getClass();
        System.out.println(c1);
        System.out.println(c2);
        System.out.println(c1 == c2); // true

        // 反射的操作都是编译后的操作，即变成字节码之后的操作（运行时）
        // c1==c2说明编译之后的集合是去泛型化的
        // Java中的泛型是防止错误输入的，只在编译阶段有效，绕过编译就无效了
        // 验证：通过方法的反射来操作，绕过编译
        try {
            Method c2Method = c2.getMethod(&quot;add&quot;, Object.class);
            c2Method.invoke(list2, 100);
            System.out.println(list2.size());
            System.out.println(list2); // [aaaa, 100],此时不能再用for循环遍历，会有类型转换错误
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p><strong>反射的应用场景</strong></p>
<ul>
<li>工厂模式：Factory类中用反射的话，添加了一个新的类之后，就不需要再修改工厂类Factory了</li>
<li>数据库JDBC中通过Class.forName(Driver).来获得数据库连接驱动</li>
<li>分析类文件：毕竟能得到类中的方法等等</li>
<li>访问一些不能访问的变量或属性：破解别人代码</li>
</ul>
<p><strong>参考资料</strong></p>
<p><a href="http://www.imooc.com/learn/199" target="_blank" rel="external">反射——Java高级开发必须懂的</a><br><a href="http://www.cnblogs.com/rollenholt/archive/2011/09/02/2163758.html" target="_blank" rel="external">java反射详解</a><br><a href="http://blog.csdn.net/ljphhj/article/details/12858767" target="_blank" rel="external">一个例子让你了解Java反射机制</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通俗地说,反射机制就是可以把一个类,类的成员(函数,属性),当成一个对象来操作,希望读者能理解,也就是说,类,类的成员,我们在运行的时候还可以&lt;strong&gt;动态地去操作&lt;/strong&gt;它们.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="反射机制" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>JUnit测试 By Intellij IDEA15(2016.3)</title>
    <link href="http://yoursite.com/2017/04/27/JUnit%E6%B5%8B%E8%AF%95%20By%20Intellij%20IDEA15(2016.3)/"/>
    <id>http://yoursite.com/2017/04/27/JUnit测试 By Intellij IDEA15(2016.3)/</id>
    <published>2017-04-27T01:40:26.000Z</published>
    <updated>2017-04-27T08:36:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JUnit单元测试的基本使用"><a href="#JUnit单元测试的基本使用" class="headerlink" title="JUnit单元测试的基本使用"></a>JUnit单元测试的基本使用</h2><blockquote>
<p>我们使用Intellij IDEA15来完成日常开发工作，使用JUnit来进行单元测试的工作，对我们所写的代码进行正确性的测试，并为后期的项目维护做好准备，以及提升代码的质量和出错率，Debug的过程一定是痛苦的。</p>
<p>本文中我们所使用的是<a href="http://junit.org/junit4/" target="_blank" rel="external">JUnit4</a>版本，不过目前<a href="http://junit.org/junit5/" target="_blank" rel="external">JUnit5</a>也已经出来了。</p>
</blockquote>
<h3 id="环境搭建以及前期准备"><a href="#环境搭建以及前期准备" class="headerlink" title="环境搭建以及前期准备"></a>环境搭建以及前期准备</h3><ul>
<li>首先，在一个新建的项目中，在项目根目录下新建一个测试文件夹，此处为了易于辨识，我们取做“tests”；</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit01.png" alt=""><br><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit02.png" alt=""><br><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit03.png" alt=""></p>
<ul>
<li>然后，“Command+；”进入到项目结构，选择Modules子选项并把tests文件夹添加为测试目录，此时文件夹的颜色由灰色变为蓝色，点击ok确认即可；</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit04.png" alt=""><br><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit05.png" alt=""></p>
<ul>
<li><p>最后，我们在src目录下的com.sh2zqp.bean包下新建一个类Person，类里面添加一个name属性和一个getName()和一个setName()方法。</p>
<p>  public class Person {</p>
<pre><code>private String name;
public Person(String name) {
    this.name = name;
}
public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}
}
</code></pre></li>
</ul>
<p><strong>注意</strong></p>
<blockquote>
<p>之所以把测试代码和源代码分开是因为一般测试代码是不会公开的，只是我们开发人员自己使用，把它们单独放在tests目录下更易于实现这样的管理。</p>
</blockquote>
<h3 id="生成测试类PersonTest"><a href="#生成测试类PersonTest" class="headerlink" title="生成测试类PersonTest"></a>生成测试类PersonTest</h3><ul>
<li>首先把鼠标定位到Person类上，快捷键Alt(option)+Enter(return)，选择Create Tests选项；</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit06.png" alt=""><br><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit07.png" alt=""></p>
<ul>
<li>然后，进入Create Tests设置页面，选择Testing Libary为JUnit4，我们发现里面有不少的测试库可以使用；</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit08.png" alt=""></p>
<ul>
<li>但是，我们发现JUnit4库并没有被引入项目Module中，此时我们点击fix，选择第一项；，点击ok；</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit09.png" alt=""></p>
<ul>
<li>最后，我们选择Person类中的getName()方法进行测试，点击ok即可，之后我们发现项目的结构如下。</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit10.png" alt=""><br><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit11.png" alt=""></p>
<blockquote>
<p>可以发现测试类PersonTest中的有一个getName的测试方法，方法上面有一个@Test注解</p>
</blockquote>
<h3 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h3><pre><code>@Test
public void getName() throws Exception {
    Person person = new Person(&quot;sh2zqp&quot;);
    assertEquals(&quot;sh2zqp&quot;, person.getName());
}
</code></pre><p><strong>代码说明</strong></p>
<ul>
<li>测试方法上面必须使用<strong>@Test</strong>注解进行修饰;</li>
<li>测试方法必须使用<strong>public void</strong> 进行修饰，<strong>不能带有任何参数</strong>;</li>
<li>测试方法必须抛出throws Exception异常;</li>
<li>新建一个源代码目录<strong>tests</strong>用来存放测试代码;</li>
<li>测试类的包应该与被测试类的<strong>包保持一致</strong>;</li>
<li>测试单元中的每一个方法必须<strong>独立测试</strong>，每个测试方法之间不能有依赖;</li>
<li>测试类使用Test做为类名的后缀（非必要）;</li>
<li>测试方法使用test作为方法名的前缀（非必要）;</li>
</ul>
<h3 id="运行测试代码"><a href="#运行测试代码" class="headerlink" title="运行测试代码"></a>运行测试代码</h3><p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit12.png" alt=""><br><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit13.png" alt=""><br><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit14.png" alt=""></p>
<blockquote>
<p>我们也可以把鼠标方法测试类PersonTest或测试方法getName()上，通过快捷键Alt+Enter来完成测试运行。</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit17.png" alt=""><br><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit16.png" alt=""></p>
<blockquote>
<p>测试结果如下：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit15.png" alt=""></p>
<blockquote>
<p>此外，我们通过在页面任意空白处使用Command+N添加新的测试方法，如下：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit18.png" alt=""><br><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit19.png" alt=""></p>
<h3 id="测试错误示范"><a href="#测试错误示范" class="headerlink" title="测试错误示范"></a>测试错误示范</h3><blockquote>
<p>我们为setName()方法添加了测试方法</p>
</blockquote>
<pre><code>@Test
public void setName() throws Exception {
    Person person = new Person(&quot;sh2zqp&quot;);
    person.setName(&quot;sh2zqp1&quot;);
    assertEquals(&quot;sh2zqp&quot;, person.getName());
}
</code></pre><blockquote>
<p>很明显assertEquals(“sh2zqp”, person.getName())中“sh2zqp”并不是person.getName()所期望的值，因为我们已经通过setName()方法更改为“sh2zqp1”。</p>
<p>另外，setName和getName方法混合使用，说明此处的setName已经不是独立的测试单元。</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit20.png" alt=""></p>
<p><strong>注意</strong></p>
<ul>
<li>Failure 一般是单元测试使用的断言方法判断失败引起，说明预期结果和程序运行结果不一致;</li>
<li>error 是有代码异常引起的，他产生于测试代码本身中的Bug;</li>
<li>测试用例不是用来证明你是对的，而是用来证明你没有错;</li>
</ul>
<h2 id="JUnit单元测试的深入学习"><a href="#JUnit单元测试的深入学习" class="headerlink" title="JUnit单元测试的深入学习"></a>JUnit单元测试的深入学习</h2><blockquote>
<p>上一部分我们简单的使用了JUnit进行了单元测试，本部分我们进一步来学习。</p>
</blockquote>
<h3 id="JUnit测试流程"><a href="#JUnit测试流程" class="headerlink" title="JUnit测试流程"></a>JUnit测试流程</h3><blockquote>
<p>在PersonTest测试类中加入如下代码：</p>
</blockquote>
<pre><code>@BeforeClass
public static void setUpBeforeClass() throws Exception {
    System.out.println(&quot;BeforeClass&quot;);
}
@AfterClass
public static void setUpAfterClass() throws Exception {
    System.out.println(&quot;AfterClass&quot;);
}
@Before
public void setUp() throws Exception {
    System.out.println(&quot;Before&quot;);
}
@After
public void tearDown() throws Exception {
    System.out.println(&quot;After&quot;);
}

@Test
public void getName() throws Exception {
    System.out.println(&quot;test getName()&quot;);
    Person person = new Person(&quot;sh2zqp1&quot;);
    assertEquals(&quot;sh2zqp1&quot;, person.getName());
}
@Test
public void setName() throws Exception {
    System.out.println(&quot;test setName()&quot;);
    Person person = new Person(&quot;sh2zqp&quot;);
    person.setName(&quot;sh2zqp1&quot;);
    assertEquals(&quot;sh2zqp1&quot;, person.getName());
}
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit21.png" alt=""></p>
<blockquote>
<p>这里我们学习四个新的注解@BeforeClass，@AfterClass，@Before，@After，下面对这几个注解做出说明：</p>
</blockquote>
<ul>
<li><strong>@BeforeClass</strong>:所修饰的方法在所有方法加载前执行，而且他是静态的在类加载后就会执行该方法，在内存中只有一份实例，适合用来加载配置文件;</li>
<li><strong>@AfterClass</strong>:所修饰的方法在所有方法执行完毕之后执行，通常用来进行资源清理，例如关闭数据库连接;</li>
<li><strong>@Before</strong>和<strong>@After</strong>在每个测试方法执行前都会执行一次。</li>
</ul>
<h3 id="JUnit常用注解"><a href="#JUnit常用注解" class="headerlink" title="JUnit常用注解"></a>JUnit常用注解</h3><ul>
<li><strong>@Test</strong>：将一个普通的方法修饰成为一个测试方法<ul>
<li>@Test(exception=xxx.class)在运行时忽略某个异常</li>
<li>@Test(timeout=毫秒数)允许程序运行的时间</li>
</ul>
</li>
</ul>
<blockquote>
<p>@Test可以附带参数，首先在Person类中新增一个divideByPerson()方法，然后在PersonTest类中新增测试方法，具体如下：</p>
</blockquote>
<pre><code>public int divideByPerson(int a, int b) {
        return a/b;
}
    @Test
    public void divideByPerson() throws Exception {
        assertEquals(6, person.divideByPerson(6,0));
    }
</code></pre><blockquote>
<p>测试结果如下：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit22.png" alt=""></p>
<blockquote>
<p>可以看到ArithmeticException算数错误，报了使用<strong>@Test(exception=xxx.class)</strong>，代码如下：</p>
</blockquote>
<pre><code>@Test(expected = ArithmeticException.class)
public void divideByPerson() throws Exception {
    assertEquals(6, person.divideByPerson(6,0));
}
</code></pre><blockquote>
<p>运行结果如下：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit23.png" alt=""></p>
<blockquote>
<p>@Test另外还有一个参数<strong>@Test(timeout=毫秒数)</strong>,其目的给出一个程序运行的最大时间，时间到了会自动停止，一般用于循环执行的代码块，避免出现死循环。</p>
</blockquote>
<ul>
<li><p><strong>@BeforeClass</strong>，<strong>@AfterClass</strong>，<strong>@Before</strong>，<strong>@After</strong>（参见上面的解释）</p>
</li>
<li><p><strong>@Ignore</strong>:所修饰的方法会被测试器忽略，里面可以附加一些提示信息<strong>@Ignore(“……”)</strong></p>
<pre><code>@Ignore(&quot;ignore&quot;)
@Test
public void getName() throws Exception {
    System.out.println(&quot;test getName()&quot;);
    assertEquals(&quot;sh2zqp&quot;, person.getName());
}
</code></pre></li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit25.png" alt=""></p>
<ul>
<li><strong>@RunWith</strong>:更改测试运行器，自定义测试器，需要继承org.junit.runner.Runner，大多数情况下使用默认的测试运行器即可。</li>
<li>assert断言的使用</li>
</ul>
<blockquote>
<p>静态导入<br>    import static org.junit.Assert</p>
</blockquote>
<h3 id="JUnit测试套件的使用"><a href="#JUnit测试套件的使用" class="headerlink" title="JUnit测试套件的使用"></a>JUnit测试套件的使用</h3><blockquote>
<p>测试套件是组织测试类一起运行的<strong>测试类</strong>，是随着项目规模的变大的一种简易测试方法，可以批量运行测试类，把这些测试类集中到一个测试套件中即可。</p>
<p>我们新建的一个测试套件类SuiteTest和三个测试类Test1，Test2，Test3，如下：</p>
</blockquote>
<pre><code>public class Test1 {
    @Test
    public void test() throws Exception {
        System.out.println(&quot;test1......&quot;);
    }
}
public class Test2 {
    @Test
    public void test() throws Exception {
        System.out.println(&quot;test2......&quot;);
    }
}
public class Test3 {
    @Test
    public void test() throws Exception {
        System.out.println(&quot;test3......&quot;);
    }
}

@RunWith(Suite.class)
@Suite.SuiteClasses({Test1.class, Test2.class, Test3.class})
public class SuiteTest {
}
</code></pre><blockquote>
<p>运行结果</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit24.png" alt=""></p>
<p><strong>说明</strong></p>
<ul>
<li>作为测试套件的入口类，类中不能包含任何方法，并用public修饰;</li>
<li>更改测试运行器Suite.class（<strong>@RunWith(Suite.class)</strong>）;</li>
<li>将需要运行的测试类放入<strong>Suite.SuiteClasses({})</strong>的数组中，当然里面也可以放测试套件类。</li>
</ul>
<h3 id="JUnit参数化设置"><a href="#JUnit参数化设置" class="headerlink" title="JUnit参数化设置"></a>JUnit参数化设置</h3><blockquote>
<p>需要测试的仅仅是测试数据，代码结构是不变的，只需要更改测试数据。</p>
</blockquote>
<pre><code>@RunWith(Parameterized.class)
public class ParameterTest {

    String expected = &quot;&quot;;
    String input = &quot;&quot;;

    @Parameterized.Parameters
    public static Collection&lt;Object[]&gt; t() {
        return Arrays.asList(new Object[][] {
                {&quot;sh2zqp1&quot;,&quot;sh2zqp1&quot;},
                {&quot;sh2zqp2&quot;,&quot;sh2zqp2&quot;}
        });
    }

    public ParameterTest(String expected, String input) {
        this.expected = expected;
        this.input = input;

    }

    @Test
    public void testGetName() throws Exception {
        Person person = new Person(input);
        assertEquals(expected, person.getName());
    }
}
</code></pre><p><strong>具体步骤</strong></p>
<ul>
<li>更改默认的测试运行器为@RunWith(Parameterized.class);</li>
<li>声明变量来存放预期值和测试值;</li>
<li>声明一个返回值为Collection的公共静态方法，并用@Parameters修饰;</li>
<li>为测试类声明一个带有参数的公共构造函数，并在其中为他声明变量赋值。</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/JUnit26.png" alt=""></p>
<h2 id="JUnit4在Web项目中的使用"><a href="#JUnit4在Web项目中的使用" class="headerlink" title="JUnit4在Web项目中的使用"></a>JUnit4在Web项目中的使用</h2><p><strong>后期添加</strong></p>
<p><strong>参考资料</strong></p>
<p><a href="https://www.youtube.com/watch?v=Bld3644bIAo&amp;t=450s" target="_blank" rel="external">JUnit 4 with IntelliJ: A quick introduction</a><br><a href="http://www.cnblogs.com/huaxingtianxia/p/5563111.html" target="_blank" rel="external">JUnit单元测试–IntelliJ IDEA</a><br><a href="http://www.imooc.com/learn/356" target="_blank" rel="external">JUnit—Java单元测试必备工具</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JUnit单元测试的基本使用&quot;&gt;&lt;a href=&quot;#JUnit单元测试的基本使用&quot; class=&quot;headerlink&quot; title=&quot;JUnit单元测试的基本使用&quot;&gt;&lt;/a&gt;JUnit单元测试的基本使用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们使用Intel
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="JUnit4" scheme="http://yoursite.com/tags/JUnit4/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="单元测试" scheme="http://yoursite.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Intellij IDEA15" scheme="http://yoursite.com/tags/Intellij-IDEA15/"/>
    
  </entry>
  
  <entry>
    <title>收集的学习网站</title>
    <link href="http://yoursite.com/2017/04/23/%E6%94%B6%E9%9B%86%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2017/04/23/收集的学习网站/</id>
    <published>2017-04-23T02:02:50.000Z</published>
    <updated>2017-04-23T02:33:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>不定时更新</strong></p>
<hr>
<ul>
<li>Google Developers: <a href="https://developers.google.cn" target="_blank" rel="external">https://developers.google.cn/</a><ul>
<li>Android官方培训课程中文版: <a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="external">http://hukai.me/android-training-course-in-chinese/index.html</a></li>
<li>掘金: <a href="https://gold.xitu.io/welcome" target="_blank" rel="external">https://gold.xitu.io/welcome</a></li>
<li>干货集中营: <a href="http://gank.io/" target="_blank" rel="external">http://gank.io/</a></li>
<li>itscoder: <a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>泡在网上的日子: <a href="http://www.jcodecraeer.com/" target="_blank" rel="external">http://www.jcodecraeer.com/</a></li>
<li>开发者头条: <a href="https://toutiao.io/" target="_blank" rel="external">https://toutiao.io/</a></li>
<li>开源中国社区: <a href="http://www.oschina.net/android" target="_blank" rel="external">http://www.oschina.net/android</a></li>
<li>简书: <a href="http://www.jianshu.com/" target="_blank" rel="external">http://www.jianshu.com/</a></li>
<li>技术小黑屋: <a href="http://droidyue.com/" target="_blank" rel="external">http://droidyue.com/</a></li>
<li>AndroidDevTools: <a href="http://www.androiddevtools.cn/" target="_blank" rel="external">http://www.androiddevtools.cn/</a></li>
<li>红黑联盟: <a href="http://www.2cto.com/kf/yidong/Android/news/" target="_blank" rel="external">http://www.2cto.com/kf/yidong/Android/news/</a></li>
<li>极客导航: <a href="http://www.jikedaohang.com/" target="_blank" rel="external">http://www.jikedaohang.com/</a></li>
<li>有赞技术博客: <a href="http://tech.youzan.com/" target="_blank" rel="external">http://tech.youzan.com/</a></li>
<li>codeKK: <a href="http://p.codekk.com/" target="_blank" rel="external">http://p.codekk.com/</a></li>
<li>慕课网: <a href="http://www.imooc.com/" target="_blank" rel="external">http://www.imooc.com/</a></li>
</ul>
</li>
<li>YouMeek: <a href="http://www.youmeek.com/" target="_blank" rel="external">http://www.imooc.com/</a><ul>
<li>极客学院: <a href="http://www.jikexueyuan.com/" target="_blank" rel="external">http://www.jikexueyuan.com/</a></li>
<li>java&amp;android学习网: <a href="http://www.javaand.com/index.html" target="_blank" rel="external">http://www.javaand.com/index.html</a></li>
<li>廖雪峰: <a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">http://www.liaoxuefeng.com/</a></li>
<li>任玉刚: <a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="external">http://blog.csdn.net/singwhatiwanna</a></li>
<li>郭霖: <a href="http://blog.csdn.net/guolin%5C_blog" target="_blank" rel="external">http://blog.csdn.net/guolin_blog</a></li>
<li>徐宜生: <a href="http://blog.csdn.net/eclipsexys" target="_blank" rel="external">http://blog.csdn.net/eclipsexys</a></li>
<li>Drakeet: <a href="https://drakeet.me/" target="_blank" rel="external">https://drakeet.me/</a></li>
<li>stormzhang: <a href="http://stormzhang.com/" target="_blank" rel="external">http://stormzhang.com/</a></li>
<li>匠心写作: <a href="https://gank.io/post/published" target="_blank" rel="external">https://gank.io/post/published</a></li>
<li>吴小龙同学: <a href="http://wuxiaolong.me/" target="_blank" rel="external">http://wuxiaolong.me/</a></li>
<li>胡凯: <a href="http://hukai.me/" target="_blank" rel="external">http://hukai.me/</a></li>
<li>阮一峰: <a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="external">http://www.ruanyifeng.com/blog/</a></li>
<li>Trinea: <a href="http://www.trinea.cn/" target="_blank" rel="external">http://www.trinea.cn/</a></li>
<li>Hongyang: <a href="http://blog.csdn.net/lmj623565791" target="_blank" rel="external">http://blog.csdn.net/lmj623565791</a></li>
</ul>
</li>
<li>hujiaweibujidao: <a href="http://hujiaweibujidao.github.io/" target="_blank" rel="external">http://hujiaweibujidao.github.io/</a><ul>
<li>lypeer: <a href="http://blog.csdn.net/luoyanglizi" target="_blank" rel="external">http://blog.csdn.net/luoyanglizi</a></li>
<li>张涛-开源实验室: <a href="http://kymjs.com/" target="_blank" rel="external">http://kymjs.com/</a></li>
<li>有家客栈: <a href="http://blog.csdn.net/njcit" target="_blank" rel="external">http://blog.csdn.net/njcit</a></li>
<li>zjutkz’s blog: <a href="http://zjutkz.net/" target="_blank" rel="external">http://zjutkz.net/</a></li>
<li>孙群: <a href="http://blog.csdn.net/iispring" target="_blank" rel="external">http://blog.csdn.net/iispring</a></li>
<li>Gityuan: <a href="http://gityuan.com/" target="_blank" rel="external">http://gityuan.com/</a></li>
<li>写代码的猴子: <a href="http://jaeger.itscoder.com/" target="_blank" rel="external">http://jaeger.itscoder.com/</a></li>
<li>Chad.cym: <a href="http://blog.csdn.net/cym492224103" target="_blank" rel="external">http://blog.csdn.net/cym492224103</a></li>
<li>别志华: <a href="http://blog.csdn.net/biezhihua" target="_blank" rel="external">http://blog.csdn.net/biezhihua</a></li>
<li>云在千峰: <a href="http://blog.chengyunfeng.com/" target="_blank" rel="external">http://blog.chengyunfeng.com/</a></li>
<li>LengYue: <a href="https://www.apkdv.com/" target="_blank" rel="external">https://www.apkdv.com/</a></li>
<li>何以诚: <a href="http://blog.csdn.net/u013022222" target="_blank" rel="external">http://blog.csdn.net/u013022222</a></li>
<li>GcsSloop: <a href="http://www.gcssloop.com/" target="_blank" rel="external">http://www.gcssloop.com/</a></li>
<li>Tikitoo: <a href="http://tikitoo.github.io/" target="_blank" rel="external">http://tikitoo.github.io/</a></li>
</ul>
</li>
<li>yayun: <a href="http://blog.csdn.net/yayun0516" target="_blank" rel="external">http://blog.csdn.net/yayun0516</a><ul>
<li>聪聪的个人网站: <a href="https://lufficc.com/" target="_blank" rel="external">https://lufficc.com/</a></li>
<li>lightSky: <a href="http://www.lightskystreet.com/" target="_blank" rel="external">http://www.lightskystreet.com/</a></li>
<li>blankj: <a href="http://blankj.com/" target="_blank" rel="external">http://blankj.com/</a></li>
<li>杰风居: <a href="http://jayfeng.com/" target="_blank" rel="external">http://jayfeng.com/</a></li>
<li>一个本科小生的奋斗史: <a href="http://blog.csdn.net/jason0539" target="_blank" rel="external">http://blog.csdn.net/jason0539</a></li>
<li>JavAndroid: <a href="http://blog.csdn.net/yy1300326388" target="_blank" rel="external">http://blog.csdn.net/yy1300326388</a></li>
<li>Jude95: <a href="http://www.jianshu.com/users/d73c34b951ef/latest%5C_articles" target="_blank" rel="external">http://www.jianshu.com/users/d73c34b951ef/latest_articles</a></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;不定时更新&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Google Developers: &lt;a href=&quot;https://developers.google.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https:/
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="阅读" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>为什么chrome浏览器打不开localhost(提示无法显示此网页)录</title>
    <link href="http://yoursite.com/2017/04/18/%E4%B8%BA%E4%BB%80%E4%B9%88chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E4%B8%8D%E5%BC%80localhost(%E6%8F%90%E7%A4%BA%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E6%AD%A4%E7%BD%91%E9%A1%B5)/"/>
    <id>http://yoursite.com/2017/04/18/为什么chrome浏览器打不开localhost(提示无法显示此网页)/</id>
    <published>2017-04-18T12:13:46.000Z</published>
    <updated>2017-04-18T12:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一、网络设置的问题 这种原因比较多出现在需要手动指定IP、网关、DNS服务器联网方式下，及使用代理服务器上网的。仔细检查计算机的网络设置。 </p>
<p>二、DNS服务器的问题 当IE无法浏览网页时，可先尝试用IP地址来访问，如果可以访问，那么应该是DNS的问题，造成DNS的问题可能是连网时获取DNS出错或DNS服务器本身问题，这时你可以手动指定DNS服务（地址可以是你当地ISP提供的DNS服务器地址，也可以用其它地方可正常使用DNS服务器地址。）不同的ISP有不同的DNS地址。有时候则是路由器或网卡的问题，无法与ISP的DNS服务连接，这种情况的话，可把路由器关一会再开，或者重新设置路由器。 还有一种可能，是本地DNS缓存出现了问题。为了提高网站访问速度，系统会自动将已经访问过并获取IP地址的网站存入本地的DNS缓存里，一旦再对这个网站进行访问，则不再通过DNS服务器而直接从本地DNS缓存取出该网站的IP地址进行访问。所以，如果本地DNS缓存出现了问题，会导致网站无法访问。可以在“运行”中执行ipconfig /flushdns来重建本地DNS缓存。</p>
<p>三、IE浏览器本身的问题 当IE浏览器本身出现故障时，自然会影响到浏览了；或者IE被恶意修改破坏也会导致无法浏览网页。这时可以尝试用“黄山IE修复专家”来修复（建议到安全模式下修复），或者重新IE（如重装IE遇到无法重新的问题，可参考：附一解决无法重装IE） </p>
<p>四、网络防火墙的问题 如果网络防火墙设置不当，如安全等级过高、不小心把IE放进了阻止访问列表、错误的防火墙策略等，可尝试检查策略、降低防火墙安全等级或直接关掉试试是否恢复正常。 </p>
<p>五、网络协议和网卡驱动的问题 IE无法浏览，有可能是网络协议（特别是TCP/IP协议）或网卡驱动损坏导致，可尝试重新网卡驱动和网络协议。 </p>
<p>六、HOSTS文件的问题 HOSTS文件被修改，也会导致浏览的不正常，解决方法当然是清空HOSTS文件里的内容。 </p>
<p>七、系统文件的问题 当与IE有关的系统文件被更换或损坏时，会影响到IE正常的使用，这时可使用SFC命令修复一下，WIN98系统可在“运行”中执行SFC，然后执行扫描；WIN2000/XP/2003则在“运行”中执行sfc /scannow尝试修复。 其中当只有IE无法浏览网页，而可以上时，则往往由于winsock.dll、wsock32.dll或wsock.vxd（VXD只在WIN9X系统下存在）等文件损坏或丢失造成，Winsock是构成TCP/IP协议的重要组成部分，一般要重装TCP/IP协议。但xp开始集成TCP/IP协议，所以不能像98那样简单卸载后重装，可以使用 netsh 命令重置 TCP/IP协议，使其恢复到初次安装操作系统时的状态。具体操作如下： 点击“开始 运行”，在运行对话框中输入“CMD”命令，弹出命令提示符窗口，接着输入“netsh int ip reset c:\resetlog.txt”命令后会回车即可，其中“resetlog.txt”文件是用来记录命令执行结果的日志文件，该参数选项必须指定，这里指定的日志文件的完整路径是“c:\resetlog.txt”。执行此命令后的结果与删除并重新安装 TCP/IP 协议的效果相同。 小提示：netsh命令是一个基于命令行的脚本编写工具，你可以使用此命令配置和监视Windows 系统，此外它还提供了交互式网络外壳程序接口，netsh命令的使用格式请参看帮助文件（在令提示符窗口中输入“netsh/?”即可）。 第二个解决方法是修复以上文件，WIN9X使用SFC重新提取以上文件，WIN2000/XP/2003使用sfc /scannow命令修复文件,当用sfc /scannow无法修复时，可试试网上发布的专门针对这个问题的修复工具WinSockFix，可以在网上搜索下载。 </p>
<p>八、杀毒软件的实时监控问题 这倒不是经常见，但有时的确跟实时监控有关，因为现在杀毒软件的实时监控都添加了对网页内容的监控。举一个实例：KV2005就会在个别的机子上会导致IE无法浏览网页（不少朋友遇到过），其具体表现是只要打开网页监控，一开机上网大约20来分钟后，IE就会无法浏览网页了，这时如果把KV2005的网页监控关掉，就一切恢复正常；经过彻底地重装KV2005也无法解决。虽然并不是安装KV2005的每台机子都会出现这种问题，毕竟每台机子的系统有差异，安装的程序也不一样。但如果出现IE无法浏览网页时，也要注意检查一下杀毒软件。</p>
<p>九、感染了病毒所致 这种情况往往表现在打开IE时，在IE界面的左下框里提示：正在打开网页，但老半天没响应。在任务管理器里查看进程，（进入方法，把鼠标放在任务栏上，按右键—任务管理器—进程）看看CPU的占用率如何，如果是100%，可以肯定，是感染了病毒，这时你想运行其他程序简直就是受罪。这就要查查是哪个进程贪婪地占用了CPU资源．找到后，最好把名称记录下来，然后点击结束，如果不能结束，则要启动到安全模式下把该东东删除，还要进入注册表里，（方法：开始—运行，输入regedit）在注册表对话框里，点编辑—查找，输入那个程序名，找到后，点鼠标右键删除，然后再进行几次的搜索，往往能彻底删除干净。 有很多的病毒，杀毒软件无能为力时，唯一的方法就是手动删除。</p>
<p>十一、无法打开二级链接 还有一种现象也需特别留意：就是能打开网站的首页，但不能打开二级链接，如果是这样，处理的方法是重新注册如下的DLL文件： 在开始—运行里输入： regsvr32 Shdocvw.dll regsvr32 Shell32.dll（注意这个命令，先不用输） regsvr32 Oleaut32.dll regsvr32 Actxprxy.dll regsvr32 Mshtml.dll regsvr32 Urlmon.dll regsvr32 Msjava.dll regsvr32 Browseui.dll 注意：每输入一条，按回车。第二个命令可以先不用输，输完这些命令后重新启动windows，如果发现无效，再重新输入一遍，这次输入第二个命令。</p>
</blockquote>
<p><strong>解决办法</strong></p>
<blockquote>
<p>关闭全局代理<br>换用Safari可以打开</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一、网络设置的问题 这种原因比较多出现在需要手动指定IP、网关、DNS服务器联网方式下，及使用代理服务器上网的。仔细检查计算机的网络设置。 &lt;/p&gt;
&lt;p&gt;二、DNS服务器的问题 当IE无法浏览网页时，可先尝试用IP地址来访问，如果可以访问，那么应
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="问题汇总" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    
      <category term="Tomcat服务器" scheme="http://yoursite.com/tags/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习路线</title>
    <link href="http://yoursite.com/2017/04/13/JavaWeb%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>http://yoursite.com/2017/04/13/JavaWeb学习路线/</id>
    <published>2017-04-13T02:04:36.000Z</published>
    <updated>2017-04-23T02:41:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Java学习这一部分其实也算是今天的重点，这一部分用来回答很多群里的朋友所问过的问题，那就是我你是如何学习Java的，能不能给点建议？今天我是打算来点干货，因此咱们就不说一些学习方法和技巧了，直接来谈每个阶段要学习的内容甚至是一些书籍。这一部分的内容，同样适用于一些希望转行到Java的同学。</p>
<p>在大家看之前，我要先声明两点。1、由于我本人是Java后端开发出身，因此所推荐的学习内容是Java Web和Java后端开发的路线，非Java Web和Java后端开发的同学请适当参考其学习思想即可，切勿照搬。2、下面对于【第一部分】的推荐内容，目的是让你尽快成为一个可以参加工作的Java开发者，更适用于处于待业状态，准备转行Java的同学。</p>
<p>如果你是在校学生，务必要在学好基础（比如计算机系统、算法、编译原理等等）的前提下，再考虑去进行下面的学习。</p>
</blockquote>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><blockquote>
<p>对于尚未做过Java工作的同学，包括一些在校生以及刚准备转行Java的同学。</p>
<p>一、Java基础首先去找一个Java的基础教程学一下，这里可以推荐一个地址，或者你也可以参照这个地址上去找相应的视频。学习Java基础的时候，应该尽量多动手，很多时候，你想当然的事情，等你写出来运行一下，你就会发现不是这么回事儿，不信你就试试。学完以上内容以后，你应该对Java有一个基本的了解了，你可以用Java语言写出一些简单的程序，并且你用的是最简单的编辑器，比如记事本。这个时候，不要急于进入下一部分，留下几天好好写一些程序，尽可能熟悉这些基础内容。</p>
<p>二、Web开发等你写上几天程序以后，你往往会比较迷茫，因为你写的东西似乎看起来毫无用处，比如实现一个简单的计算器，读取一个文件等。这个时候你就应该去学着写一些让你觉得有意思的东西了，所以你应该学习更多的知识。这些内容主要是Web开发相关的内容，包括HTML/CSS/JS（前端页面）、Servlet/JSP（J2EE）以及Mysql（数据库）相关的知识。它们的学习顺序应该是从前到后，因此最先学习的应该是HTML/CSS/JS（前端页面），这部分内容你可以去上面的那个runoob网站上找。</p>
<p>你可以试着自己写一些页面，当然，你可以尽你最大的努力让它变得最漂亮。这部分内容对于后端Java来说，理论上不是特别重要，但至少要达到可以自己写出一些简单页面的水平。接下来，你需要学习的是Servlet/JSP（J2EE）部分，这部分是Java后端开发必须非常精通的部分，因此这部分是这三部分中最需要花精力的，而且这个时候，你要学会使用开发工具，而不能再使用记事本了，可以选择eclipse。当你下载安装好eclipse以后，请视频中的教程一步一步去学习，一定要多动手。关于Servlet/Jsp部分视频的选择，业界比较认可马士兵的视频，因此推荐给大家。</p>
<p>当然了，我本人并没有看过他的视频，所以不好说的太绝对，如果大家自己有更好的选择，可以坚持自己的，不要被我干扰。原本我也是打算出教学视频的，但是由于时间问题，还是决定放弃了。但是如果你看视频的过程中遇到了问题，欢迎来我的交流群提问，或者去斗鱼观看我的直播提出你的问题，直播地址和群号都在我的个人博客左侧。最后一步，你需要学会使用数据库，mysql是个不错的入门选择，而且Java领域里主流的关系型数据库就是mysql。这部分一般在你学习Servlet/Jsp的时候，就会接触到的，其中的JDBC部分就是数据库相关的部分。你不仅要学会使用JDBC操作数据库，还要学会使用数据库客户端工具，比如navicat，sqlyog，二选一即可。</p>
<p>三、开发框架当你学会以上内容以后，这个时候你还不足以参加工作，你还需要继续深造。公司里为了提高开发的效率，会使用一些Java Web框架，因此你还需要学习一些开发框架。目前比较主流的是SSM框架，即spring、springmvc、mybatis。你需要学会这三个框架的搭建，并用它们做出一个简单的增删改查的Web项目。你可以不理解那些配置都是什么含义，以及为什么要这么做，这些留着后面你去了解。</p>
<p>但你一定要可以快速的利用它们三个搭建出一个Web框架，你可以记录下你第一次搭建的过程，相信我，你一定会用到的。还要提一句的是，你在搭建SSM的过程中，可能会经常接触到一个叫maven的工具。这个工具也是你以后工作当中几乎是必须要使用的工具，所以你在搭建SSM的过程中，也可以顺便了解一下maven的知识。在你目前这个阶段，你只需要在网络上了解一下maven基本的使用方法即可，一些高端的用法随着你工作经验的增加，会逐渐接触到的。<br>关于学习SSM框架的地址给大家推荐一个，这里面有视频，大家可以去观看。</p>
<p>四、找工作当你完成开发框架的学习以后，你就该找工作了，在校的找实习，毕业的找全职。与此同时，在找工作的同时，你不应该停下你的学习，准确的说，是你在以后都不能停下学习。上面这些内容你只是囫囵吞枣的学会了使用，你可以逐步尝试着去了解更多的东西，网络是你最重要的老师。
　　</p>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>对于参加工作一年以内的同学。恭喜你，这个时候，你已经拥有了一份Java的工作。这个阶段是你成长极快的阶段，而且你可能会经常加班。但是加班不代表你就可以松懈了，永远记得我说的那句话，从你入行那一刻起，你就要不停的学习。在这一年里，你至少需要看完《Java编程思想》这本书。这本书的内容是帮助你对于Java有一个更加深入的了解，是Java基础的升级版。这本书很厚，当初看这本书，我花了整整三个月。正常速度的话，应该可以在半年左右看完。我这里不要求过高，只要你在一年以内把这本书看完即可。当然了，我所说的看完，是充分吸收，而不是读一遍就完事了，因此有些内容你可能会看不止一遍。总而言之，这个阶段的核心学习思想就是，在工作中实践，并且更加深入的了解Java基础。<br>　　<br>对于参加工作1年到2年的同学。这部分时间段的同学，已经对Java有了一个更加深入的了解。但是对于面向对象的体会可能还不够深刻，编程的时候还停留在完成功能的层次，很少会去考虑设计的问题。于是这个时候，设计模式就来了。我当时看的是《大话设计模式》这本书，并且写了完整版的设计模式博客。因此，我要求大家，最多在你工作一年的时候，必须开始写博客，而设计模式就是你博客的开端。</p>
<p>请记住，我所提的基本都是最低要求，因此不要有任何松懈的心理，否则五年后，你不要去羡慕别人高于你的工资，也不要去羡慕别人进入了某公司。这一年，你必须对于设计模式了如指掌，《大话设计模式》可以作为你的开端。此外，设计模式并不是你这一年唯一的任务，你还需要看一些关于代码编写优化的书。比如《重构 改善既有代码的设计》，《effective java》。总而言之，这个阶段，你的核心任务就是提高你的代码能力，要能写出一手优雅的代码。
　　</p>
<h3 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h3><p>对于参加工作2年到3年的同学有的同学在这个时候觉得自己已经很牛逼了，于是忍不住开始慢慢松懈。请记住，你还嫩的多。这个阶段，有一本书是你必须看的，它叫做《深入理解Java虚拟机》。这本书绝对是Java开发者最重要的书，没有之一。在我眼里，这本书的重要性还要高于《Java编程思想》。这本书的内容是帮助你全面的了解Java虚拟机，在这个阶段，你一定已经知道Java是运行在JVM之上的。所以，对于JVM，你没有任何理由不了解它。<br>　　<br>另外，在过去2年的工作当中，你肯定或多或少接触过并发。这个时候，你应该去更加深入的了解并发相关的知识，而这部分内容，我比较推荐《Java并发编程实战》这本书。只要你把这本书啃下来了，并发的部分基本已经了解了十之六七。与此同时，这个阶段你要做的事情还远不止如此。这个时候，你应该对于你所使用的框架应该有了更深入的了解，对于Java的类库也有了更深入的了解。</p>
<p>因此，你需要去看一些JDK中的类的源码，也包括你所使用的框架的源码。这些源码能看懂的前提是，你必须对设计模式非常了解。否则的话，你看源码的过程中，永远会有这样那样的疑问，这段代码为什么要这么写？为什么要定义这个接口，它看起来好像很多余？由此也可以看出，这些学习的过程是环环相扣的，如果你任何一个阶段拉下来了，那么你就真的跟不上了，或者说是一步慢步步慢。而且我很负责的告诉你，我在这个阶段的时候，所学习的东西远多于这里所罗列出来的。<br>　　<br>因此千万不要觉得你已经学的很多了，我所说的这些都只是最低要求，不光是我，很多人在这个时间段所学习的内容都远超本文的范围。如果你不能跟上节奏的话，若干年后，如果不是程序猿市场还不错的话，你很可能不仅仅是工资比别人低，公司没别人好，而是根本就找不到工作。总而言之，这个阶段，你需要做的是深入了解Java底层和Java类库（比如并发那本书就是Java并发包java.concurrent的内容），也就是JVM和JDK的相关内容。而且还要更深入的去了解你所使用的框架，方式比较推荐看源码或者看官方文档。另外，还有一种学习的方式，在2年这个阶段，也应该启用了，那就是造轮子。不要听信那套“不要重复造轮子”的论调，那是公司为了节省时间成本编造出来的。重复造轮子或许对别人没有价值，因为你造的轮子可能早就有了，而且一般情况下你造出来的轮子还没有现存的好。<br>　　<br>但是对别人没有价值，不代表对你自己没有价值。一个造轮子的过程，是一个从无到有的过程。这个过程可以对你进行系统的锻炼，它不仅考察你的编码能力，还考察你的框架设计能力，你需要让你的轮子拥有足够好的扩展性、健壮性。而且在造轮子的过程中，你会遇到各种各样的难题，这些难题往往又是你学习的契机。当你把轮子造好的时候，你一定会发现，其实你自己收获了很多。所以，这个阶段，除了上面提到的了解JVM、JDK和框架源码以外，也请你根据别人优秀的源码，去造一个任何你能够想象出来的轮子。</p>
</blockquote>
<h3 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h3><blockquote>
<p>参加工作3年到4年的同学这个阶段的同学，提升已经是很难了，而且这个阶段的学习往往会比较多样化。因为在前3年的过程中，你肯定或多或少接触过一些其它的技术，比如大数据、分布式缓存、分布式消息服务、分布式计算、软负载均衡等等。这些技术，你能精通任何一项，都将是你未来面试时巨大的优势，因此如果你对某一项技术感兴趣的话，<br>　　<br>这个时候可以深入去研究一下。这项技术不一定是你工作所用到的，但一定是相关的。而且在研究一门新技术时，切忌朝三暮四。有的同学今天去整整大数据，搞搞Hadoop、hbase一类的东西。过不了一段时间，就觉得没意思，又去研究分布式缓存，比如redis。然后又过不了一段时间，又去研究分布式计算，比如整整Mapreduce或者storm。结果到最后，搞得自己好像什么都会一样，在简历上大言不惭的写上大数据、分布式缓存、分布式计算都了解，其实任何一个都只是浮于表面。到时候面试官随便一问，就把你给识破了。<br>　　<br>一定要记住，作为一个程序猿，平日里所接触的技术可能会很多，但是想要让一门技术成为你的优势，那么一定是你对这门技术的了解强过绝大多数人才行。因此在这个阶段，你就不能再简单的去学习前3年的内容了，虽然前面的学习如果还不够深入的话依旧要继续，但这个时候你应该更多的考虑建立你的优势，也可以称为差异性。差异性相信不难理解，就是让你自己变得与众不同。你前面三年的学习足够你成为一名基本合格的Java开发者，但你离成为一名优秀的Java开发者还有很大的距离。<br>　　<br>所谓优秀，即能别人所不能。而你前三年所学习的内容，是很多做过几年的Java开发都能够掌握的。那么为了让自己有差异性，你就需要另辟蹊径，找一个方向深入研究下去，以期在将来，你能够成为这个领域的专家，比如分布式计算领域的专家，大数据领域的专家，并发领域的专家等等。此外，你除了建立你的差异性之外，还要去弥补你基础上的不足，直到现在，我都没有提及基础知识。原因是基础是很枯燥无味的，学的太早不仅容易懵逼，而且懵逼的同时还容易产生心理阴影，以至于以后再不想去研究这些基础。但基础又是你深入研究一些领域时所必须掌握的，比如你去研究分布式计算，你不懂算法你玩个毛毛？比如你去做分布式缓存，你对计算机系统的内存不了解，你如何去做缓存？</p>
<p>如果你的基础本来就非常强，那么恭喜你，相信你在之前的工作中已经充分体会到了这些基础对你的帮助。但我相信大部分人的基础都很薄弱，哪怕是科班毕业的人，很多人也不敢说自己当初的基础学的多么强大，比如算法、计算机系统原理、编译原理这些。但是每个人时间都是有限的，而且这些基础的书籍每一本读下来，没个一年半载的，还真拿不下来，因此还是要有所抉择的。虽然艺多不压身，但问题是艺多是有代价的，是需要你付出时间和精力的，而我个人更赞成在同等代价的情况下获取最大的收获。<br>　　<br>首先，我比较推崇的基础书籍有三本，分别是《深入理解计算机系统》，《tcp/ip详解 卷一、二、三》，《数据结构与算法》。其中TCP/IP有三本书，但我们这里把这三本看成是一本大书。这三本分别适合三种人，《深入理解计算机系统》比较适合一直从事Java Web开发和APP后端开发工作的人群。《tcp/ip详解 卷一、二、三》比较适合做网络编程的人群，比如你使用netty去开发的话，那么就要对TCP/IP有更深入的了解。而《数据结构与算法》这本书，则比较适合做计算研究工作的人，比如刚才提到的分布式计算。另外，我要强调的是，这里所说的适合，并不是其它两本对你就没有用。比如你做Java Web和APP后端开发，《tcp/ip详解 卷一、二、三》这本书对你的作用也是很大的。这里只是分出个主次关系而已，你要是时间足够的话，能把三本都精读那当然最好不过了。<br>　　<br>但如果时间有限的话，那么就先挑对你帮助最大的书去读。理论上来讲，这一年你能把这三本其中一本精读下来，就已经非常厉害了。有了基础，有了前面的工作经验，你就可以去开拓属于你的领域了。在这一年里，一定要规划好自己的领域，建立好自己的优势，制造出差异性。如果你对自己的领域不够清晰的话，随着你工作的时间日益增多，你接触的技术会越来越多，这个时候，你很容易被淹死在技术的海洋里，看似接触的技术越来越多，会用的也越来越多，但你毫无优势。有的同学可能会问，“我，我也不知道我的领域是什么啊？怎么办呢？”对于这种人，我只想说，“卧槽，这还问我？要不干脆我替你学习得了，好不好？”</p>
</blockquote>
<h3 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h3><blockquote>
<p>参加工作4年到5年的同学经过前面一年的历练，相信你在自己所钻研的领域已经有了自己一定的见解，这个时候，技术上你应该已经遇到瓶颈了。这个时候不要着急提高自己的技术，已经是时候提高你的影响力了，你可以尝试去一些知名的公司去提高你的背景，你可以发表一些文章去影响更多的人。当然，你也可以去Github创建一个属于你的开源项目，去打造自己的产品。<br>　　<br>这次的开源项目不同于之前的造轮子，你这个时候是真的要去尽量尝试造出来真正对别人有价值的轮子。技术学到这个阶段，很容易遇到瓶颈，而且往往达到一定程度后，你再深入下去的收效就真的微乎其微了，除非你是专门搞学术研究的。然而很可惜，大部分程序猿做不到这一步，那是科学家做的事情。这个时候提高影响力不仅仅是因为技术上容易遇到瓶颈，更多的是影响力可以给你创造更多的机会。程序猿在某种程度上和明星很像，一个好的电视剧和电影就可以成就一批明星，程序猿有的时候也是，一个好的项目就可以成就一群程序猿。比如国内几个脍炙人口的项目，像淘宝、支付宝、QQ、百度、微信等等。这每一个项目，都成就了一批程序猿。我敢说，这里面任何一个项目，如果你是它的核心开发，光是这样一个Title，就已经是你非常大的优势。更何况还不止如此，Title说到底也是个名头，更重要的是，这种项目在做的时候，对你的历练一定也是非常给力的。<br>　　<br>而你如果想要参与这样的项目，除了靠运气之外，影响力也是很重要的一个手段。比如你在分布式计算领域有一定的影响力，那么如果有什么好的关于分布式计算的项目，对方就很可能会邀请你。就算人家不邀请你，你自己主动去面试的时候，对方如果知道你在这个领域的影响力，也肯定会起到很大的作用，而这个作用，甚至可能会超过你现在的技术能力。所以，在这个阶段，你最大的任务是提高自己的影响力，为自己未来的十年工作生涯那一天做准备。如果你能够靠你的影响力和以前积累的技术，参与到一个伟大的项目当中，那么你后面的五年也就有着落了。当然了，我现在满打满算，做程序猿也就4年半不到，因此关于4年到5年这一部分，我的见解不一定是对的，就算是对的，也不一定是适合任何人的。<br>　　<br>所以，希望大家自己有的判断力，去决定到底该如何度过这一年。结语本文到此就基本结束了，整篇文章很长，但其实主要就说了两部分内容，一个是社招面试的准备，一个是Java生涯的学习。关于这两部分，我已经给出了自己的见解，但是还是那句话，每个人吸收知识的时候，都要有抽取精华，去除糟粕的能力。我所说的，可能有些是对的，有些是错的，有些是适合你的，有些是不太适合你的，你要自己能够判断。其实你在生活和工作当中也是一样的，你身边的人形形色色，有的人你喜欢，有的人你很讨厌。但其实你喜欢的人也有缺点，你讨厌的人也有优点。你要学会从你讨厌的人身上学会他的优点，千万不要一棒子打死，这只会让你失去很多学习成长的机会。好了，说了这么多了，就到此为止吧，希望本文可以帮助到作为程序猿或即将成为程序猿的你。</p>
</blockquote>
<p><strong>参考资料</strong><br><a href="http://www.cnblogs.com/huaxingtianxia/p/5724093.html" target="_blank" rel="external">一位资深程序员大牛给予Java初学者的学习路线建议</a></p>
<p>博客地址：<a href="http://www.cnblogs.com/huaxingtianxia/" target="_blank" rel="external">华行天下</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Java学习这一部分其实也算是今天的重点，这一部分用来回答很多群里的朋友所问过的问题，那就是我你是如何学习Java的，能不能给点建议？今天我是打算来点干货，因此咱们就不说一些学习方法和技巧了，直接来谈每个阶段要学习的内容甚至是一些书籍。这一部分的内
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="阅读" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Apache与Tomcat服务器的基本使用</title>
    <link href="http://yoursite.com/2017/04/07/Apache%E4%B8%8ETomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/04/07/Apache与Tomcat服务器的基本使用/</id>
    <published>2017-04-07T05:24:40.000Z</published>
    <updated>2017-04-07T05:29:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Apache服务器的使用"><a href="#Apache服务器的使用" class="headerlink" title="Apache服务器的使用"></a>Apache服务器的使用</h3><ul>
<li>开启：sudo apachectl start</li>
<li>停止：sudo apachectl stop</li>
<li>重启：sudo apachectl restart</li>
<li>重启但不中断当前连接 sudo apachectl graceful</li>
</ul>
<p><strong>配置：在/private/etc目录下修改相关文件，如httpd.conf文件</strong></p>
<pre><code>1. 默认情况下使用http://127.0.0.1:80 访问/Library/WebServer/Documents目录下的资源 
2. 在/ScienceHistory/Sites文件夹中放入资源文件，使用http://127.0.0.1:80/\~ScienceHistory/进入上述的/ScienceHistory/Sites文件夹读取资源
</code></pre><h3 id="Tomcat服务器的使用"><a href="#Tomcat服务器的使用" class="headerlink" title="Tomcat服务器的使用"></a>Tomcat服务器的使用</h3><ul>
<li>开启：sudo startup.sh</li>
<li><p>停止：sudo shutdown.sh</p>
<ol>
<li>默认情况下使用<a href="http://127.0.0.1:8080,进入到上述路径/usr/local/apache-tomcat-8.0.30/webapps/ROOT目录下访问资源" target="_blank" rel="external">http://127.0.0.1:8080,进入到上述路径/usr/local/apache-tomcat-8.0.30/webapps/ROOT目录下访问资源</a> </li>
<li>在/usr/local/apache-tomcat-8.0.30/webapps路径下放入javaweb生成的资源,如<a href="http://127.0.0.1:8080/abc/123.mp4" target="_blank" rel="external">http://127.0.0.1:8080/abc/123.mp4</a> 文件等</li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Apache服务器的使用&quot;&gt;&lt;a href=&quot;#Apache服务器的使用&quot; class=&quot;headerlink&quot; title=&quot;Apache服务器的使用&quot;&gt;&lt;/a&gt;Apache服务器的使用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;开启：sudo apachectl start&lt;
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Apache" scheme="http://yoursite.com/tags/Apache/"/>
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android --- Activity转场动画(过渡动画)</title>
    <link href="http://yoursite.com/2017/01/06/Android%20---%20Activity%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB(%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB)/"/>
    <id>http://yoursite.com/2017/01/06/Android --- Activity转场动画(过渡动画)/</id>
    <published>2017-01-06T10:03:30.000Z</published>
    <updated>2017-01-06T10:06:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Google-Search-博文"><a href="#Google-Search-博文" class="headerlink" title="Google Search 博文"></a>Google Search 博文</h3><p><a href="http://www.jianshu.com/p/415a32976cc6" target="_blank" rel="external">Android开发之Activity转场动画</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Google-Search-博文&quot;&gt;&lt;a href=&quot;#Google-Search-博文&quot; class=&quot;headerlink&quot; title=&quot;Google Search 博文&quot;&gt;&lt;/a&gt;Google Search 博文&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http:
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="转场动画" scheme="http://yoursite.com/tags/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    
      <category term="过渡动画" scheme="http://yoursite.com/tags/%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/"/>
    
      <category term="Activity" scheme="http://yoursite.com/tags/Activity/"/>
    
      <category term="Android 5.0+" scheme="http://yoursite.com/tags/Android-5-0/"/>
    
  </entry>
  
  <entry>
    <title>Android地图SDK</title>
    <link href="http://yoursite.com/2017/01/04/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%20-%20Android%E5%9C%B0%E5%9B%BESDK/"/>
    <id>http://yoursite.com/2017/01/04/百度地图 - Android地图SDK/</id>
    <published>2017-01-04T05:01:42.000Z</published>
    <updated>2017-04-07T05:33:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Android地图SDK-v4-1-1"><a href="#Android地图SDK-v4-1-1" class="headerlink" title="Android地图SDK (v4.1.1)"></a>Android地图SDK (v4.1.1)</h3><blockquote>
<p><strong> Android地图SDK</strong>是一套基于Android 2.3及以上版本设备的应用程序接口。 您可以使用该套 SDK开发适用于Android系统移动设备的地图应用，通过调用<strong>地图SDK</strong>接口，您可以轻松访问百度地图服务和数据，构建功能丰富、交互性强的地图类应用程序。</p>
<p>自v4.0起，适配<strong>Android Wear</strong>，支持Android穿戴设备，新增室内图相关功能。</p>
<p>百度地图Android SDK提供的所有服务是免费的，接口使用无次数限制。您需<strong><a href="http://lbsyun.baidu.com/apiconsole/key" target="_blank" rel="external">申请密钥（key）</a></strong>后， 才可使用百度地图Android SDK。</p>
</blockquote>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="1-地图"><a href="#1-地图" class="headerlink" title="1. 地图"></a>1. 地图</h4><blockquote>
<p>提供<strong>地图展示</strong>和<strong>地图操作</strong>功能。</p>
</blockquote>
<ul>
<li>地图展示包括：普通地图（2D，3D）、卫星图和实时交通图；</li>
<li>地图操作：可通过接口或手势控制来实现地图的点击、双击、长按、缩放、旋转、改变视角等操作；</li>
<li>地图展示：开放高清4K地图显示。</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu1.png" alt=""></p>
<h4 id="2-POI检索"><a href="#2-POI检索" class="headerlink" title="2. POI检索"></a>2. POI检索</h4><blockquote>
<p>支持<strong>周边检索</strong>、<strong>区域检索</strong>、<strong>城市内检索</strong>和<strong>Place详情信息检索</strong>。</p>
</blockquote>
<ul>
<li>周边检索：以某一点为中心，指定距离为半径，根据用户输入的关键词进行POI检索；</li>
<li>区域检索：在指定矩形区域内、根据关键词进行POI检索；</li>
<li>城市内检索：在某一城市内，根据用户输入的关键字进行POI检索；</li>
<li>POI详情检索：根据POI的ID信息，检索该兴趣点的详情。</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu2.png" alt=""></p>
<h4 id="3-地理编码"><a href="#3-地理编码" class="headerlink" title="3. 地理编码"></a>3. 地理编码</h4><blockquote>
<p>提供<strong>地理坐标</strong>和<strong>实际地址</strong>之间相互转换的能力。</p>
</blockquote>
<ul>
<li>正向地理编码：实现了将中文地址或地名描述转换为地球表面上相应位置的功能；</li>
<li>反向地理编码：将地球表面的地址坐标转换为标准地址的过程。</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu3.png" alt=""></p>
<h4 id="4-线路规划"><a href="#4-线路规划" class="headerlink" title="4. 线路规划"></a>4. 线路规划</h4><blockquote>
<p>支持<strong>公交信息查询</strong>、<strong>公交换乘查询</strong>、<strong>公交/驾车/骑行/步行线路规划</strong>。</p>
</blockquote>
<ul>
<li>公交信息查询：可对公交详细信息进行查询；</li>
<li>公交换乘查询：根据起、终点，查询策略，进行线路规划方案；</li>
<li>驾车线路规划：提供不同策略，规划驾车路线；（支持设置途经点）</li>
<li>步行路径检索：支持步行路径的规划;</li>
<li>骑行路径检索：支持跨城骑行路径规划。</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu4.png" alt=""></p>
<h4 id="5-地图覆盖物"><a href="#5-地图覆盖物" class="headerlink" title="5. 地图覆盖物"></a>5. 地图覆盖物</h4><blockquote>
<p>百度地图SDK支持<strong>多种地图覆盖物</strong>，帮助您展示更丰富的地图。目前所支持的地图覆盖物有：<strong>定位图层</strong>、<strong>地图标注（Marker）</strong>、<strong>几何图形（点、折线、弧线、多边形等）</strong>、<strong>地形图图层</strong>、<strong>POI检索结果覆盖物</strong>、<strong>线路规划结果覆盖物</strong>、<strong>热力图图层</strong>、<strong>瓦片图层</strong>等。</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu5.jpg" alt=""></p>
<h4 id="6-定位"><a href="#6-定位" class="headerlink" title="6. 定位"></a>6. 定位</h4><blockquote>
<p>采用<strong>GPS</strong>、<strong>WIFI</strong>、<strong>基站</strong>、<strong>IP混合定位模式</strong>，请使用<strong>Android定位SDK获取定位信息</strong>，使用<strong>地图SDK定位图层进行位置展示</strong>。</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu6.png" alt=""></p>
<h4 id="7-离线地图"><a href="#7-离线地图" class="headerlink" title="7. 离线地图"></a>7. 离线地图</h4><blockquote>
<p>用户可以通过<strong>SDK在线下载离线包接口</strong>，下载离线地图包，使用离线地图可节省用户流量，提供更好的地图展示效果。</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu7.png" alt=""></p>
<h4 id="8-调启百度地图"><a href="#8-调启百度地图" class="headerlink" title="8. 调启百度地图"></a>8. 调启百度地图</h4><blockquote>
<p>利用SDK接口，直接在本地打开百度地图客户端或WebApp，实现地图功能。 目前支持调启的功能有：POI周边检索、POI详情页面、步行线路规划、驾车线路规划、公交线路规划、驾车导航、步行导航、骑行导航。 （具体请参考开发指南中，<strong>计算工具</strong>章节内的介绍）</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu8.png" alt=""></p>
<h4 id="9-周边雷达"><a href="#9-周边雷达" class="headerlink" title="9. 周边雷达"></a>9. 周边雷达</h4><blockquote>
<p>周边雷达功能，是面向移动端开发者的一套SDK功能接口。同步支持Android和iOS端。它的本质是一个连接百度LBS开放平台前端SDK产品和后端LBS云的中间服务。开发者利用周边雷达功能，可以便捷的在自己的应用内，帮助用户实现查找周边跟“我”使同样一款App的人，这样一个功能。</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu9.png" alt=""></p>
<h4 id="10-LBS云"><a href="#10-LBS云" class="headerlink" title="10. LBS云"></a>10. LBS云</h4><blockquote>
<p>百度地图LBS云是百度地图针对LBS开发者全新推出的平台级服务，不仅适用PC应用开发，同时适用移动设备应用的开发。</p>
<p>使用LBS云，可以实现移动开发者存储海量位置数据的服务器零成本及维护压力，且支持高效检索用户数据，且实现地图展现。</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu10.png" alt=""></p>
<h4 id="11-特色功能"><a href="#11-特色功能" class="headerlink" title="11. 特色功能"></a>11. 特色功能</h4><blockquote>
<p>包括：<strong>短串分享</strong>、<strong>Place详情信息检索</strong>、<strong>热力图</strong>等。</p>
</blockquote>
<ul>
<li>短串分享：将POI搜索结果、驾车/公交/骑行/步行路线规划结果 或反地理编码结果生成短串，当其他用户点击短串即可打开手机上的百度地图客户端或者手机浏览器进行查看；</li>
<li>Place详情检索：根据POI的ID信息，检索该POI的详情；</li>
<li>热力图功能：开放热力图绘制能力，帮助开发者构建属于自己的热力图；</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu11.png" alt=""></p>
<h4 id="12-个性化地图"><a href="#12-个性化地图" class="headerlink" title="12. 个性化地图"></a>12. 个性化地图</h4><blockquote>
<p>自v3.7.0起，支持使用个性化地图模板，改变底图颜色和样式。</p>
</blockquote>
<ul>
<li>使用个性化模板，实现地图元素的颜色设置，地图元素包含大地、水系、草地、高速、普通道路、铁路、地铁，poi等，以及poi和道路的文字颜色设置。</li>
<li>通过可见属性，控制显示地图元素。</li>
</ul>
<blockquote>
<p>下个版本，我们将进一步优化此功能，让广大开发者可以通过可视化编辑器方式编辑样式模板。</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu12.jpg" alt=""></p>
<h4 id="13-室内图"><a href="#13-室内图" class="headerlink" title="13. 室内图"></a>13. 室内图</h4><blockquote>
<p>自v4.0起，百度地图SDK室内图功能正式上线，辅助开发者实现全新的地理位置服务体验，室内地图与百度地图App同步更新。</p>
</blockquote>
<ul>
<li>支持的公众建筑包含购物商场、机场和火车站等交通枢纽，医院等，覆盖全国约600个大型购物中心，覆盖类型和城市还在持续增加中。</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu13.png" alt=""></p>
<h4 id="14-Android-Wear"><a href="#14-Android-Wear" class="headerlink" title="14. Android Wear"></a>14. Android Wear</h4><blockquote>
<p>自v4.0起，适配Android Wear，支持Android穿戴设备。</p>
</blockquote>
<ul>
<li>适配穿戴设备显示屏，支持地图显示、POI检索、路线规划等全部功能</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu14.png" alt=""></p>
<h3 id="获取密钥"><a href="#获取密钥" class="headerlink" title="获取密钥"></a>获取密钥</h3><p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu15.png" alt=""></p>
<blockquote>
<p>需要创建一个应用，便可以获得该应用的<strong>访问应用（AK）</strong>密钥。</p>
</blockquote>
<h3 id="开发指南"><a href="#开发指南" class="headerlink" title="开发指南"></a>开发指南</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>什么是百度地图Android SDK?</strong></p>
<blockquote>
<p>百度地图 Android SDK是一套基于Android 2.1及以上版本设备的应用程序接口， 您可以通过该接口实现丰富的LBS功能：</p>
</blockquote>
<ul>
<li>地图：提供地图（2D、3D）的展示和缩放、平移、旋转、改变视角等地图操作；</li>
<li>室内图：提供展示<strong>公众建筑物室内地图</strong>的展示功能；</li>
<li>Android Wear：适配Android Wear，支持Android穿戴设备；</li>
<li>POI检索：可根据关键字，对POI数据进行周边、区域和城市内三种检索；</li>
<li>室内POI检索：支持设置城市和当前建筑物的室内POI检索；</li>
<li>地理编码：提供地理坐标和地址之间相互转换的能力；</li>
<li>线路规划：支持公交信息查询、公交换乘查询、驾车线路规划和步行路径检索；</li>
<li>覆盖物：提供多种地图覆盖物（自定义标注、几何图形、文字绘制、地形图图层、热力图图层等），满足开发者的各种需求；</li>
<li>定位：采用多种定位模式，使用定位SDK获取位置信息，使用地图SDK我的位置图层进行位置展示；</li>
<li>离线地图：支持使用离线地图，节省用户流量，同时为用户带来更好的地图体验；</li>
<li>调启百度地图：利用SDK接口，直接在本地打开百度地图客户端或WebApp，实现地图功能;</li>
<li>周边雷达：利用周边雷达功能，开发者可在App内低成本、快速实现查找周边使用相同App的用户位置的功能;</li>
<li>LBS云检索：支持用户检索存储在LBS云内的自有POI数据，并展示；</li>
<li>瓦片图层：支持开发者在地图上添加自有瓦片数据；</li>
<li>特色功能：提供短串分享、Place详情检索、热力图等特色功能，帮助开发者搭建功能更加强大的应用；</li>
</ul>
<p><strong>面向的读者</strong></p>
<blockquote>
<p>百度地图SDK是提供给具有一定Android编程经验和了解面向对象概念的读者使用。此外，读者还应该对<strong>地图的基本知识</strong>有一定的了解。在使用中遇到任何问题，都可以通过<a href="http://bbs.lbsyun.baidu.com/" target="_blank" rel="external">API论坛</a>。</p>
</blockquote>
<p><strong>获取定制的百度地图SDK</strong></p>
<blockquote>
<p>开发者可在百度地图Android SDK的下载页面下载到最新版的地图SDK，下载地址为：<a href="http://developer.baidu.com/map/index.php?title=androidsdk/sdkandev-download" target="_blank" rel="external">http://developer.baidu.com/map/index.php?title=androidsdk/sdkandev-download</a>.</p>
<p>为了给开发者带来更优质的地图服务、满足开发者灵活使用SDK的需求，百度地图SDK自v2.3.0起，采用了<strong>可定制</strong>的形式为用户提供开发包。 百度地图SDK按功能可分为：基础地图、检索功能、LBS云检索、计算工具和周边雷达五个部分，开发者可根据自身的实际需求，任意组合这五种功能，点击下载页面的“自定义下载”， 即可下载相应的开发包来完成自己的应用开发。</p>
</blockquote>
<ul>
<li>基础地图：包括基本矢量地图、卫星图、实时路况图、室内图、适配Android Wear，各种地图覆盖物，瓦片图层，OpenGL绘制能力。此外还包括各种与地图相关的操作和事件监听；</li>
<li>检索功能：包括POI检索（周边、区域、城市内），室内POI检索，Place详情检索，公交信息查询，路线规划（驾车、步行、公交），地理编码/反地理编码，在线建议查询，短串分享等；</li>
<li>LBS云检索：包括LBS云检索（周边、区域、城市内、详情）；</li>
<li>计算工具：包括计算两点之间距离、计算矩形面积、坐标转换、调启百度地图客户端、判断点和圆/多边形位置关系、本地收藏夹等功能；</li>
<li>周边雷达：包含位置信息上传和检索周边相同应用的用户位置信息功能；</li>
</ul>
<blockquote>
<p>注：本套开发指南是针对默认的全功能包编写，开发者在使用定制化的SDK进行开发时，请参考开发指南中相对应的章节获取更多信息。</p>
</blockquote>
<p><strong>兼容性</strong></p>
<blockquote>
<p>支持Android 2.1 及以上系统。</p>
</blockquote>
<h4 id="申请密钥"><a href="#申请密钥" class="headerlink" title="申请密钥"></a>申请密钥</h4><p><strong>简介</strong></p>
<blockquote>
<p>在使用百度地图SDK为您提供的各种LBS能力之前，您需要获取百度地图移动版的<strong>开发密钥</strong>，<strong>该密钥与您的百度账户相关联</strong>。因此，您必须先有百度帐户，才能获得开发密钥。并且，该<strong>密钥与您创建的过程名称有关</strong>，具体流程请参考如下介绍。</p>
<p>Key的申请地址为：<a href="http://lbsyun.baidu.com/apiconsole/key" target="_blank" rel="external">http://lbsyun.baidu.com/apiconsole/key</a></p>
</blockquote>
<p><strong>注意</strong></p>
<ol>
<li><strong>每个Key唯一对应一个APP</strong>，如果您的APP<strong>修改了包名</strong>或者<strong>发布的时候打包的签名文件改变了</strong>，则改变前后的APP被视为两个APP。因此，多个APP【包括一份代码多个包名打包】需申请多个与之对应的Key；</li>
<li>在同一个工程中同时使用百度地图SDK、定位SDK、导航SDK 和全景SDK的全部或者任何组合，可以<strong>共用同一个key</strong>；</li>
<li>如果您在Android SDK开发过程中使用了LBS云服务（如LBS云检索功能），则需要为该服务<strong>单独申请一个“服务端”类型的key</strong>，代码中调用LBS云服务接口时使用此key即可，注意：此key一定要和AndroidManifest.xml中配置API_KEY的key区分开；</li>
<li>Android SDK自v2.1.3版本开始采用了全新的Key验证体系，v2.1.3之前的版本不再维护，如果升级到新版本SDK（v2.1.3及之后的版本）时需要在API控制台重新申请key进行替换。</li>
</ol>
<p><strong>申请步骤</strong></p>
<ol>
<li>登录百度账号</li>
</ol>
<blockquote>
<p>访问API控制台页面，若您未登录百度账号，将会进入百度账号登录页面，如下图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu16.png" alt=""></p>
<ol>
<li>登陆API控制台</li>
</ol>
<blockquote>
<p>登录会跳转到API控制台服务，具体如下图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu17.png" alt=""></p>
<ol>
<li>创建应用</li>
</ol>
<blockquote>
<p>点击”创建应用”，进入创建AK页面，输入应用名称，将应用类型改为：“Android SDK”：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu18.png" alt=""><br><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu19.png" alt=""></p>
<ol>
<li>配置应用</li>
</ol>
<blockquote>
<p>在应用类型选为“Android SDK”后，需要配置应用的安全码，如下图所示：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu20.png" alt=""></p>
<ol>
<li>获取安全码</li>
</ol>
<blockquote>
<p>安全码的组成规则为：Android签名证书的sha1值+packagename , 例如：</p>
<p>SHA1：BB:0D:AC:74:D3:21:E1:43:67:71:9B:62:91:AF:A1:66:6E:44:5D:75<br>包名：com.baidumap.demo</p>
<p>Android应用获取包名packagename，AS工程获取位置:</p>
<p>包名需要在文件<strong>build.gradle中查询 applicationId</strong>，并确保 applicationId 与在 AndroidManifest.xml 中定义的包名一致</p>
<p>在文件build.gradle中查询 applicationId，方法如图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu21.png" alt=""></p>
<blockquote>
<p>Android签名证书的sha1值获取方式有两种：</p>
</blockquote>
<ul>
<li><p>第一种方法：使用keytool</p>
<ul>
<li><p>第1步：运行进入控制台</p>
<p>  <img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu22.png" alt=""></p>
</li>
<li><p>第2步：定位到.android文件夹下，输入cd .android</p>
<p>  <img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu23.png" alt=""></p>
</li>
<li><p>第3步：输入keytool -list -v -keystore debug.keystore，会得到三种指纹证书，选取SHA1类型的证书（密钥口令是android），例如：其中keytool为jdk自带工具；keystorefile为Android 签名证书文件</p>
<p>  <img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu24.png" alt=""></p>
</li>
</ul>
</li>
<li><p>第二种方法：在AS中，点击下图signingReport运行Task，即可。</p>
<p>  <img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu25.png" alt=""><br>  <img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu26.png" alt=""></p>
</li>
</ul>
<blockquote>
<p>其中“SHA1”值即为Android签名证书的sha1值</p>
</blockquote>
<ol>
<li>成功创建KEY</li>
</ol>
<blockquote>
<p>在输入安全码后，点击“确定”完成应用的配置工作，您将会得到一个创建的Key，请妥善保管您所申请的Key。到这您就可以使用新Key来完成您的开发工作了。</p>
</blockquote>
<h4 id="配置环境及发布"><a href="#配置环境及发布" class="headerlink" title="配置环境及发布"></a>配置环境及发布</h4><p><strong>开发工具</strong></p>
<blockquote>
<p>Android开发工具很多，主要是Eclipse和Android Studio两种开发工具。下面将主要针对Android Studio介绍一下地图SDK的工程配置方法。Eclipse的工程配置方法参照<a href="http://lbsyun.baidu.com/index.php?title=androidsdk/guide/buildproject" target="_blank" rel="external">官方文档</a>。</p>
</blockquote>
<p><strong>Android Studio工程配置方法</strong></p>
<blockquote>
<p>第一步：在工程<strong>app/libs</strong>目录下放入<strong>baidumapapi_vX_X_X.jar</strong>包，在<strong>src/main/</strong>目录下新建<strong>jniLibs</strong>目录，工程会自动加载src目录下的<strong>so动态库</strong>，放入libBaiduMapSDK_vX_X_X_X.so如下图所示，注意jar和so的前3位版本号必须一致，并且保证使用一次下载的文件夹中的两个文件，不能不同功能组件的jar或so交叉使用。</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu27.png" alt=""></p>
<blockquote>
<p>第二步：工程配置还需要把jar包集成到自己的工程中，如图上图所示，放入libs目录下。对于每个jar文件，右键-选择Add As Library，导入到工程中。对应在build.gradle生成工程所依赖的jar文件说明，如图所示：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu28.png" alt=""></p>
<blockquote>
<p>app模块下的build.gradle文件如下图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu29.png" alt=""></p>
<p><strong>应用混淆</strong></p>
<p>集成地图SDK的应用，在打包混淆的时候，需要注意与地图SDK相关的方法不可被混淆。混淆方法如下：</p>
<pre><code>-keep class com.baidu.** {*;}
-keep class vi.com.** {*;}    
-dontwarn com.baidu.**
</code></pre><blockquote>
<p>保证百度类不能被混淆，否则会出现网络不可用等运行时异常</p>
</blockquote>
<h4 id="Hello-BaiduMap"><a href="#Hello-BaiduMap" class="headerlink" title="Hello BaiduMap"></a>Hello BaiduMap</h4><p><strong>显示百度地图</strong></p>
<blockquote>
<p>百度地图SDK为开发者提供了便捷的显示百度地图数据的接口，通过以下几步操作，即可在您的应用中使用百度地图数据：</p>
</blockquote>
<ul>
<li>创建并配置工程（具体方法参见上部分内容）；</li>
<li><p>在AndroidManifest中添加开发密钥、所需权限等信息；</p>
<ul>
<li><p>在application中添加开发密钥</p>
<application><br>  \<meta-data android:name="com.baidu.lbsapi.API\_KEY" android:value="开发者 key" \=""><br></meta-data></application>
</li>
</ul>
</li>
<li><p>添加所需权限</p>
<p>  \<uses-permission android:name="android.permission.ACCESS\_NETWORK\_STATE" \=""><br>  \<uses-permission android:name="android.permission.INTERNET" \=""><br>  \<uses-permission android:name="com.android.launcher.permission.READ\_SETTINGS" \=""><br>  \<uses-permission android:name="android.permission.WAKE\_LOCK" \=""><br>  \<uses-permission android:name="android.permission.CHANGE\_WIFI\_STATE" \=""><br>  \<uses-permission android:name="android.permission.ACCESS\_WIFI\_STATE" \=""><br>  \<uses-permission android:name="android.permission.GET\_TASKS" \=""><br>  \<uses-permission android:name="android.permission.WRITE\_EXTERNAL\_STORAGE" \=""><br>  \<uses-permission android:name="android.permission.WRITE\_SETTINGS" \=""></uses-permission></uses-permission></uses-permission></uses-permission></uses-permission></uses-permission></uses-permission></uses-permission></uses-permission></p>
</li>
<li><p>在布局xml文件中添加地图控件</p>
<p>  \&lt;com.baidu.mapapi.map.MapView  </p>
<pre><code>android:id=&quot;@+id/bmapView&quot;  
android:layout\_width=&quot;match\_parent&quot;  
android:layout\_height=&quot;match\_parent&quot;  
android:clickable=&quot;true&quot; /\&gt;
</code></pre></li>
<li><p>在应用程序创建时<strong>初始化 SDK引用的Context 全局变量</strong></p>
<p>  public class MainActivity extends Activity {  </p>
<pre><code>@Override  
protected void onCreate(Bundle savedInstanceState) {  
    super.onCreate(savedInstanceState);  
    //在使用SDK各组件之前初始化context信息，传入ApplicationContext  
    //注意该方法要再setContentView方法之前实现  
    SDKInitializer.initialize(getApplicationContext());  
    setContentView(R.layout.activity\_main);  
}  
</code></pre><p>  }</p>
</li>
</ul>
<p><strong>注意：在SDK各功能组件使用之前都需要调用SDKInitializer.initialize(getApplicationContext());，因此我们建议该方法放在Application的初始化方法中</strong></p>
<ul>
<li><p>创建地图Activity，管理地图生命周期</p>
<p>  public class MainActivity extends Activity {  </p>
<pre><code>MapView mMapView = null;  
@Override  
protected void onCreate(Bundle savedInstanceState) {  
    super.onCreate(savedInstanceState);  
    //在使用SDK各组件之前初始化context信息，传入ApplicationContext  
    //注意该方法要再setContentView方法之前实现  
    SDKInitializer.initialize(getApplicationContext());  
    setContentView(R.layout.activity\_main);  
    //获取地图控件引用  
    mMapView = (MapView) findViewById(R.id.bmapView);  
}  
@Override  
protected void onDestroy() {  
    super.onDestroy();  
    //在activity执行onDestroy时执行mMapView.onDestroy()，实现地图生命周期管理  
    mMapView.onDestroy();  
}  
@Override  
protected void onResume() {  
    super.onResume();  
    //在activity执行onResume时执行mMapView. onResume ()，实现地图生命周期管理  
    mMapView.onResume();  
    }  
@Override  
protected void onPause() {  
    super.onPause();  
    //在activity执行onPause时执行mMapView. onPause ()，实现地图生命周期管理  
    mMapView.onPause();  
    }  
}
</code></pre></li>
</ul>
<blockquote>
<p>完成以上步骤后，运行程序，即可在您的应用中显示如下地图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/baiduditu30.jpg" alt=""></p>
<blockquote>
<p>以上的例子为大家介绍了如何构建一个基础的地图页面。地图控件自v2.3.5版本起，<strong>支持多实例</strong>，即开发者可以在一个页面中建立多个地图对象，并且针对这些对象分别操作且不会产生相互干扰。具体使用方法请参考MutiMapViewDemo中的相关介绍。</p>
<p>此外，自v2.3.5版本开始。MapView控件还增加了对Fragment框架的支持。用户可以使用<strong>SupportMapFragment</strong>控件完成相应框架内的开发工作（详见<strong>MapFragmentDemo</strong>）。</p>
</blockquote>
<h4 id="基础地图"><a href="#基础地图" class="headerlink" title="基础地图"></a>基础地图</h4><p><strong>简介</strong></p>
<blockquote>
<p>开发者可利用SDK提供的接口，使用百度为您提供的<strong>基础地图数据</strong>。目前百度地图SDK所提供的<strong>地图等级为3-21级</strong>，所包含的信息有<strong>建筑物、道路、河流、学校、公园等内容</strong>。</p>
<p>V3.7.0起，地图支持缩放至21级，暂不支持卫星图、热力图、交通路况图层的21级显示，打开以上类型图层，地图会自动缩放到20级。</p>
<p>所有叠加或覆盖到地图的内容，我们统称为<strong>地图覆盖物</strong>。如标注、矢量图形元素（包括：折线、多边形和圆等）、定位图标等。覆盖物拥有自己的地理坐标，当您拖动或缩放地图时，它们会相应的移动。</p>
<p>百度地图SDK为广大开发者提供的<strong>基础地图和上面的各种覆盖物元素</strong>，具有一定的层级压盖关系，具体如下（从下至上的顺序）：</p>
</blockquote>
<ul>
<li>1、基础底图（包括底图、底图道路、卫星图、室内图等）；</li>
<li>2、瓦片图层（TileOverlay）；</li>
<li>3、地形图图层（GroundOverlay）；</li>
<li>4、热力图图层（HeatMap）；</li>
<li>5、实时路况图图层（BaiduMap.setTrafficEnabled(true);）；</li>
<li>6、百度城市热力图（BaiduMap.setBaiduHeatMapEnabled(true);）；</li>
<li>7、底图标注（指的是底图上面自带的那些POI元素）；</li>
<li>8、几何图形图层（点、折线、弧线、圆、多边形）；</li>
<li>9、标注图层（Marker），文字绘制图层（Text）；</li>
<li>10、指南针图层（当地图发生旋转和视角变化时，默认出现在左上角的指南针）；</li>
<li>11、定位图层（BaiduMap.setMyLocationEnabled(true);）；</li>
<li>12、弹出窗图层（InfoWindow）；</li>
<li>13、自定义View（MapView.addView(View);）；</li>
</ul>
<p><strong>地图类型</strong></p>
<blockquote>
<p>百度地图Android SDK为您提供了<strong>3种类型的地图资源</strong>（<strong>普通矢量地图、卫星图和空白地图</strong>），开发者可以利用BaiduMap中的mapType()方法来设置地图类型。核心代码如下：</p>
</blockquote>
<pre><code>mMapView = (MapView) findViewById(R.id.bmapView);  
mBaiduMap = mMapView.getMap();  

//普通地图  
mBaiduMap.setMapType(BaiduMap.MAP\_TYPE\_NORMAL);  

//卫星地图  
mBaiduMap.setMapType(BaiduMap.MAP\_TYPE\_SATELLITE);  

//空白地图, 基础地图瓦片将不会被渲染。在地图类型中设置为NONE，将不会使用流量下载基础地图瓦片图层。使用场景：与瓦片图层一起使用，节省流量，提升自定义瓦片图下载速度。
mBaiduMap.setMapType(BaiduMap.MAP\_TYPE\_NONE);
</code></pre><p><strong>实时交通图</strong></p>
<blockquote>
<p>当前，全国范围内已支持多个城市实时路况查询，且会陆续开通其他城市。在地图上打开实时路况的核心代码如下：</p>
</blockquote>
<pre><code>mMapView = (MapView) findViewById(R.id.bmapView);  
mBaiduMap = mMapView.getMap();  
//开启交通图   
mBaiduMap.setTrafficEnabled(true);
</code></pre><p><strong>百度城市热力图</strong></p>
<blockquote>
<p>百度地图SDK继为广大开发者开放<strong>热力图本地绘制能力</strong>之后，再次进一步开放百度自有数据的<strong>城市热力图层</strong>，帮助开发者构建形式更加多样的移动端应用。</p>
<p>百度城市热力图的性质及使用与实时交通图类似，只需要简单的接口调用，即可在地图上展现样式丰富的百度城市热力图。</p>
<p>在地图上开启百度城市热力图的核心代码如下：</p>
</blockquote>
<pre><code>mMapView = (MapView) findViewById(R.id.bmapView);  
mBaiduMap = mMapView.getMap();  
//开启交通图   
mBaiduMap.setBaiduHeatMapEnabled(true);
</code></pre><p><strong>地图控制和手势</strong></p>
<ul>
<li><p>地图控制</p>
<ul>
<li><p>地图Logo</p>
<blockquote>
<p>默认在左下角显示，不可以移除。<br>通过mMapView.setLogoPosition(LogoPosition.logoPostionleftBottom)方法，使用枚举类型控制显示的位置，共支持6个显示位置(左下，中下，右下，左上，中上，右上)。<br>地图Logo不允许遮挡，可通过mBaiduMap.setPadding(paddingLeft, paddingTop, paddingRight, paddingBottom)方法可以设置地图边界区域，来避免UI遮挡。<br>其中参数paddingLeft、paddingTop、paddingRight、paddingBottom参数表示距离屏幕边框的左、上、右、下边距的距离，单位为屏幕坐标的像素密度。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>指南针</p>
<blockquote>
<p>指南针默认为开启状态，可以关闭显示 。</p>
</blockquote>
</li>
<li><p>比例尺</p>
<blockquote>
<p>比例尺默认为开启状态，可以关闭显示。同时支持设置MaxZoomLevel和MinZoomLevel，可通过mMapView.getMapLevel获取当前地图级别下比例尺所表示的距离大小。</p>
</blockquote>
</li>
<li><p>地图手势</p>
<ul>
<li><p>地图平移</p>
<blockquote>
<p>控制是否启用或禁用平移的功能，默认开启。如果启用，则用户可以平移地图</p>
</blockquote>
</li>
</ul>
</li>
<li><p>地图缩放</p>
<blockquote>
<p>控制是否启用或禁用缩放手势，默认开启。如果启用，用户可以双指点击或缩放地图视图。</p>
</blockquote>
</li>
<li><p>地图俯视（3D）</p>
<blockquote>
<p>控制是否启用或禁用俯视（3D）功能，默认开启。如果启用，则用户可使用双指 向下或向上滑动到俯视图。</p>
</blockquote>
</li>
<li><p>地图旋转</p>
<blockquote>
<p>控制是否启用或禁用地图旋转功能，默认开启。如果启用，则用户可使用双指 旋转来旋转地图。</p>
</blockquote>
</li>
<li><p>禁止所有手势</p>
<blockquote>
<p>控制是否一并禁止所有手势，默认关闭。如果启用，所有手势都将被禁用。</p>
</blockquote>
</li>
<li><p>标注覆盖物</p>
<ul>
<li><p>地图标注</p>
<blockquote>
<p>开发者可根据自己实际的业务需求，利用标注覆盖物，在地图指定的位置上添加标注信息。具体实现方法如下：</p>
</blockquote>
<p>//定义Maker坐标点<br>LatLng point = new LatLng(39.963175, 116.400244);<br>//构建Marker图标<br>BitmapDescriptor bitmap = BitmapDescriptorFactory<br>  .fromResource(R.drawable.icon_marka);<br>//构建MarkerOption，用于在地图上添加Marker<br>OverlayOptions option = new MarkerOptions()<br>  .position(point)<br>  .icon(bitmap);<br>//在地图上添加Marker，并显示<br>mBaiduMap.addOverlay(option);</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>针对已经添加在地图上的标注，可采用如下方式进行手势拖拽：</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;Android地图SDK-v4-1-1&quot;&gt;&lt;a href=&quot;#Android地图SDK-v4-1-1&quot; class=&quot;header
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="百度地图" scheme="http://yoursite.com/tags/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE/"/>
    
      <category term="SDK" scheme="http://yoursite.com/tags/SDK/"/>
    
  </entry>
  
  <entry>
    <title>Git使用详解</title>
    <link href="http://yoursite.com/2016/12/29/Git%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/12/29/Git使用详解/</id>
    <published>2016-12-29T10:37:08.000Z</published>
    <updated>2016-12-30T11:14:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初识版本控制工具Git"><a href="#初识版本控制工具Git" class="headerlink" title="初识版本控制工具Git"></a>初识版本控制工具Git</h3><blockquote>
<p>Git是一个开源的分布式版本控制工具，由Linux操作系统的作者Linus Torvalds(林纳斯·托瓦兹)进行开发，其初衷是为了更好的管理Linux内核工程项目，而随着时间的发展，目前已被广泛应用于各种大中小型的项目中。</p>
</blockquote>
<p><strong>Git的工作原理图</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/GitProcess.jpg" alt=""></p>
<h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><ul>
<li>Linux系统</li>
</ul>
<blockquote>
<p>由于Linux和Git出自同一位作者，所以在Linux上是进行安装是最简单方便的，如果你是Ubuntu的系统，只需打开shell界面，输入：</p>
</blockquote>
<pre><code>sudo apt-get install git-core
</code></pre><blockquote>
<p>回车输入密码，即可完成Git的安装。</p>
</blockquote>
<ul>
<li>Windows和Mac系统</li>
</ul>
<blockquote>
<p>参考廖雪峰的官网的<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="external">这篇文章</a></p>
</blockquote>
<h4 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h4><p><strong>注意</strong></p>
<blockquote>
<p>虽说Git的操作可以在图形界面上进行操作，AS也支持图形化的形式操作Git，但还是建议在在命令行窗口进行相关操作。Git命令是在各种操作系统下通用技能，也是程序员必要的技能修养，图形化是你在Git命令熟练掌握后提升工作效率的工作方法。</p>
</blockquote>
<ul>
<li><p>配置一下你的身份，这样在提交代码的时候Git就可以知道是谁提交的</p>
<p>  git config –global user.name “sh2zqp”<br>  git config –global user.email “sh2zqp@gmail.com”</p>
</li>
<li><p>配置完成后，可以使用同样的命令来查看是否配置成功，只需将后面的名字和邮箱去掉</p>
<p>  git config –global user.name<br>  git config –global user.email </p>
</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_1.png" alt=""></p>
<blockquote>
<p>接着就可以开始创建代码仓库了，仓库(Repository)是用于保存版本管理所需信息的地方，所有本地提交的代码都会被提交到代码仓库中，如果有需要还可以再推送到远程仓库(如Github)中，这里尝试给LitePalDemo项目建立一个代码仓库。</p>
</blockquote>
<ul>
<li>首先进入到LitePalDemo项目的根目录下</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_2.png" alt=""></p>
<ul>
<li><p>然后在这个目录下，运行如下命令，进行代码仓库初始化</p>
<p>  git init</p>
</li>
</ul>
<blockquote>
<p>很简单，一行命令就可以完成创建代码仓库的操作，如下图</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_3.png" alt=""></p>
<blockquote>
<p>仓库创建完成后，会在LitePalDemo项目的根目录下生成一个隐藏的.git文件夹，这个文件夹就是用来记录本地所有的Git操作的，通过ls -al命令来查看，如下图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_4.png" alt=""></p>
<blockquote>
<p>如果想要删除本地仓库，只需要删除这个.git文件夹就ok了</p>
</blockquote>
<h4 id="提交本地代码"><a href="#提交本地代码" class="headerlink" title="提交本地代码"></a>提交本地代码</h4><blockquote>
<p>代码仓库建立完成之后就可以提交代码了，这里使用add和commit命令就可以了。add: 用于把想要提交的代码先添加进来，其可以接单个文件，单个目录，和 . ，commit: 是真正地去执行提交操作的命令。</p>
</blockquote>
<pre><code>git add build.gradle // 提交单个文件
git add app               // 提交单个目录
git add .                    // 全部提交
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_5.png" alt=""></p>
<blockquote>
<p>现在LitePalDemo项目下的所有文件都已经添加好了，下面就可以提交了</p>
</blockquote>
<pre><code>git commit -m &quot;First commit&quot;
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_6.png" alt=""></p>
<blockquote>
<p>commit命令后一定要通过 -m 来添加上本次提交的描述信息，没有该信息的话，本次提交会被认为是非法的。</p>
</blockquote>
<p><strong>Finished！</strong></p>
<h3 id="版本控制工具Git进阶"><a href="#版本控制工具Git进阶" class="headerlink" title="版本控制工具Git进阶"></a>版本控制工具Git进阶</h3><blockquote>
<p>上节已经完成了代码仓库的创建(git init)，和本地代码的提交(git add . 和git commit -m “First Commit”)，准备工作已经完成。</p>
</blockquote>
<h4 id="忽略文件-gitignore"><a href="#忽略文件-gitignore" class="headerlink" title="忽略文件.gitignore"></a>忽略文件.gitignore</h4><blockquote>
<p>在代码仓库创建完成后，在上节中我们直接通过git add . 和git commit -m “First Commit” 进行了本地代码提交，我们并没有考虑什么文件需要被提交，什么文件需要被忽略而不被提交，并不是所有文件都应该要被加入到版本控制当中。</p>
<p>比如Android项目结构下的build目录是每次编译项目时自动生成的，我们其实是没必要将这部分文件添加到版本控制当中，还有就是一些私密文件我们也是不希望加入到版本控制当中的。那么我们应该如何忽略这些文件呢？</p>
<p>Git提供了一种可配型很强的机制来让用户自己指定某些文件或目录，使它们被排除在版本控制之外，它会检查代码仓库的目录下是否存在一个名为.gitignore的文件，如果存在就去一行一行读取这个文件的内容，并把每一行指定的文件或目录给排除在版本控制之外。</p>
</blockquote>
<p><strong>注意</strong></p>
<blockquote>
<p>.gitignore中指定的文件或目录是可以使用“*”通配符的</p>
<p>AS在创建项目时其实已经自动帮助我们创建了两个.gitignore文件，一个在项目的根目录下，一个在app模块目录下：</p>
</blockquote>
<p><strong>/.gitignore</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_7.png" alt=""></p>
<p><strong>/app/.gitignore</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_8.png" alt=""></p>
<blockquote>
<p>这些内容都是AS自动生成的一些默认配置，通常这部分文件和目录是不需要添加到版本控制当中的。当然我们完全可以自己手动添加文件或目录，比如app模块下的所有测试文件只供我们自己使用，可以不添加到版本控制当中，就可以对/app/.gitignore文件进行修改如下：</p>
</blockquote>
<pre><code>/build
/src/test
/src/androidTest
</code></pre><blockquote>
<p>修改完成两个.gitignore文件后，就可以按照上节讲的两个add和commit命令进行本地代码的提交了</p>
</blockquote>
<pre><code>git add .
git commit -m &quot;First Commit&quot;
</code></pre><h4 id="查看修改内容"><a href="#查看修改内容" class="headerlink" title="查看修改内容"></a>查看修改内容</h4><blockquote>
<p>在进行了第一次代码提交后，后期我们会对自己的项目进行不断的维护与功能扩展，一般是没完成一个小功能就会进行一次代码提交。但如果某项功能牵扯到的代码过于多，有可能写到后面市已经忘记了前面修改了什么内容，遇到这种情况不用慌张，Git全帮我们记着，本部分就会学习如何使用Git来查看上次提交后文件修改的内容。</p>
</blockquote>
<ul>
<li><p>查看文件修改情况，只需要使用status命令就可以了，在项目根目录下输入：</p>
<p>  git status</p>
</li>
</ul>
<blockquote>
<p>如果提交代码后无任何修改</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_9.png" alt=""></p>
<blockquote>
<p>Git会提示我们项目中没有任何可提交的文件，现在对项目做一些修改，在查看</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_10.png" alt=""></p>
<blockquote>
<p>Git提醒我们MainActivity.java这个文件已经发生了更改，那么如何才能看到更改的内容呢？这就要借助diff命令了。</p>
</blockquote>
<pre><code>git diff
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_11.png" alt=""></p>
<blockquote>
<p>如果你只想查看某个指定文件的修改内容，如MainActivity.java，可以用如下命令：</p>
</blockquote>
<pre><code>git diff app/src/main/java/com/sh2zqp/litepaldemo/MainActivity.java
</code></pre><blockquote>
<p>因为项目就只有该文件被修改，效果和上图一样。其中减号代表删除部分，加好代表添加部分。</p>
</blockquote>
<h4 id="撤销未被提交的修改"><a href="#撤销未被提交的修改" class="headerlink" title="撤销未被提交的修改"></a>撤销未被提交的修改</h4><blockquote>
<p>有时候代码写的急，过于草率，以至于原有的功能会受到影响，遇到这种情况不用着急，只要代码还没有被提交，所有修改的内容都是可以撤销的。</p>
<p>还是上面的例子，我们就可以使用checkout命令来撤销未被提交的修改：</p>
</blockquote>
<pre><code>git checkout app/src/main/java/com/sh2zqp/litepaldemo/MainActivity.java
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_12.png" alt=""></p>
<blockquote>
<p>可以看到，当前项目中没有任何可提交的文件，说明撤销成功了。不过这种撤销方式只适用于那些还没有add的文件，如果某个文件已经被add了，这种方式是无效的。</p>
<p>先add，后status查看</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_13.png" alt=""></p>
<blockquote>
<p>现在checkout一下，你会发现依旧如上所示，无法撤销，MainActivity仍处于已添加状态。这种情况，我们需要把已添加的文件取消添加，然后才可以撤回提交，取消添加用reset命令</p>
</blockquote>
<pre><code>git reset HEAD app/src/main/java/com/sh2zqp/litepaldemo/MainActivity.java
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_14.png" alt=""></p>
<pre><code>git status
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_15.png" alt=""></p>
<blockquote>
<p>MainActivity文件就重新变回了未添加状态</p>
</blockquote>
<pre><code>git checkout app/src/main/java/com/sh2zqp/litepaldemo/MainActivity.java
git status
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_16.png" alt=""> </p>
<blockquote>
<p>MainActivity文件修改的内容就被撤销了</p>
</blockquote>
<h4 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h4><blockquote>
<p>当LitePalDemo项目开发很久之后，我们可能已经记不住上百次的提交操作了，估计你也已经忘了每次提交都修改了什么内容，没关系，Git一直默默的帮你记着，我们使用log命令来进行查看历史的提交信息，用法如下：</p>
</blockquote>
<pre><code>git log
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_17.png" alt=""></p>
<blockquote>
<p>可以看到，我们只进行了2次提交，所看到的信息比较少，每次提交记录包含了提交id，提交人，提交日期以及提交描述这些信息。然后我们再进行一次提交，把书目的价格改为55.55</p>
</blockquote>
<pre><code>git add .
git commit -m &quot;Change price&quot;
git log
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_18.png" alt=""></p>
<blockquote>
<p>当提交记录多的时候，如果我们只想查看其中的一条记录，可以在命令中指定该记录的id，并加上 -1 参数表示我们只想看到一行记录，如下：</p>
</blockquote>
<pre><code>git log b54866932d885b439711707628b742155de028ff -1
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_19.png" alt=""></p>
<blockquote>
<p>如果你想要查看提交记录具体修改了什么内容，可以在命令中加入 -p参数：</p>
</blockquote>
<pre><code>git log b54866932d885b439711707628b742155de028ff -1 -p
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_20.png" alt=""></p>
<blockquote>
<p>减号代表删除部分，加好代表添加部分</p>
</blockquote>
<p><strong>Finished!</strong></p>
<h3 id="版本控制工具的高级用法"><a href="#版本控制工具的高级用法" class="headerlink" title="版本控制工具的高级用法"></a>版本控制工具的高级用法</h3><p><strong>准备工作（项目根目录）</strong></p>
<pre><code>git init
git add .
git commit -m &quot;First Commit&quot;
</code></pre><h4 id="分支的用法"><a href="#分支的用法" class="headerlink" title="分支的用法"></a>分支的用法</h4><blockquote>
<p>分支是版本控制工具中比较高级且重要的概念，它的主要作用就是在现有代码基础上开辟一个分叉口，使得代码可以在主干线和分支干线上同时进行开发，且二者之间相互不影响，分支的工作原理如下：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_21.png" alt=""></p>
<p><strong>为什么需要建立新分支</strong></p>
<blockquote>
<p>正常情况下，我们在主干线上进行开发就可以了，完全不会有问题。不过一旦涉及到版本的情况，如果不建立分支的话，就会让你很头疼。例如，你开发了一款软件，并推出了初始的1.0版本，随着项目的进行，各种不同的新需求会不断的被提出来，我们会继续投入1.1版本的开发，经过一段时间的开发之后，有用户反映原先的1.0版本软件出现严重bug，所以我们需要对bug进行修复，并在此重写发布1.0版本，说起来很容易，你要知道你在1.0版本的基础上开发了1.1版本，在现有的代码基础上进行1.0版本的bug修复，再次发布1.0版本就会具有了还未发布的1.1版本功能，而且也会使得两个版本的代码相互混淆，很不方便。</p>
<p>这个时候，你就需要使用分支了，它使得以上问题得到解决。你只需要在1.0版本发布的时候在主分支上建立一个新的分支，然后在主分支上继续开发1.1版本的相关功能，当有1.0版本有bug出现时，就可以在新建分支上进行1.0版本的bug修复，然后再进行1.0版本软件的再发布，并记得将修改后的1.0版本代码与正在开发的1.1版本代码进行合并，既是将分支合并到主分支上。这样不仅可以轻松地解决1.0版本的bug修复，而且在分支合并到主分支后，也保证了主分支开发的1.1版本代码也已经修复了相关bug，当1.1版本开发完成发布后就不会存在同样的不过bug了。</p>
</blockquote>
<p><strong>所以说，分支很重要</strong></p>
<blockquote>
<p>下面学习Git中如何进行分支操作吧，分支，英文为branch</p>
</blockquote>
<ul>
<li><p>查看当前版本库当中有哪些分支</p>
<p>  git branch</p>
</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_22.png" alt=""></p>
<blockquote>
<p>可以看到只有一个master主分支，下面我们创建一个新的分支：</p>
</blockquote>
<pre><code>git branch version1.0
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_23.png" alt=""></p>
<blockquote>
<p>这样就创建了一个名为version1.0的分支，可以看到master前面有一个“*”号，说明我们目前在master分支上，那么我们如何切换到version1.0分支呢，checkout命令：</p>
</blockquote>
<pre><code>git checkout version1.0
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_24.png" alt=""></p>
<blockquote>
<p>可以看到已经切换到version1.0分支上，在version1.0分支上修改并提交代码不会影响到master分支的代码，反之也成立。所以我们在version1.0分支上修复了一个bug，在master分支上这个bug依旧存在，这时我们就需要进行合并操作，merge命令来完成合并分支操作，如下：</p>
<p>在version1.0分支上修改代码，然后进行如下操作，</p>
</blockquote>
<pre><code>git add .
git commit -m &quot;version1.0 branch change&quot;
git checkout master
git merge version1.0
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_25.png" alt=""></p>
<blockquote>
<p>在合并分支的时候会发现有代码冲突的情况，这个时候就需要你慢慢地找出这些冲突，Git就无能为力了。</p>
<p>当你不需要version1.0分支时，可以用如下命令删除version1.0分支</p>
</blockquote>
<pre><code>git branch -D version1.0
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/git_course_26.png" alt=""></p>
<h4 id="与远程版本库协作"><a href="#与远程版本库协作" class="headerlink" title="与远程版本库协作"></a>与远程版本库协作</h4><blockquote>
<p>如果你是一个人开发，其实使用版本控制工具Git远远无法发挥它真正强大的功能。版本控制工具Git最重要的一个特点就是为了进行团队协同开发的。每个开发者电脑上都有一份代码副本，当某个开发者在自己的电脑上编写完成了某个功能后，就将代码提交到服务器，其他开发者就只需要将服务器上的代码同步到本地，就能保证整个团队所有人的代码都一致。这样，团队的每个开发者就可以各司其职，大家来共同完成一个较为庞大的项目。</p>
<p>那如何使用Git来进行团队开发呢？这就需要一个远程的版本库，团队的每个开发者都从这个远程版本库进行原始代码的获取，然后各自开发，并且以后每次提交的代码都同步到远程版本库就ok了。另外，每个团队开发者要养成经常从远程版本库中获取最新代码的习惯，不然的话，大家的代码就有可能经常出现冲突。</p>
<p>假如，现在有一个远程版本库的Git地址是“<a href="https://github.com/sh2zqp/RunningPermission.git" target="_blank" rel="external">https://github.com/sh2zqp/RunningPermission.git</a>”,就可以使用如下命令来将代码下载到本地（版本库）：</p>
</blockquote>
<pre><code>git clone https://github.com/sh2zqp/RunningPermission.git
</code></pre><blockquote>
<p>之后，你在这份代码的基础上进行修改和提交，那么怎么样才能把本地修改的内容同步到远程版本库上呢？这就要借助push命令了：</p>
</blockquote>
<pre><code>git push origin master
</code></pre><blockquote>
<p>origin部分指定的就是远程版本库的Git地址，master部分指定的是同步到哪一分支上，上述命令就完成了将本地代码同步到<a href="https://github.com/sh2zqp/RunningPermission.git" target="_blank" rel="external">https://github.com/sh2zqp/RunningPermission.git</a>这个远程版本库的master分支上。</p>
<p>知道了将本地的修改同步到远程版本库上的方法，接下来我们看一下如何将远程版本库的修改同步到本地版本库。Git提供了两种命令来完成此功能，fetch和pull，fetch的语法规则与push差不多，如下：</p>
</blockquote>
<pre><code>git fetch origin master
</code></pre><blockquote>
<p>执行这个命令后，就会将远程版本库上的代码同步到本地，不过同步下来的代码并不会合并到任何分支上去，而是会存放在一个origin/master分支上，这时候我们就可以通过diff命令来查看远程版本库上到底修改了哪些东西：</p>
</blockquote>
<pre><code>git diff origin/master
</code></pre><p>之后再调用merge命令将origin/master分支上的修改合并到主分支即可，如下所示：</p>
<pre><code>git merge origin/master
</code></pre><blockquote>
<p>而pull命令则相当于将fetch和merge命令放在一起执行了，它可以从远程版本库上获取最新的代码并且合并到本地，如下：</p>
</blockquote>
<pre><code>git pull origin master
</code></pre><blockquote>
<p>现在感觉对远程版本库比较抽象，下节我们将更加深入的进行了解</p>
</blockquote>
<p><strong>Finished!</strong></p>
<h3 id="将代码托管到Github上"><a href="#将代码托管到Github上" class="headerlink" title="将代码托管到Github上"></a>将代码托管到Github上</h3><blockquote>
<p>经过前面三节的学习，本节我们会将项目托管到GitHub上</p>
<p><a href="https://github.com" target="_blank" rel="external">Github</a>是全球最大的代码托管网站，主要是借助Git来进行版本控制的。任何开源的软件都可以免费的将代码提交到GitHub上，以0陈本来进行代码的托管。</p>
</blockquote>
<ul>
<li>首先你要注册一个GitHub账号</li>
<li>然后再创建一个版本库（自动为我们创建.gitignore,LICENSE,README.md）</li>
<li>在本地用AS创建项目</li>
<li><p>进入本地项目的根目录，根据版本库的Git地址将远程版本库克隆到本地</p>
<p>  git clone 远程版本库Git地址</p>
</li>
<li><p>再进入到克隆下来文件夹目录，将这个目录里面的全部文件复制到本地项目的根目录下</p>
</li>
<li>删除克隆下来的文件夹</li>
<li><p>最后便可以把项目提交到远程代码库</p>
<p>  git add .<br>  git commit -m “first commit”<br>  git push origin master</p>
</li>
<li><p>Github可能需要进行用户名和密码的验证，输入注册时的用户名和密码就ok了</p>
</li>
<li>这样同步完成，远程代码库已经有了本地项目的代码了</li>
</ul>
<blockquote>
<p>详细过程请参考《第一行代码》第二版 （489-494）</p>
</blockquote>
<p><strong>Finished!</strong></p>
<p><strong>Git命令大图谱</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/git%E5%91%BD%E4%BB%A4.jpg" alt=""></p>
<p><strong>参考资料</strong></p>
<p>《第一行代码》第二版   —   郭霖<br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰Git教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;初识版本控制工具Git&quot;&gt;&lt;a href=&quot;#初识版本控制工具Git&quot; class=&quot;headerlink&quot; title=&quot;初识版本控制工具Git&quot;&gt;&lt;/a&gt;初识版本控制工具Git&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Git是一个开源的分布式版本控制工具，由L
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
      <category term="版本控制工具" scheme="http://yoursite.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>如何上传自己的Library到JCenter仓库</title>
    <link href="http://yoursite.com/2016/12/29/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E8%87%AA%E5%B7%B1%E7%9A%84Library%E5%88%B0JCenter%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2016/12/29/如何上传自己的Library到JCenter仓库/</id>
    <published>2016-12-29T04:31:52.000Z</published>
    <updated>2016-12-29T07:04:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在Android开发过程中一定会用到别人的库，比如squareup公司的OKHttp：</p>
</blockquote>
<pre><code>compile &apos;com.squareup.okhttp3:okhttp:3.4.1&apos;
</code></pre><blockquote>
<p>这样我们版本更新的时候只需要更改一下版本号就行，而不用去下载jar包，给开发带来了极大的便利，但如果我们自己想上传library供其他开发者使用呢？那么此教程会讨论几种不同的方式来一步步发布自己的library到JCenter仓库。</p>
</blockquote>
<h3 id="基于插件novoda-bintray-release的方式"><a href="#基于插件novoda-bintray-release的方式" class="headerlink" title="基于插件novoda/bintray-release的方式"></a>基于插件<a href="https://github.com/novoda/bintray-release" target="_blank" rel="external">novoda/bintray-release</a>的方式</h3><ul>
<li>第一步：新建一个Android Library类型的RPLibrary库，把其作为上传到远程JCenter仓库的本地第三方库</li>
</ul>
<blockquote>
<p>在AS中选择File->New->New Module,然后选择Android Library,新建一个Library。这里以新建RPLibrary为例子.</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/RPLibrary_jcenter_1.png" alt=""></p>
<p><strong> 注意这里的Library的名字需要后面的Package的名字保持一致</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/RPLibrary_jcenter_2.png" alt=""></p>
<blockquote>
<p>现在项目的结构如下图，接下来就是添加必要的<strong>Jcenter的依赖</strong>，为上传做准备。</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/RPLibrary_jcenter_3.png" alt=""></p>
<p><strong>如果你已经有了Android Library类型的库则可以忽略此步骤</strong></p>
<ul>
<li>第二步：注册账号</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/RPLibrary_jcenter_4.png" alt=""></p>
<blockquote>
<p>在bintray<a href="https://bintray.com/" target="_blank" rel="external">官网</a>注册账号，注册完成后验证邮箱，然后登陆进入首页把鼠标放到你的账户名上，选择弹出的Edit Profile选项</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/RPLibrary_jcenter_5.png" alt=""></p>
<blockquote>
<p>然后在界面的左侧选择Repositories选项，进入如下界面：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/RPLibrary_jcenter_6.png" alt=""></p>
<blockquote>
<p>接着选择Repositories仓库的maven，双击进入如下界面：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/RPLibrary_jcenter_7.png" alt="">  </p>
<blockquote>
<p>双击右侧的Add New Package新建一个Package，并在左侧填写Package名字（<strong>注意Package需要和你的Library的名字保持一致</strong>）</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/RPLibrary_jcenter_8.png" alt=""></p>
<blockquote>
<p>填写相应的库信息，（<strong>注意Name要和你的Library的名字保持一致</strong>，<strong>Licenses选择Apache-2.0</strong>，<strong>最后三个网址与你的项目在GitHub上的地址有关，相信不难理解（建议这样填写）</strong>），最后双击Create Package新建一个Package</p>
</blockquote>
<ul>
<li>第三步：添加依赖</li>
</ul>
<blockquote>
<p>在整个工程的build.gradle文件中添加classpath ‘com.novoda:bintray-release:0.4.0’,<strong>注意是整个工程的build.gradle</strong>。</p>
</blockquote>
<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.2.0&apos;
        // 基于插件[novoda/bintray-release]的方式
        classpath &apos;com.novoda:bintray-release:0.4.0&apos;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}
.....
</code></pre><blockquote>
<p>接着是在你自己Library（这里是RPLibrary）的build.gradle的文件中配置自己的信息，复制下面的脚本，改成你自己的信息即可</p>
</blockquote>
<pre><code>apply plugin: &apos;com.android.library&apos;
// 基于插件[novoda/bintray-release]的方式
apply plugin: &apos;com.novoda.bintray-release&apos;

// 基于插件[novoda/bintray-release]的方式
publish {
    userOrg = &apos;********&apos; //你的bintray用户名
    groupId = &apos;com.sh2zqp&apos;  //你的唯一的groupId，对应com.squareup.okhttp3:okhttp:3.4.1中的com.squareup.okhttp3
    artifactId = &apos;RPLibrary&apos; //你的library的名字，对应com.squareup.okhttp3:okhttp:3.4.1中的okhttp
    publishVersion = &apos;0.0.2&apos; //版本号
    desc = &apos;Android6.0+ RunningPermission Simple Use Way Library.&apos;
    website = &apos;https://github.com/sh2zqp/&apos; //建议填写github地址，不过不影响，这里做演示填的自己的网址

    bintrayUser = &apos;scinecehistory&apos; //你的bintray用户名
    bintrayKey = &apos;******************************&apos; //在你的bintray账户里面查找
}
</code></pre><p><strong> bintrayKey的获取方式如下图</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/RPLibrary_jcenter_9.png" alt=""></p>
<blockquote>
<p>经过上面的配置，上传JCenter成功后那么别人引用你的library的代码就为</p>
</blockquote>
<pre><code>compile &apos;com.sh2zqp:RPLibrary:0.0.2’
</code></pre><ul>
<li>第五步：上传到bintray的maven仓库</li>
</ul>
<blockquote>
<p>经过上面的配置，现在就可以传了，上传之前记得Sync一下Project,然后打开命令行，输入回车：</p>
</blockquote>
<pre><code>./gradlew clean build bintrayUpload -PdryRun=false
</code></pre><blockquote>
<p>然后等待几分钟，期间会联网下载依赖的库，最后如果没有问题，会显示BUILD SUCCESSFUL信息，然后去官网查看刚才建的Package，会发现多了你刚才上传的版本号。</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/RPLibrary_jcenter_10.png" alt=""></p>
<blockquote>
<p>点进去可以看到有三种引用方式</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/RPLibrary_jcenter_12.png" alt=""></p>
<blockquote>
<p>但是到这里还无法让别人通过<strong> compile ‘com.sh2zqp:RPLibrary:0.0.2</strong>引用，目前只是你自己的私人库。但可以通过如下方式来进行引用：</p>
<p>通过gradle脚本上传library到maven仓库，你可以在本地验证以下，需要进行在根目录的build.gradle配置：</p>
</blockquote>
<pre><code>allprojects {
    repositories {
        jcenter()
        maven {
            url &apos;https://dl.bintray.com/sciencehistory/maven/&apos;
        }
    }
}
</code></pre><blockquote>
<p>然后在主工程的build.gradle文件中添加如下依赖：</p>
</blockquote>
<pre><code>compile &apos;com.sh2zqp:RPLibrary:0.0.2&apos;
</code></pre><p><strong>url可以通过如下图获取</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/RPLibrary_jcenter_11.png" alt=""></p>
<ul>
<li>第六步：添加到JCenter仓库</li>
</ul>
<p><img src="https://segmentfault.com/image?src=http://7xp8c8.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160804234627.png&amp;objectId=1190000006186992&amp;token=2c5ed77232a8b4a43b17399b1f37538e" alt=""></p>
<p><img src="https://segmentfault.com/image?src=http://7xp8c8.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160804234750.png&amp;objectId=1190000006186992&amp;token=c5c266f182fa78e5954ffb571eaf5237" alt=""></p>
<blockquote>
<p>在上面的页面中点击Add To JCenter，然后随便填写一下Comments，点击Send，然后工作人员会审核和，你只需等待几个小时，然后会有站内消息提示你已经发布发到Jcenter，这样别人也可以引用你的Library，有没有很自豪的感觉！</p>
</blockquote>
<pre><code>compile &apos;com.sh2zqp:RPLibrary:0.0.2&apos;
</code></pre><ul>
<li>第七步：更新版本号</li>
</ul>
<blockquote>
<p>这个非常简单，当你的Library代码更改后，只需要更改一下上面的配置里面的<strong>publishVersion</strong>，运行./gradlew clean build bintrayUpload -PdryRun=false，就可以更新版本号了。这样，整个过程就结束了。</p>
</blockquote>
<p><strong>常见问题</strong></p>
<blockquote>
<p>如果你的Java doc含有中文导致上传失败，可以尝试在lib的build.gradle添加如下代码：</p>
</blockquote>
<pre><code>allprojects {
    tasks.withType(Javadoc) {
        options{
            encoding &quot;UTF-8&quot;
            charSet &apos;UTF-8&apos;
            links &quot;http://docs.oracle.com/javase/7/docs/api&quot;
        }
    }
}
</code></pre><p><strong><a href="https://github.com/sh2zqp/RunningPermission" target="_blank" rel="external">源码</a></strong></p>
<p><strong>参考资料</strong></p>
<p><a href="https://segmentfault.com/a/1190000006186992" target="_blank" rel="external">一步一步教你上传自己的 Library 到 JCenter</a><br> <a href="http://blog.csdn.net/wwj_748/article/details/51913280" target="_blank" rel="external">Android Library上传到JCenter仓库实践</a><br> <a href="http://blog.csdn.net/fengyuzhengfan/article/details/51407009" target="_blank" rel="external">教你轻松将Android library 发布到JCenter</a><br><a href="http://blog.csdn.net/wangdong20/article/details/50098535" target="_blank" rel="external">AndroidStudio怎么将开源项目发布到jcenter</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0623/3097.html" target="_blank" rel="external">如何使用Android Studio把自己的Android library分享到jCenter和Maven Central</a><br><a href="http://www.jianshu.com/p/0ba8960f80a9" target="_blank" rel="external">将Library上传到Jcenter</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在Android开发过程中一定会用到别人的库，比如squareup公司的OKHttp：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;compile &amp;apos;com.squareup.okhttp3:okhttp:3.4.1&amp;apo
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="AS" scheme="http://yoursite.com/tags/AS/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Library" scheme="http://yoursite.com/tags/Library/"/>
    
      <category term="JCenter" scheme="http://yoursite.com/tags/JCenter/"/>
    
  </entry>
  
  <entry>
    <title>AS如何打jar包和aar包</title>
    <link href="http://yoursite.com/2016/12/28/AS%E5%A6%82%E4%BD%95%E6%89%93jar%E5%8C%85%E5%92%8Caar%E5%8C%85/"/>
    <id>http://yoursite.com/2016/12/28/AS如何打jar包和aar包/</id>
    <published>2016-12-28T09:57:38.000Z</published>
    <updated>2016-12-29T07:09:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生成jar包"><a href="#生成jar包" class="headerlink" title="生成jar包"></a>生成jar包</h3><p><strong>在AS中可以通过修改gradle来处理</strong></p>
<blockquote>
<p>新建一个项目RunningPermissionDemo, 在该项目中新建一个类型为Android Library的Module: RunningPermissionLib, 如下图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/as_jar_1.png" alt=""></p>
<blockquote>
<p>app为我们的主工程, RunningPermissionLib是我们要将其生成jar包的Library. 在RunningPermissionLib与主工程的中的build.gradle文件中加入如下代码：</p>
</blockquote>
<ul>
<li><p>在主工程app的build.gradle中要加入RunningPermissionLib 这个Module的依赖：</p>
<p>  dependencies {</p>
<pre><code>compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)
androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, {
    exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;
})
compile &apos;com.android.support:appcompat-v7:24.2.1&apos;
testCompile &apos;junit:junit:4.12&apos;
compile project(&apos;:RunningPermissionLib&apos;)
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>当你编译完工程后其实RunningPermissionLib库的所有Java文件已经生成了包含class 的classes.jar包，如下图所示：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/as_jar_2.png" alt=""></p>
<ul>
<li>在RunningPermissionLib库中编写task进行jar生成</li>
</ul>
<blockquote>
<p>给出一个task方便将改classes.jar 导出到RunningPermissionLib库的build/libs/下，并修改名字为my.jar ( 名字随意)</p>
</blockquote>
<pre><code>//Copy类型
task makeJar(type: Copy) {
    //删除存在的
    delete &apos;build/libs/mysdk.jar&apos;
    //设置拷贝的文件
    from(&apos;build/intermediates/bundles/release/&apos;)
    //打进jar包后的文件目录
    into(&apos;build/libs/&apos;)
    //将classes.jar放入build/libs/目录下
    //include ,exclude参数来设置过滤
    //（我们只关心classes.jar这个文件）
    include(&apos;classes.jar&apos;)
    //重命名
    rename (&apos;classes.jar&apos;, &apos;RunningPermission.jar&apos;)
}

makeJar.dependsOn(build)
//在终端执行生成JAR包
// gradlew makeJar
</code></pre><ul>
<li>在AS提供的Terminal中（目录默认为当前工程的）键入： ./gradlew makeJar 回车看到如下所示就OK了</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/as_jar_3.png" alt=""></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/as_jar_4.png" alt=""></p>
<blockquote>
<p>生成的jar包在你的library那个的build下的libs下，然后就可以使用了</p>
</blockquote>
<p><strong>声明：打出来的jar只有源代码的.class 文件，不包含资源文件</strong></p>
<h3 id="生成aar包"><a href="#生成aar包" class="headerlink" title="生成aar包"></a>生成aar包</h3><blockquote>
<p>怎么把资源（图片，布局，string等）打进jar包呢？</p>
</blockquote>
<p><strong>答案</strong> </p>
<blockquote>
<p>既然不包含那我们就把jar包中用到的资源放到你使用该jar的工程里面，然后通过反射即可。 </p>
<p>这里给出反射类：</p>
</blockquote>
<pre><code>public class MResource {
    public static int getIdByName(Context context, String className, String resName) {
        String packageName = context.getPackageName();
        int id = 0;
        try {
            Class r = Class.forName(packageName + &quot;.R&quot;);
            Class[] classes = r.getClasses();
            Class desireClass = null;
            for (Class cls : classes) {
                if (cls.getName().split(&quot;\\$&quot;)[1].equals(className)) {
                    desireClass = cls;
                    break;
                }
            }
            if (desireClass != null) {
                id = desireClass.getField(resName).getInt(desireClass);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return id;
    }
}
</code></pre><blockquote>
<p>其实AS已经为我们提供的aar包，在编译完后就生成了aar了，而且也不用担心资源问题，你自己来可能会漏资源。 </p>
<p>生成的aar在你的library的／build／outputs／aar／</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/as_jar_5.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;生成jar包&quot;&gt;&lt;a href=&quot;#生成jar包&quot; class=&quot;headerlink&quot; title=&quot;生成jar包&quot;&gt;&lt;/a&gt;生成jar包&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;在AS中可以通过修改gradle来处理&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="jar" scheme="http://yoursite.com/tags/jar/"/>
    
      <category term="arr" scheme="http://yoursite.com/tags/arr/"/>
    
      <category term="AS" scheme="http://yoursite.com/tags/AS/"/>
    
  </entry>
  
  <entry>
    <title>阅读记录</title>
    <link href="http://yoursite.com/2016/12/22/%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2016/12/22/阅读记录/</id>
    <published>2016-12-22T05:28:07.000Z</published>
    <updated>2017-01-07T03:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2016-10-31"><a href="#2016-10-31" class="headerlink" title="2016.10.31"></a>2016.10.31</h3><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/1025/6699.html" target="_blank" rel="external">Android 多线程编程的总结</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/1014/6675.html" target="_blank" rel="external">[译]探索Android 大杀器——Handler</a>[2]<br><a href="http://www.open-open.com/lib/view/open1438065400878.html" target="_blank" rel="external">Android ORM 框架之 greenDAO 使用心得</a><br><a href="http://www.jianshu.com/p/4986100eff90" target="_blank" rel="external">GreenDao3.0简单使用</a><br><a href="http://yifeng.studio/2016/10/27/android-develop-30-things-that-experience-made-me-learn-the-hard-way/" target="_blank" rel="external">[译]开发安卓Apps，我所努力学习到的三十多条宝贵经验</a><a href="http://yifeng.studio/2016/10/27/android-develop-30-things-that-experience-made-me-learn-the-hard-way/" target="_blank" rel="external">5</a></p>
<h4 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h4><p><strong>无</strong></p>
<h3 id="2016-11-01"><a href="#2016-11-01" class="headerlink" title="2016.11.01"></a>2016.11.01</h3><h4 id="博客-1"><a href="#博客-1" class="headerlink" title="博客"></a>博客</h4><p><a href="http://blog.csdn.net/iispring/article/details/51661195" target="_blank" rel="external"> Okhttp使用详解</a></p>
<h4 id="书籍-1"><a href="#书籍-1" class="headerlink" title="书籍"></a>书籍</h4><p><strong>无</strong></p>
<h3 id="2016-11-02"><a href="#2016-11-02" class="headerlink" title="2016.11.02"></a>2016.11.02</h3><h4 id="博客-2"><a href="#博客-2" class="headerlink" title="博客"></a>博客</h4><p><a href="http://blog.csdn.net/lmj623565791/article/details/47911083" target="_blank" rel="external"> Android OkHttp完全解析 是时候来了解OkHttp了</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html" target="_blank" rel="external">OkHttp使用教程</a><br><a href="http://blog.csdn.net/iispring/article/details/51615631" target="_blank" rel="external">HTTPS理论基础及其在Android中的最佳实践</a><br><a href="http://limboy.me/tech/2011/02/19/https-workflow.html" target="_blank" rel="external">图解HTTPS</a><br><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="external">数字签名是什么？</a><br><a href="http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html" target="_blank" rel="external">密码学笔记</a><br> <a href="http://blog.csdn.net/lmj623565791/article/details/48129405" target="_blank" rel="external">Android Https相关完全解析 当OkHttp遇到Https</a><br><a href="http://www.jianshu.com/p/74d21a44323c" target="_blank" rel="external">设计模式-装饰者模式</a><br><a href="http://www.jianshu.com/p/f798c8b02348" target="_blank" rel="external">Android项目从零到上线的全过程</a><br><a href="http://www.jianshu.com/p/d9e4ddd1c530" target="_blank" rel="external">一个优秀的Android应用从建项目开始</a><br><a href="http://www.jianshu.com/p/fe9ccdf5d03b" target="_blank" rel="external">细读《失控》：送你一把瑞士军刀</a></p>
<h4 id="书籍-2"><a href="#书籍-2" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>《万历十五年》<br>《被误解的日本人》</p>
</blockquote>
<h3 id="2016-11-05"><a href="#2016-11-05" class="headerlink" title="2016.11.05"></a>2016.11.05</h3><h4 id="博客-3"><a href="#博客-3" class="headerlink" title="博客"></a>博客</h4><p><a href="http://blog.csdn.net/xiaanming/article/details/41084843" target="_blank" rel="external">Android 那些你所不知道的Bitmap对象详解</a><br><a href="http://www.jianshu.com/p/27bf1057f5aa" target="_blank" rel="external">带你学开源项目：OkHttp–自己动手实现OkHttp</a><br><a href="http://www.jianshu.com/p/47e72693a302" target="_blank" rel="external">带你学开源项目：Meizhi Android之RxJava &amp; Retrofit最佳实践</a><br><a href="http://www.jianshu.com/p/3141d4e46240" target="_blank" rel="external">Android网络请求心路历程</a><br><a href="http://blog.oneapm.com/apm-tech/344.html" target="_blank" rel="external">Android 网络请求详解</a><br><a href="http://gold.xitu.io/entry/5769f978d342d300580f4328" target="_blank" rel="external">OkHttpUtils 一个专注于让网络请求更简单的框架</a><a href="https://github.com/jeasonlzy/okhttp-OkGo" target="_blank" rel="external">(github)</a><br><a href="http://www.jianshu.com/p/e4670e9cfce9" target="_blank" rel="external">Java多线程深度探索</a></p>
<h4 id="书籍-3"><a href="#书籍-3" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>无</p>
</blockquote>
<h3 id="2016-11-07"><a href="#2016-11-07" class="headerlink" title="2016.11.07"></a>2016.11.07</h3><h4 id="博客-4"><a href="#博客-4" class="headerlink" title="博客"></a>博客</h4><p><a href="http://blog.csdn.net/jason0539/article/details/44956775" target="_blank" rel="external">23种设计模式汇总整理</a></p>
<h4 id="书籍-4"><a href="#书籍-4" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>《HTTP权威指南》<br>《Head First设计模式》<br>《大话设计模式》</p>
</blockquote>
<h3 id="2016-11-08"><a href="#2016-11-08" class="headerlink" title="2016.11.08"></a>2016.11.08</h3><h4 id="博客-5"><a href="#博客-5" class="headerlink" title="博客"></a>博客</h4><blockquote>
<p>无</p>
</blockquote>
<h4 id="书籍-5"><a href="#书籍-5" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>《大话设计模式》</p>
</blockquote>
<h3 id="2016-11-11"><a href="#2016-11-11" class="headerlink" title="2016.11.11"></a>2016.11.11</h3><h4 id="博客-6"><a href="#博客-6" class="headerlink" title="博客"></a>博客</h4><p><a href="http://blog.csdn.net/lpjishu/article/details/52665446" target="_blank" rel="external">Java泛型详解</a></p>
<h4 id="书籍-6"><a href="#书籍-6" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>《大话设计模式》</p>
</blockquote>
<h3 id="2016-11-13"><a href="#2016-11-13" class="headerlink" title="2016.11.13"></a>2016.11.13</h3><h4 id="博客-7"><a href="#博客-7" class="headerlink" title="博客"></a>博客</h4><p><a href="http://www.gcssloop.com/customview/dispatch-touchevent-theory" target="_blank" rel="external">安卓自定义View进阶-事件分发机制原理</a></p>
<h4 id="书籍-7"><a href="#书籍-7" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>《大话设计模式》</p>
</blockquote>
<h3 id="2016-12-01"><a href="#2016-12-01" class="headerlink" title="2016.12.01"></a>2016.12.01</h3><h4 id="博客-8"><a href="#博客-8" class="headerlink" title="博客"></a>博客</h4><p><a href="http://www.diycode.cc/topics/409" target="_blank" rel="external">手把手教你做个人 app</a><br><a href="http://www.jianshu.com/p/099c2c875524" target="_blank" rel="external">如何开发出一款仿映客直播APP项目实践篇 </a><br><a href="http://gold.xitu.io/post/583c242061ff4b006b59c7fb" target="_blank" rel="external">直接拿去用！每个App都会用到的LoadingLayout</a><br><a href="http://www.jianshu.com/p/d2f5ae6b4927" target="_blank" rel="external">WebView你真的熟悉吗？看了才知道</a></p>
<h4 id="书籍-8"><a href="#书籍-8" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>无</p>
</blockquote>
<h3 id="2016-12-12"><a href="#2016-12-12" class="headerlink" title="2016.12.12"></a>2016.12.12</h3><h4 id="博客-9"><a href="#博客-9" class="headerlink" title="博客"></a>博客</h4><p><a href="http://www.jianshu.com/p/f418bf95db2d" target="_blank" rel="external">掌握CoordinatorLayout</a><br><a href="http://www.jianshu.com/p/8dc11152f178" target="_blank" rel="external">如何给100亿个数字排序?</a><br><a href="http://www.jianshu.com/p/62f85f53ec16" target="_blank" rel="external">哈希分治法 - 统计海量数据中出现次数最多的前10个IP</a><br><a href="https://gold.xitu.io/post/584e7b298d6d81005456eb53" target="_blank" rel="external">Mysql 常用 SQL 语句集锦</a><br><a href="http://blog.csdn.net/u011507982/article/details/51199644" target="_blank" rel="external"> Android 自定义View合集</a><br><a href="https://gold.xitu.io/post/5846aee5ac502e006bb45d7e" target="_blank" rel="external">GitHub 使用</a><br><a href="http://www.jianshu.com/p/5f9b36a047e9" target="_blank" rel="external">Realm Java官方教程翻译(一)：Getting Started</a><br><a href="http://www.jianshu.com/p/99c98a02053e" target="_blank" rel="external">Realm Java官方教程翻译(二)：Getting Help及Models</a><br><a href="http://www.jianshu.com/p/d52a01af3d0a" target="_blank" rel="external">Realm Java官方教程翻译(三)：Relationships</a><br><a href="https://gold.xitu.io/post/58441c48c59e0d0056a30bc2" target="_blank" rel="external">Android 样式 (style) 和主题(theme)</a><br><a href="http://www.jianshu.com/p/5449656d56d2" target="_blank" rel="external">史上最高效的ORM方案——GreenDao3.0详解</a></p>
<h4 id="书籍-9"><a href="#书籍-9" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>《第一行代码》</p>
</blockquote>
<h3 id="2016-12-15"><a href="#2016-12-15" class="headerlink" title="2016.12.15"></a>2016.12.15</h3><h4 id="博客-10"><a href="#博客-10" class="headerlink" title="博客"></a>博客</h4><p><strong>MVP学习资源</strong></p>
<p><a href="http://hujiandong.com/2016/12/13/android-mvp-basic/" target="_blank" rel="external">Android 项目框架–MVP 基础</a><br><a href="http://www.jianshu.com/p/9a6845b26856" target="_blank" rel="external">Android MVP 详解（上）</a><br><a href="http://www.jianshu.com/p/0590f530c617" target="_blank" rel="external">Android MVP 详解（下）</a><br><a href="http://www.infoq.com/cn/articles/android-official-mvp-architecture-sample-project-analysis" target="_blank" rel="external">Android官方MVP架构示例项目解析</a></p>
<h4 id="书籍-10"><a href="#书籍-10" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>无</p>
</blockquote>
<h3 id="2016-12-20"><a href="#2016-12-20" class="headerlink" title="2016.12.20"></a>2016.12.20</h3><h4 id="博客-11"><a href="#博客-11" class="headerlink" title="博客"></a>博客</h4><p><a href="http://www.jianshu.com/p/1d84ba23f4d2" target="_blank" rel="external">Dagger2 入门,以初学者角度</a><br><a href="https://gold.xitu.io/post/5858a8f3b123db00658b1191" target="_blank" rel="external">探索日期滚轮控件的源码</a></p>
<h4 id="书籍-11"><a href="#书籍-11" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>无</p>
</blockquote>
<h3 id="2016-12-22"><a href="#2016-12-22" class="headerlink" title="2016.12.22"></a>2016.12.22</h3><h4 id="博客-12"><a href="#博客-12" class="headerlink" title="博客"></a>博客</h4><p><a href="http://blog.kaush.co/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/" target="_blank" rel="external">用RxJava来实现Otto—RxBus</a></p>
<h4 id="书籍-12"><a href="#书籍-12" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>无</p>
</blockquote>
<h3 id="2017-01-06"><a href="#2017-01-06" class="headerlink" title="2017.01.06"></a>2017.01.06</h3><h4 id="博客-13"><a href="#博客-13" class="headerlink" title="博客"></a>博客</h4><p><a href="http://blog.csdn.net/caiwenfeng_for_23/article/details/8373569" target="_blank" rel="external">tools:context=”.MainActivity的作用</a><br><a href="http://blog.csdn.net/xiabing082/article/details/50563559" target="_blank" rel="external">android基础–tools:context=”.MainActivity”作用</a><br><a href="https://www.kancloud.cn/qibin0506/android-md/117682" target="_blank" rel="external">你所不知道的Activity转场动画</a><br><a href="http://blog.csdn.net/u012702547/article/details/51289789" target="_blank" rel="external">Android5.0之Activity的转场动画</a><br><a href="https://my.oschina.net/vvcumt/blog/388185" target="_blank" rel="external">Android 转场动画 windowAnimation和ActivityAnimation的区别</a></p>
<h4 id="书籍-13"><a href="#书籍-13" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>无</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2016-10-31&quot;&gt;&lt;a href=&quot;#2016-10-31&quot; class=&quot;headerlink&quot; title=&quot;2016.10.31&quot;&gt;&lt;/a&gt;2016.10.31&lt;/h3&gt;&lt;h4 id=&quot;博客&quot;&gt;&lt;a href=&quot;#博客&quot; class=&quot;headerli
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="阅读" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
</feed>
