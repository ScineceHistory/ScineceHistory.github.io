<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sh2zqp</title>
  <subtitle>Keep Learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-12-28T10:53:28.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>QinPeng Zhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dagger2 入门详解</title>
    <link href="http://yoursite.com/2016/12/28/Dagger2%20%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3%20-%202/"/>
    <id>http://yoursite.com/2016/12/28/Dagger2 入门详解 - 2/</id>
    <published>2016-12-28T10:53:07.000Z</published>
    <updated>2016-12-28T10:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Dagger2"><a href="#什么是Dagger2" class="headerlink" title="什么是Dagger2"></a>什么是Dagger2</h2><blockquote>
<p>Dagger2是Android中<strong>比较热门</strong>的<strong>依赖注入框架</strong>，而Android开发当前非常流行框架就是<strong>MVP模式</strong>了，Dagger2的目标便是将MVP中的V和P 进一步解耦，达到模块化最大的解耦，使得代码更容易维护。</p>
</blockquote>
<p><strong>Google官方主页介绍</strong></p>
<blockquote>
<p>Dagger is a fully static, compile-time dependency injection framework for both Java and Android. It is an adaptation of an earlier version created by Square and now maintained by Google.<br>Dagger aims to address many of the development and performance issues that have plagued reflection-based solutions. More details can be found in this talk(slides) by +Gregory Kick.</p>
</blockquote>
<p><strong>翻译理解</strong></p>
<blockquote>
<p>Dagger是为Android和Java平台提供的一个完全静态的，在编译时进行依赖注入的框架。 早期的版本由Square公司进行改编，现在由Google进行维护。<br>Dagger旨在解决基于反射带来的开发和性能上的问题（因为Dagger并没有用反射来做依赖注入）。更多详细内容可以看一下<a href="https://plus.google.com/+GregoryKick/" target="_blank" rel="external">Gregory Kicktalk</a>这个人的<a href="https://www.youtube.com/watch?v=oK_XtfXPkqw" target="_blank" rel="external">talk</a>。</p>
</blockquote>
<p><strong>通俗理解</strong></p>
<blockquote>
<p>其实就是告诉我们Dagger可以用来进行依赖注入，搞过Spring的人肯定都知道这是啥，SpringMVC里用到了大量依赖注入，下面聊一聊<strong>依赖注入</strong>。</p>
</blockquote>
<h2 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h2><p><strong>维基百科</strong></p>
<blockquote>
<p><strong>控制反转</strong>(Inversion of Control，缩写为<strong>IoC</strong>)，是面向对象编程中的一种<strong>设计原则</strong>，可以用来<strong>降低计算机代码之间的耦合度</strong>。其中最常见的方式叫做依赖注入(Dependency Injection，简称DI)，还有一种方式叫“依赖查找”(Dependency Lookup)。通过控制反转，对象在被创建的时候，由一个调度者调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p>
</blockquote>
<p><strong>通俗理解</strong></p>
<blockquote>
<p>当一个类中需要依赖其他对象时,不需要你亲自为那些需要依赖的对象赋值,为那些对象赋值的操作交给了<strong>IOC框架</strong>(如Dagger2)。例如，我们在做项目时，经常需要在一个对象里去创建另一个对象的示例，这种行为是<strong>产生耦合</strong>的常见形式，对于一个大型项目来说，过多的相互依赖会导致代码难以维护，很容易就会碰到修改一个小需求需要大面积的修改各种代码，特别是代码原来不是自己维护的，麻烦会更大。</p>
</blockquote>
<h2 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h2><blockquote>
<p>有一家咖啡店CoffeeShop，向顾客提供咖啡，我们非常容易明白咖啡店CoffeeShop是不能自己生产咖啡给顾客的，他们只能通过不同咖啡制作方法来生产咖啡供顾客饮用，此时抽象一个接口CoffeeMaker。</p>
</blockquote>
<h3 id="传统做法"><a href="#传统做法" class="headerlink" title="传统做法"></a>传统做法</h3><ul>
<li><p>业务核心类是CoffeeShop，通过CoffeeMaker负责生产Coffee并进行售卖</p>
<p>  /**</p>
<ul>
<li>这是一个售卖Coffee的例子</li>
<li>CoffeeMaker是对生成Coffee过程的一个封装</li>
<li><p>制作Coffee需要实现CoffeeMaker的produceCoffee方法<br>*/<br>public class CoffeeShop {</p>
<p> private CoffeeMaker mCoffeeMachine;</p>
<p> public CoffeeShop(CoffeeMaker coffeeMachine) {</p>
<pre><code>mCoffeeMachine = new SimpleCoffeeMachine();
</code></pre><p> }</p>
<p> public String provideCoffee() {</p>
<pre><code>return mCoffeeMachine.produceCoffee();
</code></pre><p> }<br>}</p>
</li>
</ul>
</li>
<li><p>Coffee的实际生产接口CoffeeMaker</p>
<p>  public interface CoffeeMaker {</p>
<pre><code>String produceCoffee(); // 实际生成咖啡的方法
</code></pre><p>  }</p>
</li>
<li><p>实际的Coffee生产者，下面是简单的咖啡机SimpleCoffeeMachine</p>
<p>  public class SimpleCoffeeMachine implements CoffeeMaker {</p>
<pre><code>@Override
public String produceCoffee() {
    return &quot;Coffee is made by SimpleCoffeeMachine&quot;;
}
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>刚开始咖啡都是咖啡机做出来的，这家咖啡店很简单，在CoffeeShop中可以看到，CoffeeShop持有了一个CoffeeMaker生产接口，而具体制作Coffee的过程是由实现了CoffeeMaker的自动咖啡机SimpleCoffeeMachine实现的，CoffeeMaker是在构造方法中new 出了一个实现CoffeeMaker接口的SimpleCoffeeMachine。当前的功能很简单，这么写看着也没什么问题。</p>
<p>随着业务的扩展，消费人群改变了，自动咖啡机SimpleCoffeeMachine也完全不能满足现有客户的需求，这个时候我们的CoffeeShop该进行业务升级。</p>
</blockquote>
<ul>
<li><p>雇佣<strong>咖啡师</strong>CoffeeCooker来制作咖啡。</p>
<p>  public class CoffeeCooker {</p>
<pre><code>private String mName; // 咖啡师名字
private String MCoffeeType; // 生产的Coffee类型

public CoffeeCooker(String name, String MCoffeeType) {
    mName = name;
    this.MCoffeeType = MCoffeeType;
}

public String produceCoffee() {
    return mName + &quot;制作了&quot; + MCoffeeType + &quot;的Coffee.&quot;;
}
</code></pre><p>  }</p>
</li>
<li><p>此时要升级SimpleCoffeeMachine了</p>
<p>  public class SimpleCoffeeMachine implements CoffeeMaker {<br>  //    @Override<br>  //    public String produceCoffee() {<br>  //        return “Coffee is made by SimpleCoffeeMachine”;<br>  //    }</p>
<pre><code>// 升级后
private CoffeeCooker mCoffeeCooker;

public SimpleCoffeeMachine(CoffeeCooker coffeeCooker) {
    mCoffeeCooker = coffeeCooker;
}
@Override
public String produceCoffee() {
    return mCoffeeCooker.produceCoffee();
}
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>基于目前的情况，我们制作咖啡的流程发生了变化，原来的业务随着CoffeeCooker的加入发生了改变，但细心的小伙伴会发现目前还有一个地方受到了影响，那就是我们的CoffeeShop，</p>
</blockquote>
<pre><code>public class CoffeeShop {

    private CoffeeMaker mCoffeeMaker;

//    public CoffeeShop(CoffeeMaker coffeeMachine) {
//        mCoffeeMachine = new SimpleCoffeeMachine();
//    }

    // 升级后
    public CoffeeShop(CoffeeCooker coffeeCooker) {
        mCoffeeMaker = new SimpleCoffeeMachine(coffeeCooker);
    }

    public String provideCoffee() {
        return mCoffeeMaker.produceCoffee();
    }
}
</code></pre><blockquote>
<p>我们的SimpleCoffeeMachine升级了，业务波动影响到了我们的CoffeeShop，这时候不得不对CoffeeShop也进行修改。这时候我们的CoffeeShop就懵逼了，你SimpleCoffeeMachine业务升级就升级呗，为毛我制造CoffeeShop的过程也要变动，非常的不愿意，但迫于老板的压力。最后还是给整改了。很明显，这是一个<strong>不合适的流程</strong>，简单的一个业务的升级，还要我们对整个咖啡店进行修改，那如果业务非常复杂，引用了SimpleCoffeeMachine的可不仅仅是CoffeeShop一个，那是不是每个引用的地方都需要进行修改，业务庞大的情况下，这种修改就是致命的，不仅需要做大量没有意义的体力劳动来修改，还可能导致大片业务代码的变动直接<strong>增加测试的成本</strong>，其他接收这个需求的开发人员直接得跪键盘了，一个S SimpleCoffeeMachine的改动对CoffeeShop产生了直接的影响，肯定有什么地方是不对的。原因就是CoffeeShop里的SimpleCoffeeMachine是<strong>自己new出来的</strong>。这就是一个很不好的地方。这种糟糕的<strong>实例引用的方式</strong>我们称之为<strong>硬初始化（Hard init）</strong>，和<strong>硬编码（Hard coding）</strong>一样，都是糟糕代码滋生的好方法，Hard init不仅增加了<strong>各个模块的耦合</strong>，还让<strong>单元测试</strong>变得<strong>更加困难</strong>了。</p>
</blockquote>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote>
<p>那么该用什么方法来尽量地<strong>降低各个模块的耦合</strong>，避免<strong>new对象</strong>带来的问题呢。我们知道，类的初始化可以<strong>描述成new</strong>,get和set，new就是我们上面说的Hard init，容易增加各个模块之间的耦合，而<strong>get，则可以看做是工厂模式</strong>，工厂模式是new的一个<strong>升级版本</strong>，相对硬初始化来说，工厂模式把<strong>对象的创建都集中在工厂</strong>里了，对于需要依赖的类来说，无需再考虑对象的创建工作了，只需要关注如何从工厂里获得，在发生修改时也不会有太多的改动，和以前的方案比起来要好了不少。但工厂模式的对象创建依然非常的不灵活，对象的实现<strong>完全取决于工厂</strong>，会导致原来的<strong>依赖由具体的对象</strong>变为<strong>依赖相应的工厂</strong>，本质上还是有依赖关系的！！！对，工厂模式并没有改变本质的<strong>依赖关系</strong>，而且，对于简单职责的工厂来说，抽出一层工厂似乎并不会太麻烦，但当我们的工厂中提供的类的实现复杂起来时，又回到了最初的问题上，我们是在工厂中new对象还是继续给工厂中的内容再提供一个工厂呢，这种层层嵌套会让我们的代码变得干涩难懂，也会有<strong>设计过度</strong>的嫌疑，工厂模式在解决依赖问题还是有点尴尬。</p>
</blockquote>
<h3 id="手动依赖注入"><a href="#手动依赖注入" class="headerlink" title="手动依赖注入"></a>手动依赖注入</h3><blockquote>
<p>那么最后还有一个<strong>set</strong>，也就是我们的<strong>依赖注入</strong>了，依赖注入的依赖是<strong>从外部传递过来的</strong>，而且在Java平台上很多时候都是通过<strong>反射或者动态编译</strong>来提供<strong>依赖注入</strong>，这样就更加剥离的各个部分的耦合性，也让上述两种方式只能望其项背了。</p>
<p>依赖注入主要有三种途径：</p>
</blockquote>
<pre><code>public class CoffeeShopWithInjection implements InjectMaker {

    private CoffeeMaker mCoffeeMaker;

    // 第1种依赖注入方式: 构造器注入
    public CoffeeShopWithInjection(CoffeeMaker coffeeMaker) {
        mCoffeeMaker = coffeeMaker;
    }

    // 第2种依赖注入方式: Setter注入
    public void setCoffeeMaker(CoffeeMaker coffeeMaker) {
        mCoffeeMaker = coffeeMaker;
    }

    // 第3种依赖注入方式: 接口注入
    @Override
    public void injectMaker(CoffeeMaker coffeeMaker) {
        mCoffeeMaker = coffeeMaker;
    }

    public String produceCoffee() {
        return mCoffeeMaker.produceCoffee();
    }
}
</code></pre><blockquote>
<p>InjectMarker接口内容如下：</p>
</blockquote>
<pre><code>public interface InjectMaker {
    void injectMaker(CoffeeMaker coffeeMaker);
}
</code></pre><blockquote>
<p>依赖注入的最基本的原理比较容易理解，就是不要在需要依赖的类中通过<strong>new</strong>来创建依赖而是<strong>通过方法提供的参数注入进来</strong>，这样我们的需要依赖的类和提供依赖的类的实现方法分隔开了。不过这种<strong>手动提供依赖</strong>也是很繁杂的工作，充满的浓浓的重复体力劳动的气息，如何来尽量减少这些冗余代码的制作呢，答案就是下一部分。</p>
</blockquote>
<h3 id="依赖注入框架-Dagger2"><a href="#依赖注入框架-Dagger2" class="headerlink" title="依赖注入框架(Dagger2)"></a>依赖注入框架(Dagger2)</h3><blockquote>
<p>一般的IOC框架都是通过<strong>反射</strong>来实现的,但Dagger2作为Android端的IOC框架,为了不影响性能,它是通过<strong>apt动态生成代码</strong>来实现的.</p>
</blockquote>
<h4 id="Dagger2主要分为三个模块"><a href="#Dagger2主要分为三个模块" class="headerlink" title="Dagger2主要分为三个模块"></a>Dagger2主要分为三个模块</h4><ul>
<li>依赖提供方Module,负责提供依赖中所需要的对象,实际编码中类似于<strong>工厂类</strong></li>
<li>依赖需求方实例,它声明依赖对象,它在实际编码中对应<strong>业务类</strong>,例如Activity,当你在Activity中需要某个对象时,你只要在其中<strong>声明</strong>就行,声明的方法在下面会讲到</li>
<li>依赖注入组件Component,负责将对象注入到依赖需求方,它在实际编码中是<strong>一个接口</strong>,编译时Dagger2会自动为它生成一个实现类</li>
</ul>
<h4 id="Dagger2的主要工作流程"><a href="#Dagger2的主要工作流程" class="headerlink" title="Dagger2的主要工作流程"></a>Dagger2的主要工作流程</h4><ul>
<li>将依赖需求方实例传入给Component实现类</li>
<li>Component实现类根据依赖需求方实例中<strong>依赖声明</strong>,来确定该实例需要依赖哪些对象</li>
<li>确定依赖对象后,Component会在与自己关联的<strong>Module类</strong>中查找有没有提供<strong>这些依赖对象的方法</strong>,有的话就将Module类中提供的对象<strong>设置到依赖需求方实例中</strong></li>
</ul>
<blockquote>
<p>通俗上来讲就好比你现在需要一件衣服,自己做太麻烦了,你就去商店买,你跟商店老板说明你想要购买的类型后,商店老板就会在自己的衣服供应商中查找有没有你所说的类型,有就将它卖给你.其中<strong>你就对应上面所说的依赖需求方实例</strong>,你只要说明你需要什么,<strong>商店老板则对应Component实现类</strong>,负责满足别人的需求,而<strong>衣服供应商则对应Module类</strong>,他负责生产衣服.也许这里有点绕,但经过下面的Demo,也许能够帮助你理解.</p>
</blockquote>
<h4 id="在项目中引入Dagger2"><a href="#在项目中引入Dagger2" class="headerlink" title="在项目中引入Dagger2"></a>在项目中引入Dagger2</h4><p><strong>在项目下的build.gradle文件中添加apt插件</strong></p>
<pre><code>buildscript {
    ...
    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.2.2&apos;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
        //添加apt插件
        classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;
    }
}
...
</code></pre><p><strong>在app目录的build.gradle文件中添加</strong></p>
<pre><code>apply plugin: &apos;com.android.application&apos;
//应用apt插件,一定要放在下面
apply plugin: &apos;com.neenbedankt.android-apt&apos;
...
dependencies {
    ...
    //引入dagger2
    compile &apos;com.google.dagger:dagger:2.4&apos;
    apt &apos;com.google.dagger:dagger-compiler:2.4&apos;
    //java注解
    provided &apos;org.glassfish:javax.annotation:10.0-b28&apos;
}
</code></pre><h4 id="Module类注入方式"><a href="#Module类注入方式" class="headerlink" title="Module类注入方式"></a>Module类注入方式</h4><p><strong>编写布料类Cloth</strong></p>
<blockquote>
<p>写一个Cloth类用作依赖对象,它包含一个color属性</p>
</blockquote>
<pre><code>public class Cloth {
    private String color;

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return color + &quot;布料&quot;;
    }
}
</code></pre><p><strong>书写Module类</strong></p>
<blockquote>
<p>现在的需求是MainActivity中需要使用到Cloth对象,所以我们要为MainActivity书写一个Module类用来提供Cloth对象,相当于创建了一个<strong>提供商</strong></p>
</blockquote>
<pre><code>@Module
public class MainModule {
    @Provides
    public Cloth getCloth() {
        Cloth cloth = new Cloth();
        cloth.setColor(&quot;红色&quot;);
        return cloth;
    }
}
</code></pre><blockquote>
<p>嗯?怎么多了两个注解?这两个注解有什么用呢?<br><strong>注解</strong>是Dagger2中的关键,编写<strong>Module类</strong>时要在该类上声明<strong>@Module</strong>以表明该类是Module类,这样Dagger2才能识别,那<strong>@Provides</strong>又是干嘛的呢?它的作用是声明Module类中<strong>哪些方法是用来提供依赖对象的</strong>,当<strong>Component类</strong>需要<strong>依赖对象</strong>时,他就会根据<strong>返回值的类型</strong>来在<strong>有@Provides注解的方法中选择调用哪个方法</strong>.在一个方法上声明@Provides注解,就相当于创建了<strong>一条生产线</strong>,这条生产线的产物就是方法的<strong>返回值类型</strong>.有了这条生产线,供应商就能<strong>提供这种类型的商品</strong>了,当商店老板（Component类）发现有人（依赖需求方）需要这种类型的商品时,<strong>供应商Module</strong>就可以提供给他了。</p>
</blockquote>
<p><strong>书写Component接口</strong></p>
<pre><code>@Component(modules = MainModule.class)
public interface MainComponent {
    void inject(MainActivity mainActivity);
}
</code></pre><blockquote>
<p>和Module类一样,<strong>Component类</strong>也是需要注解声明的,那个注解就是<strong>@Component</strong>,但是@Component注解的作用可<strong>不是单单用来声明Component类</strong>,他还有更强大的功能,@Component注解有<strong>modules和dependencies</strong>两个属性,这两个属性的类型都是<strong>Class数组</strong>,modules的作用就是<strong>声明该Component含有哪几个Module</strong>,即有几个供应商,当Component需要<strong>某个依赖对象</strong>时,就会通过<strong>这些Module类中对应的方法</strong>获取依赖对象,MainComponent中只包含<strong>MainModule</strong>,所以令modules=MainModule.class,<strong>相当于供应商和商店老板确定合作关系的合同</strong>.而<strong>dependencies属性则是声明Component类的依赖关系</strong>,这个下面再详讲.</p>
<p><strong>接口中那个方法</strong>又是干嘛用的呢?</p>
<p>我们现在只是声明了Component类,但我们要怎么将<strong>Component类和依赖需求方</strong>对象联合起来呢?答案就是通过这个<strong>inject方法</strong>,这个方法可以将依赖需求方对象送到Component类中,Component类就会根据<strong>依赖需求方对象中声明的依赖关系</strong>来<strong>注入依赖需求方对象中所需要的对象</strong>,本Demo中<strong>MainActivity（依赖需求方）</strong>中需要<strong>Cloth对象</strong>,所以我们通过inject方法将MainActivity实例传入到MainComponent中,MainComponent就会从MainModule中的getCloth方法获取Cloth实例,并将该实例赋值给MainActivity中的cloth字段.相当于你去商店的道路,没有这条路,<strong>你就无法去商店和老板说明你所需要的东西</strong>.但是这里需要注意的是,<strong>inject方法的参数不能用子类来接收,例如本Demo中,如果inject的参数是Activity,那么Dagger2就会报错.</strong></p>
</blockquote>
<p><strong>在MainActivity中声明</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private TextView mTextView;
    @Inject
    Cloth mCloth;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mTextView = (TextView) findViewById(R.id.tv);

        MainComponent build = DaggerMainComponent.builder()
                .mainModule(new MainModule())
                .build();
        build.inject(this);

        mTextView.setText(&quot;我现在有&quot; + mCloth);
    }
}
</code></pre><blockquote>
<p>上面代码中有两处关键:</p>
</blockquote>
<ul>
<li><strong>声明依赖对象Cloth</strong>,就是在cloth字段上添加<strong>@Inject</strong>注解,Dagger2中<strong>声明依赖对象</strong>都是通过@Inject注解,但是@Inject注解的字段不能是<strong>private和protected的</strong>. </li>
<li>通过Dagger2自动生成的类来创建<strong>Component的实现类</strong>,创建时需要传入该Component实现类所需要的<strong>Module类实例</strong>,传入方法就是调用Module类类名首字母小写对应的方法.这里我们通过Dagger2自动生成的<strong>DaggerMainComponent</strong>类创建了MainComponent的实例,相当于我们创建了一个实实在在的商店,不再是理论上的商店,但是创建商店一定也要创建真实的供应商嘛,所以创建Component实现类时一定要<strong>传入Module的实例.</strong>(注意编写完Component接口后Dagger2并不会自动创建对应的类,需要我们点击Android Studio中bulid菜单下的Rebulid Poject选项,或者直接书写代码,编译时Dagger2就会帮你自动生成).<br>  再将MainActivity通过inject方法发送到MainComponent中,调用完<strong>inject方法</strong>后,你就会发现,MainActivity中的<strong>mCloth字段已经被赋值</strong>,而且该mCloth对应的就是我们在<strong>MainModule类getCloth方法中创建的Cloth对象.</strong></li>
</ul>
<p><strong>运行结果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1818011-f8884b1f3c71e61d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="注解依赖对象注入方式"><a href="#注解依赖对象注入方式" class="headerlink" title="注解依赖对象注入方式"></a>注解<strong>依赖对象</strong>注入方式</h4><blockquote>
<p>前面的例子可能给人最大的感受就是麻烦吧?就是为mCloth赋个值,又要写什么Module类,又是要写什么Component接口.其实Dagger2还可以用注解来提供依赖对象.让我们来瞧瞧怎么使用.</p>
</blockquote>
<p><strong>创建依赖类Shoe</strong></p>
<blockquote>
<p>我们又创建一个依赖类Shoe</p>
</blockquote>
<pre><code>public class Shoe {
    @Inject
    public Shoe() {}

    @Override
    public String toString() {
        return &quot;鞋子&quot;;
    }
}
</code></pre><blockquote>
<p>但是这次我们创建的方<strong>式和Cloth不一样了</strong>,我们在<strong>构造函数上声明了@Inject注解</strong>,这个注解有什么用呢?作用可大了,<strong>当Component在所拥有的Module类中找不到依赖需求方需要类型的提供方法时</strong>,Dagger2就会检查该需要类型的<strong>有没有用@Inject声明的构造方法</strong>,<strong>有则用该构造方法创建一个</strong>.</p>
<p>相当于你去商店购买东西,你需要的东西商店的供应商不生产,商店老板就只好帮你去网上看看有没有你需要的东西,有则帮你网购一个.</p>
</blockquote>
<p><strong>在MainActivity中声明Shoe依赖</strong></p>
<blockquote>
<p>我们修改之前的MainActivity,添加一点东西</p>
</blockquote>
<pre><code>public class MainActivity extends AppCompatActivity {
    private TextView mTextView;
    @Inject
    Cloth mCloth;
    @Inject
    Shoe mShoe;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mTextView = (TextView) findViewById(R.id.tv);

        MainComponent build = DaggerMainComponent.builder()
                .mainModule(new MainModule())
                .build();
        build.inject(this);

        //mTextView.setText(&quot;我现在有&quot; + mCloth);
        mTextView.setText(&quot;我现在有&quot; + mCloth + &quot;和&quot; + mShoe);
    }
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1818011-e9598e0d6581d92f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>注意</strong></p>
<blockquote>
<p>有些读者可能会这样想:为什么不都用这种方法来声明呢?为什么要用Module类?<br>答案是这样的,项目中我们会用到<strong>别人的jar包</strong>,我们无法修改别人的源码,就更别说<strong>在人家的类上添加注解了</strong>,所以我们只能通过Module类来提供.</p>
</blockquote>
<h4 id="复杂一点的使用情况"><a href="#复杂一点的使用情况" class="headerlink" title="复杂一点的使用情况"></a>复杂一点的使用情况</h4><blockquote>
<p>我们创建的这些<strong>依赖类</strong>都<strong>不用依赖于其它依赖类</strong>,但是如果需要依赖于其它依赖类又要怎么弄呢?</p>
</blockquote>
<p><strong>创建依赖类Clothes</strong></p>
<blockquote>
<p>我们又来创建一个<strong>衣服类Clothes</strong>,制作衣服时<strong>需要布料</strong>,所以我们在创建Clothes的实例时需要<strong>用到Cloth实例</strong>(依赖到Cloth类)</p>
</blockquote>
<pre><code>public class Clothes {
    private Cloth cloth;
    public Clothes(Cloth cloth) {
        this.cloth = cloth;
    }
    public Cloth getCloth() {
        return cloth;
    }
    @Override
    public String toString() {
        return cloth.getColor() + &quot;衣服&quot;;
    }
}
</code></pre><p><strong>在Module类中增加提供方法</strong></p>
<blockquote>
<p>现在我们的MainActivity中需要<strong>依赖于Clothes对象</strong>,所以我们在MianModule中<strong>添加提供Clothes对象的方法</strong>,但是<strong>Clothes需要依赖于Cloth对象</strong>,这要怎么办呢?可能最先想到的办法就是这样:</p>
</blockquote>
<pre><code>@Provides
    public Clothes getClothes() {
        Cloth cloth = new Cloth();
        cloth.setColor(&quot;红色&quot;);
        return new Clothes(cloth);
}
</code></pre><blockquote>
<p>直接在方法中创建一个Cloth不就得了,但是你有没有发现,创建Cloth的代码已经在<strong>getCloth方法中有了</strong>,我们能不能用getCloth方法中创建的Cloth实例来创建Clothes实例呢?</p>
<p>Dagger2提供了这样的功能,我们只要在getClothes方法中<strong>添加Cloth参数</strong>,Dagger2就会像帮<strong>依赖需求方找依赖对象一样帮你找到该方法依赖的Cloth实例</strong>,所以我们代码可以这样改:</p>
</blockquote>
<pre><code>@Provides
    public Clothes getClothes(Cloth cloth) {
        return new Clothes(cloth);
}
</code></pre><p><strong>在MainActivity中声明Clothes依赖</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {
    ...
    @Inject
    Clothes clothes;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        tv.setText(&quot;我现在有&quot; + cloth + &quot;和&quot; + shoe + &quot;和&quot; + clothes);
    }
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1818011-edb92a97c1ae2c15.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>同理,在带有@Inject注解的构造函数要是依赖于其它对象,Dagger2也会帮你自动注入.</p>
</blockquote>
<p><strong> 创建依赖类Shirt</strong></p>
<pre><code>public class Shirt {
    Cloth mCloth;
    @Inject
    public Shirt(Cloth cloth) {
        mCloth = cloth;
    }
    @Override
    public String toString() {
        return mCloth + &quot;T恤&quot;;
    }
}
</code></pre><p><strong>在MainActivity中声明Shirt依赖</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {
    ...
    @Inject
    Shirt mShirt;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        mTextView.setText(&quot;我现在有&quot; + mCloth + &quot;和&quot; + mShoe + &quot;和&quot; + mClothes + &quot;和&quot; + mShirt);
    }
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo1.png" alt=""></p>
<h4 id="依赖总结"><a href="#依赖总结" class="headerlink" title="依赖总结"></a>依赖总结</h4><blockquote>
<p>引用<a href="https://dreamerhome.github.io/2016/07/07/dagger/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">依赖注入神器：Dagger2详解系列</a>中的一段话:<br>我们有<strong>两种方式可以提供依赖</strong>，一个是<strong>注解了@Inject的构造方法</strong>，一个是在<strong>Module里提供的依赖</strong>，那么Dagger2是怎么选择依赖提供的呢，规则是这样的：</p>
</blockquote>
<ul>
<li>步骤1：查找Module中是否存在创建该类的方法</li>
<li>步骤2：若存在创建类方法，查看该方法是否存在参数<ul>
<li>步骤2.1：若存在参数，则按从步骤1开始依次初始化每个参数</li>
<li>步骤2.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束</li>
</ul>
</li>
<li>步骤3：若不存在创建类方法，则查找Inject注解的构造函数，看构造函数是否存在参数<ul>
<li>步骤3.1：若存在参数，则从步骤1开始依次初始化每个参数</li>
<li>步骤3.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束</li>
</ul>
</li>
</ul>
<p><strong>也就说Dagger2会递归的提供依赖</strong></p>
<h4 id="Named和-Qulifier注解的使用"><a href="#Named和-Qulifier注解的使用" class="headerlink" title="@Named和@Qulifier注解的使用"></a>@Named和@Qulifier注解的使用</h4><p><strong>@Named</strong></p>
<blockquote>
<p>假设我们现在又有了新的需求,MainActivity中需要<strong>两种布料</strong>,分别是红布料和蓝布料,但我们的MainModule类中只能提供红布料,怎么办呢?<br>读者可能会想:在MainModule类中再添加一个提供蓝布料的方法不就行了:</p>
</blockquote>
<pre><code>@Provides
public Cloth getRedCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;红色&quot;);
    return cloth;
}
@Provides
public Cloth getBlueCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;蓝色&quot;);
    return cloth;
}
</code></pre><blockquote>
<p>可问题就来了,Dagger2<strong>是通过返回值类型来确定的</strong>,当你需要红布料时,它又怎么知道哪个是红布料呢?所以Dagger2为我们提供<strong>@Named</strong>注解,它怎么使用呢?它有一个value值,<strong>用来标识这个方法是给谁用的</strong>.修改我们的代码:</p>
</blockquote>
<pre><code>@Provides
@Named(&quot;red&quot;)
public Cloth getRedCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;红色&quot;);
    return cloth;
}
@Provides
@Named(&quot;blue&quot;)
public Cloth getBlueCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;蓝色&quot;);
    return cloth;
}
</code></pre><blockquote>
<p>我们在getRedCloth方法上使用<strong>@Named(“red”)表明此方法返回的是红布料</strong>,同理,在<strong>getBlueCloth方法上使用@Named(“blue”)</strong>表明此方法返回的是蓝布料,接下我们只要在MainActivity中的布料字段上<strong>同样使用@Named注解</strong>,就可以<strong>一一配对</strong>了.</p>
</blockquote>
<pre><code>public class MainActivity extends AppCompatActivity {
    ...
    @Inject
    @Named(&quot;red&quot;)
    Cloth redCloth;
    @Inject
    @Named(&quot;blue&quot;)
    Cloth blueCloth;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        tv.setText(&quot;我现在有&quot; + mRedCloth + &quot;和&quot; + mBlueCloth );
    }
}
</code></pre><blockquote>
<p>在redCloth上用@Named(“red”)标记后,他就会对应Module中对应的方法.</p>
</blockquote>
<p><strong>运行结果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1818011-2fcd4ed5a6a53f9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>@Qulifier</strong></p>
<blockquote>
<p>@Qulifier功能和@Named一样,并且@Named就是继承@Qulifier的,我们要怎么使用@Qulifier注解呢?答案就是自定义一个注解:</p>
</blockquote>
<pre><code>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface RedCloth {
}
</code></pre><blockquote>
<p>有了这个注解,我们就可以用它在替换掉上面的@Named(“red”),效果是一样的.</p>
</blockquote>
<p><strong>略</strong></p>
<blockquote>
<p>而且这两个注解还能使用在依赖参数上,比如这个:</p>
</blockquote>
<pre><code>@Provides
 public Clothes getClothes(@Named(&quot;blue&quot;) Cloth cloth){
     return new Clothes(cloth);
 }
</code></pre><blockquote>
<p>效果和上面说明的一样,进入这个方法的cloth由上面有@Named(“blue”)的方法提供</p>
</blockquote>
<h4 id="Singleton和-Scope的使用"><a href="#Singleton和-Scope的使用" class="headerlink" title="@Singleton和@Scope的使用"></a>@Singleton和@Scope的使用</h4><p><strong>@Singleton</strong></p>
<blockquote>
<p>假设现在MainActivity中需要依赖Clothes和Cloth,我们在MainModule中提供这两个类的提供方法:</p>
</blockquote>
<pre><code>@Provides
@Named(&quot;blue&quot;)
public Cloth getBlueCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;蓝色&quot;);
    return cloth;
}
@Provides
public Clothes getClothes(@Named(&quot;blue&quot;) Cloth cloth) {
    return new Clothes(cloth);
}
</code></pre><blockquote>
<p>接着在MainActivity中声明</p>
</blockquote>
<pre><code>mTextView.setText(&quot;mBlueCloth=mClothes中的mBlueCloth吗?:&quot; + (mBlueCloth == mClothes.getCloth()));
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo2.png" alt=""></p>
<blockquote>
<p>你会发现,MainActivity中的<strong>Cloth对象</strong>和<strong>Clothes中的Cloth对象</strong>并<strong>不是同一个对象</strong>,注入过程中,对mBlueCloth注入时会调用一次getBlueCloth方法,<strong>创建了一个Cloth对象</strong>;注入mClothes时又会调用一次getBlueCloth方法,这时<strong>又会创建一个Cloth对象</strong>,所以才会出现上面的结果.但是如果需要MainActivity中的mBlueCloth对象和mClothes中的mBlueCloth对象是<strong>同一个对象</strong>又要怎么办呢?Dagger2为我们提供了<strong>@Singleton</strong>注解,和名字一样,这个注解的作用就是<strong>声明单例模式</strong>,我们先看看它怎么使用,下面再讲原理.</p>
</blockquote>
<p><strong>首先,在getRedCloth方法上添加该注解</strong></p>
<pre><code>@Provides
@Named(&quot;blue&quot;)
@Singleton
public Cloth getBlueCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;蓝色&quot;);
    return cloth;
}
</code></pre><p><strong>再在MainComponent接口上添加该注解</strong></p>
<pre><code>@Singleton
@Component(modules = MainModule.class)
public interface MainComponent {
    void inject(MainActivity mainActivity);
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo3.png" alt=""></p>
<blockquote>
<p>有没有发现,MainActivity中的Cloth对象和Clothes中的Cloth对象是同一个对象了,是不是很神奇!</p>
</blockquote>
<p><strong>Scope</strong></p>
<blockquote>
<p>@Singleton是怎么实现的呢?我们先看看<strong>@Scope注解</strong>,弄懂它,@Singleton你也就会明白了,下面我们就来分析分析<br>顾名思义,@Scope就是用来<strong>声明作用范围的</strong>.@Scope和@Qulifier一样,需要我们<strong>自定义注解才能使用,</strong>我们先自定义一个注解:</p>
</blockquote>
<pre><code>@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface PreActivity {
}
</code></pre><blockquote>
<p>这个注解有什么用呢?答案就是<strong>声明作用范围</strong>,当我们将这个注解使用在Module类中的Provide方法上时,就是声明这个Provide方法是在PerActivity作用范围内的,并且当一个Component要引用这个Module时,必须也要声明这个Component是PerActivity作用范围内的,否则就会报错,声明方法也很简单,就是在Component接口上使用这个注解.但是我们声明这个作用范围又有什么用呢?</p>
<p>原来Dagger2有这样一个机制:在同一个作用范围内,Provide方法<strong>提供的依赖对象就会变成单例</strong>,也就是说依赖需求方不管依赖几次Provide方法提供的依赖对象,Dagger2都<strong>只会调用一次这个方法</strong>.就和上面那个例子一样,正常情况下,在注入MainActivity中的mBlueCloth对象时会调用一次getBlueCloth方法,注入mClothes对象时因为依赖Cloth对象,所以又会调用一次getBlueCloth方法,导致这两个Cloth对象并不是同一个实例.但是我们给它<strong>声明作用范围</strong>后,这两次对Cloth的依赖<strong>只会调用一次getBlueCloth方法</strong>,这样这两个Cloth对象就是同一实例了,这样就保证了在给MainActivity注入时,所有声明的<strong>Cloth</strong>依赖都是指向同一个实例.(注意:只有Module类中声明了作用范围的Provide方法才能实现单例,没声明的方法就不是单例的)</p>
<p>查看源码你会发现Singleton其实是<strong>继承@Scope注解的</strong>,所以你知道了Singleton是怎么实现单例模式的吧.</p>
<p>可能有些读者可能会问,Dagger2既然有了Singleton为什么还要我们<strong>自定义PerActivity注解</strong>?这就涉及到<strong>代码可读性</strong>了,当<strong>依赖需求方是Activity</strong>时,我们可以自定义一个PerActivity注解,当<strong>依赖需求方是Fragment时</strong>,我们又可以自定义一个PerFragment注解,这样我们就能清楚的区分依赖对象的提供目标了.</p>
<p>那我们通过<strong>构造函数提供依赖的方式又要怎么声明作用范围</strong>呢?答案就是在<strong>类名上使用注解标明</strong>,<strong>切记不要在构造函数上用注解标明,这样是无效的</strong>.<br>读者可以试试用PerActivity注解代替上面例子中的Singleton注解,你会发现效果是一样的.</p>
<p><strong>注意注意注意</strong>:单例是在<strong>同一个Component实例提供依赖的前提下才有效的</strong>,<strong>不同的Component实例只能通过Component依赖才能实现单例</strong>.也就是说,你虽然在两个Component接口上都添加了PerActivity注解,但是这两个Component提供依赖时是<strong>没有联系</strong>的,他们<strong>只能在各自的范围内实现单例</strong>.(下面会降到)</p>
</blockquote>
<h4 id="组件依赖dependencies的使用"><a href="#组件依赖dependencies的使用" class="headerlink" title="组件依赖dependencies的使用"></a>组件依赖dependencies的使用</h4><blockquote>
<p>在实际开发中,我们经常会使用到工具类,工具类一般在<strong>整个App的生命周期内都是单例的</strong>,我们现在给我们的Demo添加一个工具类ClothHandler:</p>
</blockquote>
<pre><code>public class ClothHandler {
    public Clothes handle(Cloth cloth){
        return new Clothes(cloth);
    }
}
</code></pre><blockquote>
<p>它的功能就是<strong>将cloth加工成clothes,</strong>假设我们现在有<strong>两个Activity</strong>中都要使用该工具类,我们要怎么使用Dagger2帮我们注入呢?</p>
<p>我们先用上面所学的方法试试,先在MainModule中添加提供方法:</p>
</blockquote>
<pre><code>@Module
public class MainModule {
     .....
    @PerActivity
    @Provides
    public ClothHandler getClothHandler(){
        return new ClothHandler();
    }
}
</code></pre><blockquote>
<p>再在MainActivity中声明依赖</p>
</blockquote>
<pre><code>public class MainActivity extends AppCompatActivity {
        .....   
    @Inject
    ClothHandler mClothHandler;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ......
    mTextView.setText(&quot;红布料加工后变成了&quot; + mClothHandler.handle(mRedCloth) + &quot;\nmClothHandler地址:&quot; + mClothHandler);
    }
    //在布局文件中声明的点击方法
    public void onclick(View view) {
        Intent intent = new Intent(this,SecondActivity.class);
        startActivity(intent);
    }
}
</code></pre><blockquote>
<p>同理在书写第二个Activity,并为它书写Module类Component接口</p>
</blockquote>
<pre><code>public class SecondActivity extends AppCompatActivity {
    private TextView tv;
    @Inject
    Cloth mBlueCloth;
    @Inject
    ClothHandler mClothHandler;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
        tv = (TextView) findViewById(R.id.tv2);
        SecondComponent component = DaggerSecondComponent.builder()
                .secondModule(new SecondModule())
                .build();
        component.inject(this);
        tv.setText(&quot;蓝布料加工后变成了&quot; + mClothHandler.handle(mBlueCloth) + &quot;\nmClothHandler地址:&quot; + mClothHandler);
    }
}

@Module
public class SecondModule {
    @PreActivity
    @Provides
    public Cloth getBlueCloth(){
        Cloth cloth = new Cloth();
        cloth.setColor(&quot;蓝色&quot;);
        return cloth;
    }
    @PreActivity
    @Provides
    public ClothHandler getClothHandler(){
        return new ClothHandler();
    }
}

@Component(modules = SecondModule.class)
@PreActivity
public interface SecondComponent {
    void inject(SecondActivity secondActivity);
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo4.png" alt=""><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo5.png" alt=""></p>
<blockquote>
<p>你会发现,虽然我们成功的将ClothHandler注入到了这两个Activity中,但是你会发现,这两个Activity中的ClothHandler<strong>实例不是一样的</strong>(验证了上面那个结论),并且我们发现这种注入方式要在每一个Module中都要提供getClothHandler方法, 假如有20个Activity都需要用到ClothHandler,那我们都这样写,不就代码重复了吗.并且我们还要实现单例,怎么办呢?Dagger2很贴心的为我们<strong>提供了Component依赖</strong>,就能完美的解决这个问题.</p>
<p>在面向对象的思想中,我们碰到这种情况一般都要<strong>抽取父类,</strong>Dagger2也是用的这种思想,我们先创建一个<strong>BaseModule</strong>,用来提供工具类:</p>
</blockquote>
<pre><code>@Module
public class BaseModule {
    @Singleton //单例
    @Provides
    public ClothHandler getClothHandler(){
        return new ClothHandler();
    }
}
</code></pre><blockquote>
<p>在创建一个BaseComponent接口:</p>
</blockquote>
<pre><code>@Singleton
@Component(modules = BaseModule.class)
public interface BaseComponent {
    ClothHandler getClothHandler();
}
</code></pre><blockquote>
<p>嗯?</p>
<p>这个Component怎么有点不一样,怎<strong>么没有inject方法呢?</strong>上面讲过,我们通过inject方法依赖需求方实例送到Component中,从而帮助依赖需求方实现依赖,但是我们<strong>这个BaseComponent是给其他Component提供依赖的</strong>,所以我们就可以不用inject方法,但是BaseComponent中多了一个<strong>getClothHandler方法,它的返回值是ClothHandler对象</strong>,这个方法有什么用呢?它的作用就是告诉<strong>依赖于BaseComponent的Component</strong>,<strong>BaseComponent能为你们提供ClothHandler对象</strong>,如果没有这个方法,BaseComponent就不能提供ClothHandler对象(这个提供规则和上面的依赖规则相同,可以实现单例).既然有了BaseComponent,那我们就可在其它Component中依赖它了.我们删除MainModule和SecondModule中的getClothHandler方法即可。</p>
<p>接下来在MainComponent和SecondComponent中声明依赖,就要用到@Component中的dependencies属性了:</p>
</blockquote>
<pre><code>@PreActivity
@Component(modules=MainModule.class,dependencies = BaseComponent.class)
public interface MainComponent {
    void inject(MainActivity mainActivity);
}

@PreActivity
@Component(modules = SecondModule.class,dependencies = BaseComponent.class)
public interface SecondComponent {
    void inject(SecondActivity secondActivity);
}
</code></pre><blockquote>
<p>下面我们用Android Studio中build菜单下的Rebuild Object选项后,你会发现创建MainComponent和SecondComponent实例时多了一个baseComponent方法:</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo6.png" alt=""> <img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo7.png" alt=""></p>
<blockquote>
<p>这个方法需要我们传入一个<strong>BaseComponent实例</strong>,原因很简单,MainComponent和SecondComponent既然<strong>依赖BaseComponent</strong>,肯定需要你传入一个<strong>BaseComponent实例</strong>给它,它才能从BaseComponent实例中获取到它需要的对象嘛.但是需要注意的是,如果要MainComponent和SecondComponent依赖到的对象是同一个的话(<strong>也就是单例</strong>),创建它们是<strong>传入的BaseComponent实例也必须是同一个</strong>,上面说过,不同的Component实例是无法提供相同的依赖实例的,因为它们之间是没有联系的.这样的话,我们就需要在MainActivity和SecondActivity中能获取到同一个BaseComponent实例,怎么样能实现呢?很多人一开始都会想到用<strong>静态工厂</strong>,这种方法可行,但是我们一般都会自定义一个<strong>Application类</strong>,用它来提供BaseComponent实例,因为在<strong>整个App生命周期内都只有一个Application实例</strong>,所以其中的BaseComponent实例也不会变.我们自定义一个MyApplication类</p>
</blockquote>
<pre><code>public class MyApplication extends Application {
    private BaseComponent baseComponent;
    @Override
    public void onCreate() {
        super.onCreate();
        baseComponent = DaggerBaseComponent.builder().baseModule(new BaseModule()).build();
    }

    public BaseComponent getBaseComponent() {
        return baseComponent;
    }
}
</code></pre><blockquote>
<p>我们在onCreate方法中创建BaseComponent实例,并对外提供获取方法.<br>这种方式还有一种好处,就是当我们在BaseModule中需要用到Application实例时,我们就可以在创建BaseModule时传入this.</p>
<p>接下来在AndroidManifest.xml中声明我们新建的MyApplication</p>
<p>接下来修改MainActivity和SecondActivity中的代码</p>
</blockquote>
<pre><code>MainComponent build = DaggerMainComponent
                .builder()
                .baseComponent(((MyApplication)getApplication()).getBaseComponent())
                .mainModule(new MainModule())
                .build();

SecondComponent component = DaggerSecondComponent
                .builder()
                .baseComponent(((MyApplication)getApplication()).getBaseComponent())
                .secondModule(new SecondModule())
                .build();
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo8.png" alt=""><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo9.png" alt=""></p>
<blockquote>
<p>我们成功的将ClothHandler注入到了这两个Activity中,并且还实现了单例.(注意:这里能实现单例跟BaseComponent中声明了@Singleton有很大关系,因为BaseComponent都没有单例的话,外部依赖它的Component就更不可能单例了).</p>
</blockquote>
<h4 id="Component的生命周期"><a href="#Component的生命周期" class="headerlink" title="Component的生命周期"></a>Component的生命周期</h4><blockquote>
<p>一般情况下我们都是在Activity的onCreate方法中创建Component实例,再调用inject方法完成依赖.所以Component依赖可以分为三个过程:</p>
</blockquote>
<ul>
<li><p>创建Component实例</p>
<p>  MainComponent component = DaggerMainComponent</p>
<pre><code>.builder()
.baseComponent(((MyApplication)getApplication()).getBaseComponent())
.mainModule(new MainModule())
.build();
</code></pre></li>
<li><p>调用inject方法</p>
<p>  component.inject(this);</p>
</li>
</ul>
<blockquote>
<p>调用完这个方法整个依赖就完成了.</p>
</blockquote>
<ul>
<li>Component实例被销毁</li>
</ul>
<blockquote>
<p>onCreate()方法调用完成后,Component实例就会因为没有被引用而被垃圾回收器回收.其中传入给Component实例的Module实例也会一同被回收,这也就能说明不同的Component实例之间是没有联系的(Component依赖除外).</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>至此,Dagger2<strong>基础</strong>已讲完,对于Dagger2在项目中的使用方法,可以参考github上的开源项目.</p>
<p>最后我们引用一下<a href="http://blog.piasy.com/2016/04/11/Dagger2-Scope-Instance/" target="_blank" rel="external">Dagger2 Scope 注解能保证依赖在 component 生命周期内的单例性吗？</a>中的注意事项:</p>
</blockquote>
<ul>
<li>component 的 inject 函数不要声明基类参数；</li>
<li>Scope 注解必须用在 module 的 provide 方法上，否则并不能达到局部单例的效果；</li>
<li>如果 module 的 provide 方法使用了 scope 注解，那么 component 就必须使用同一个注解，否则编译会失败；</li>
<li>如果 module 的 provide 方法没有使用 scope 注解，那么 component 和 module 是否加注解都无关紧要，可以通过编译，但是没有局部单例效果；</li>
<li>对于直接使用 @Inject 构造函数的依赖，如果把 scope 注解放到它的类上，而不是构造函数上，就能达到局部单例的效果了；</li>
<li>被依赖的Component能提供某个对象时,一定要在接口中声明以该对象为返回值的方法(也就是<strong>暴露接口</strong>).这样依赖它的Component才能获取到这种对象.</li>
</ul>
<blockquote>
<p><a href="https://github.com/sh2zqp/Dagger2Demo" target="_blank" rel="external">源码入口</a></p>
</blockquote>
<p><strong>参考资料</strong></p>
<p><a href="https://google.github.io/dagger/" target="_blank" rel="external">Google官方介绍</a><br><a href="https://dreamerhome.github.io/2016/07/07/dagger/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">依赖注入神器：Dagger2详解系列</a><br><a href="http://www.jianshu.com/p/1d84ba23f4d2" target="_blank" rel="external">Dagger2 入门,以初学者角度</a><br><a href="https://github.com/luxiaoming/dagger2Demo" target="_blank" rel="external">Dagger2图文完全教程</a><br><a href="http://blog.piasy.com/2016/04/11/Dagger2-Scope-Instance/" target="_blank" rel="external">Dagger2 Scope 注解能保证依赖在 component 生命周期内的单例性吗？</a><br><a href="https://github.com/codeestX/GeekNews" target="_blank" rel="external">GeekNews</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Dagger2&quot;&gt;&lt;a href=&quot;#什么是Dagger2&quot; class=&quot;headerlink&quot; title=&quot;什么是Dagger2&quot;&gt;&lt;/a&gt;什么是Dagger2&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Dagger2是Android中&lt;strong&gt;比
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="注解" scheme="http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="Dagger2" scheme="http://yoursite.com/tags/Dagger2/"/>
    
      <category term="依赖注入" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="Ioc" scheme="http://yoursite.com/tags/Ioc/"/>
    
      <category term="控制反转" scheme="http://yoursite.com/tags/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2016/12/28/AS%E5%A6%82%E4%BD%95%E6%89%93jar%E5%8C%85%E5%92%8Caar%E5%8C%85/"/>
    <id>http://yoursite.com/2016/12/28/AS如何打jar包和aar包/</id>
    <published>2016-12-28T09:57:38.000Z</published>
    <updated>2016-12-28T10:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: AS如何打jar包和aar包 # 这是标题<br>categories:  # 这里写的分类会自动汇集到 categories 页面上，分类可以多级</p>
<ul>
<li>学习记录  # 二级分类<br>tags:   # 这里写的标签会自动汇集到 tags 页面上 </li>
<li>AS      # 可配置多个标签，注意格式</li>
<li>jar</li>
<li>aar</li>
</ul>
<hr>
<hr>
<h3 id="生成jar包"><a href="#生成jar包" class="headerlink" title="生成jar包"></a>生成jar包</h3><p><strong>在AS中可以通过修改gradle来处理</strong></p>
<blockquote>
<p>新建一个项目RunningPermissionDemo, 在该项目中新建一个类型为Android Library的Module: RunningPermissionLib, 如下图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/as_jar_1.png" alt=""></p>
<blockquote>
<p>app为我们的主工程, RunningPermissionLib是我们要将其生成jar包的Library. 在RunningPermissionLib与主工程的中的build.gradle文件中加入如下代码：</p>
</blockquote>
<ul>
<li><p>在主工程app的build.gradle中要加入RunningPermissionLib 这个Module的依赖：</p>
<p>  dependencies {</p>
<pre><code>compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)
androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, {
    exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;
})
compile &apos;com.android.support:appcompat-v7:24.2.1&apos;
testCompile &apos;junit:junit:4.12&apos;
compile project(&apos;:RunningPermissionLib&apos;)
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>当你编译完工程后其实RunningPermissionLib库的所有Java文件已经生成了包含class 的classes.jar包，如下图所示：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/as_jar_2.png" alt=""></p>
<ul>
<li>在RunningPermissionLib库中编写task进行jar生成</li>
</ul>
<blockquote>
<p>给出一个task方便将改classes.jar 导出到RunningPermissionLib库的build/libs/下，并修改名字为my.jar ( 名字随意)</p>
</blockquote>
<pre><code>//Copy类型
task makeJar(type: Copy) {
    //删除存在的
    delete &apos;build/libs/mysdk.jar&apos;
    //设置拷贝的文件
    from(&apos;build/intermediates/bundles/release/&apos;)
    //打进jar包后的文件目录
    into(&apos;build/libs/&apos;)
    //将classes.jar放入build/libs/目录下
    //include ,exclude参数来设置过滤
    //（我们只关心classes.jar这个文件）
    include(&apos;classes.jar&apos;)
    //重命名
    rename (&apos;classes.jar&apos;, &apos;RunningPermission.jar&apos;)
}

makeJar.dependsOn(build)
//在终端执行生成JAR包
// gradlew makeJar
</code></pre><ul>
<li>在AS提供的Terminal中（目录默认为当前工程的）键入： ./gradlew makeJar 回车看到如下所示就OK了</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/as_jar_3.png" alt=""></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/as_jar_4.png" alt=""></p>
<blockquote>
<p>生成的jar包在你的library那个的build下的libs下，然后就可以使用了</p>
</blockquote>
<p><strong>声明：打出来的jar只有源代码的.class 文件，不包含资源文件</strong></p>
<h3 id="生成aar包"><a href="#生成aar包" class="headerlink" title="生成aar包"></a>生成aar包</h3><blockquote>
<p>怎么把资源（图片，布局，string等）打进jar包呢？</p>
</blockquote>
<p><strong>答案</strong> </p>
<blockquote>
<p>既然不包含那我们就把jar包中用到的资源放到你使用该jar的工程里面，然后通过反射即可。 </p>
<p>这里给出反射类：</p>
</blockquote>
<pre><code>public class MResource {
    public static int getIdByName(Context context, String className, String resName) {
        String packageName = context.getPackageName();
        int id = 0;
        try {
            Class r = Class.forName(packageName + &quot;.R&quot;);
            Class[] classes = r.getClasses();
            Class desireClass = null;
            for (Class cls : classes) {
                if (cls.getName().split(&quot;\\$&quot;)[1].equals(className)) {
                    desireClass = cls;
                    break;
                }
            }
            if (desireClass != null) {
                id = desireClass.getField(resName).getInt(desireClass);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return id;
    }
}
</code></pre><blockquote>
<p>其实AS已经为我们提供的aar包，在编译完后就生成了aar了，而且也不用担心资源问题，你自己来可能会漏资源。 </p>
<p>生成的aar在你的library的／build／outputs／aar／</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/as_jar_5.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: AS如何打jar包和aar包 # 这是标题&lt;br&gt;categories:  # 这里写的分类会自动汇集到 categories 页面上，分类可以多级&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学习记录  # 二级分类&lt;br&gt;tags:   # 这里写的标签会自动汇集
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阅读记录</title>
    <link href="http://yoursite.com/2016/12/22/%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2016/12/22/阅读记录/</id>
    <published>2016-12-22T05:28:07.000Z</published>
    <updated>2016-12-22T05:28:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2016-10-31"><a href="#2016-10-31" class="headerlink" title="2016.10.31"></a>2016.10.31</h3><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/1025/6699.html" target="_blank" rel="external">Android 多线程编程的总结</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/1014/6675.html" target="_blank" rel="external">[译]探索Android 大杀器——Handler</a>[2]<br><a href="http://www.open-open.com/lib/view/open1438065400878.html" target="_blank" rel="external">Android ORM 框架之 greenDAO 使用心得</a><br><a href="http://www.jianshu.com/p/4986100eff90" target="_blank" rel="external">GreenDao3.0简单使用</a><br><a href="http://yifeng.studio/2016/10/27/android-develop-30-things-that-experience-made-me-learn-the-hard-way/" target="_blank" rel="external">[译]开发安卓Apps，我所努力学习到的三十多条宝贵经验</a><a href="http://yifeng.studio/2016/10/27/android-develop-30-things-that-experience-made-me-learn-the-hard-way/" target="_blank" rel="external">5</a></p>
<h4 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h4><p><strong>无</strong></p>
<h3 id="2016-11-01"><a href="#2016-11-01" class="headerlink" title="2016.11.01"></a>2016.11.01</h3><h4 id="博客-1"><a href="#博客-1" class="headerlink" title="博客"></a>博客</h4><p><a href="http://blog.csdn.net/iispring/article/details/51661195" target="_blank" rel="external"> Okhttp使用详解</a></p>
<h4 id="书籍-1"><a href="#书籍-1" class="headerlink" title="书籍"></a>书籍</h4><p><strong>无</strong></p>
<h3 id="2016-11-02"><a href="#2016-11-02" class="headerlink" title="2016.11.02"></a>2016.11.02</h3><h4 id="博客-2"><a href="#博客-2" class="headerlink" title="博客"></a>博客</h4><p><a href="http://blog.csdn.net/lmj623565791/article/details/47911083" target="_blank" rel="external"> Android OkHttp完全解析 是时候来了解OkHttp了</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html" target="_blank" rel="external">OkHttp使用教程</a><br><a href="http://blog.csdn.net/iispring/article/details/51615631" target="_blank" rel="external">HTTPS理论基础及其在Android中的最佳实践</a><br><a href="http://limboy.me/tech/2011/02/19/https-workflow.html" target="_blank" rel="external">图解HTTPS</a><br><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="external">数字签名是什么？</a><br><a href="http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html" target="_blank" rel="external">密码学笔记</a><br> <a href="http://blog.csdn.net/lmj623565791/article/details/48129405" target="_blank" rel="external">Android Https相关完全解析 当OkHttp遇到Https</a><br><a href="http://www.jianshu.com/p/74d21a44323c" target="_blank" rel="external">设计模式-装饰者模式</a><br><a href="http://www.jianshu.com/p/f798c8b02348" target="_blank" rel="external">Android项目从零到上线的全过程</a><br><a href="http://www.jianshu.com/p/d9e4ddd1c530" target="_blank" rel="external">一个优秀的Android应用从建项目开始</a><br><a href="http://www.jianshu.com/p/fe9ccdf5d03b" target="_blank" rel="external">细读《失控》：送你一把瑞士军刀</a></p>
<h4 id="书籍-2"><a href="#书籍-2" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>《万历十五年》<br>《被误解的日本人》</p>
</blockquote>
<h3 id="2016-11-05"><a href="#2016-11-05" class="headerlink" title="2016.11.05"></a>2016.11.05</h3><h4 id="博客-3"><a href="#博客-3" class="headerlink" title="博客"></a>博客</h4><p><a href="http://blog.csdn.net/xiaanming/article/details/41084843" target="_blank" rel="external">Android 那些你所不知道的Bitmap对象详解</a><br><a href="http://www.jianshu.com/p/27bf1057f5aa" target="_blank" rel="external">带你学开源项目：OkHttp–自己动手实现OkHttp</a><br><a href="http://www.jianshu.com/p/47e72693a302" target="_blank" rel="external">带你学开源项目：Meizhi Android之RxJava &amp; Retrofit最佳实践</a><br><a href="http://www.jianshu.com/p/3141d4e46240" target="_blank" rel="external">Android网络请求心路历程</a><br><a href="http://blog.oneapm.com/apm-tech/344.html" target="_blank" rel="external">Android 网络请求详解</a><br><a href="http://gold.xitu.io/entry/5769f978d342d300580f4328" target="_blank" rel="external">OkHttpUtils 一个专注于让网络请求更简单的框架</a><a href="https://github.com/jeasonlzy/okhttp-OkGo" target="_blank" rel="external">(github)</a><br><a href="http://www.jianshu.com/p/e4670e9cfce9" target="_blank" rel="external">Java多线程深度探索</a></p>
<h4 id="书籍-3"><a href="#书籍-3" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>无</p>
</blockquote>
<h3 id="2016-11-07"><a href="#2016-11-07" class="headerlink" title="2016.11.07"></a>2016.11.07</h3><h4 id="博客-4"><a href="#博客-4" class="headerlink" title="博客"></a>博客</h4><p><a href="http://blog.csdn.net/jason0539/article/details/44956775" target="_blank" rel="external">23种设计模式汇总整理</a></p>
<h4 id="书籍-4"><a href="#书籍-4" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>《HTTP权威指南》<br>《Head First设计模式》<br>《大话设计模式》</p>
</blockquote>
<h3 id="2016-11-08"><a href="#2016-11-08" class="headerlink" title="2016.11.08"></a>2016.11.08</h3><h4 id="博客-5"><a href="#博客-5" class="headerlink" title="博客"></a>博客</h4><blockquote>
<p>无</p>
</blockquote>
<h4 id="书籍-5"><a href="#书籍-5" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>《大话设计模式》</p>
</blockquote>
<h3 id="2016-11-11"><a href="#2016-11-11" class="headerlink" title="2016.11.11"></a>2016.11.11</h3><h4 id="博客-6"><a href="#博客-6" class="headerlink" title="博客"></a>博客</h4><p><a href="http://blog.csdn.net/lpjishu/article/details/52665446" target="_blank" rel="external">Java泛型详解</a></p>
<h4 id="书籍-6"><a href="#书籍-6" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>《大话设计模式》</p>
</blockquote>
<h3 id="2016-11-13"><a href="#2016-11-13" class="headerlink" title="2016.11.13"></a>2016.11.13</h3><h4 id="博客-7"><a href="#博客-7" class="headerlink" title="博客"></a>博客</h4><p><a href="http://www.gcssloop.com/customview/dispatch-touchevent-theory" target="_blank" rel="external">安卓自定义View进阶-事件分发机制原理</a></p>
<h4 id="书籍-7"><a href="#书籍-7" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>《大话设计模式》</p>
</blockquote>
<h3 id="2016-12-01"><a href="#2016-12-01" class="headerlink" title="2016.12.01"></a>2016.12.01</h3><h4 id="博客-8"><a href="#博客-8" class="headerlink" title="博客"></a>博客</h4><p><a href="http://www.diycode.cc/topics/409" target="_blank" rel="external">手把手教你做个人 app</a><br><a href="http://www.jianshu.com/p/099c2c875524" target="_blank" rel="external">如何开发出一款仿映客直播APP项目实践篇 </a><br><a href="http://gold.xitu.io/post/583c242061ff4b006b59c7fb" target="_blank" rel="external">直接拿去用！每个App都会用到的LoadingLayout</a><br><a href="http://www.jianshu.com/p/d2f5ae6b4927" target="_blank" rel="external">WebView你真的熟悉吗？看了才知道</a></p>
<h4 id="书籍-8"><a href="#书籍-8" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>无</p>
</blockquote>
<h3 id="2016-12-12"><a href="#2016-12-12" class="headerlink" title="2016.12.12"></a>2016.12.12</h3><h4 id="博客-9"><a href="#博客-9" class="headerlink" title="博客"></a>博客</h4><p><a href="http://www.jianshu.com/p/f418bf95db2d" target="_blank" rel="external">掌握CoordinatorLayout</a><br><a href="http://www.jianshu.com/p/8dc11152f178" target="_blank" rel="external">如何给100亿个数字排序?</a><br><a href="http://www.jianshu.com/p/62f85f53ec16" target="_blank" rel="external">哈希分治法 - 统计海量数据中出现次数最多的前10个IP</a><br><a href="https://gold.xitu.io/post/584e7b298d6d81005456eb53" target="_blank" rel="external">Mysql 常用 SQL 语句集锦</a><br><a href="http://blog.csdn.net/u011507982/article/details/51199644" target="_blank" rel="external"> Android 自定义View合集</a><br><a href="https://gold.xitu.io/post/5846aee5ac502e006bb45d7e" target="_blank" rel="external">GitHub 使用</a><br><a href="http://www.jianshu.com/p/5f9b36a047e9" target="_blank" rel="external">Realm Java官方教程翻译(一)：Getting Started</a><br><a href="http://www.jianshu.com/p/99c98a02053e" target="_blank" rel="external">Realm Java官方教程翻译(二)：Getting Help及Models</a><br><a href="http://www.jianshu.com/p/d52a01af3d0a" target="_blank" rel="external">Realm Java官方教程翻译(三)：Relationships</a><br><a href="https://gold.xitu.io/post/58441c48c59e0d0056a30bc2" target="_blank" rel="external">Android 样式 (style) 和主题(theme)</a><br><a href="http://www.jianshu.com/p/5449656d56d2" target="_blank" rel="external">史上最高效的ORM方案——GreenDao3.0详解</a></p>
<h4 id="书籍-9"><a href="#书籍-9" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>《第一行代码》</p>
</blockquote>
<h3 id="2016-12-15"><a href="#2016-12-15" class="headerlink" title="2016.12.15"></a>2016.12.15</h3><h4 id="博客-10"><a href="#博客-10" class="headerlink" title="博客"></a>博客</h4><p><strong>MVP学习资源</strong></p>
<p><a href="http://hujiandong.com/2016/12/13/android-mvp-basic/" target="_blank" rel="external">Android 项目框架–MVP 基础</a><br><a href="http://www.jianshu.com/p/9a6845b26856" target="_blank" rel="external">Android MVP 详解（上）</a><br><a href="http://www.jianshu.com/p/0590f530c617" target="_blank" rel="external">Android MVP 详解（下）</a><br><a href="http://www.infoq.com/cn/articles/android-official-mvp-architecture-sample-project-analysis" target="_blank" rel="external">Android官方MVP架构示例项目解析</a></p>
<h4 id="书籍-10"><a href="#书籍-10" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>无</p>
</blockquote>
<h3 id="2016-12-20"><a href="#2016-12-20" class="headerlink" title="2016.12.20"></a>2016.12.20</h3><h4 id="博客-11"><a href="#博客-11" class="headerlink" title="博客"></a>博客</h4><p><a href="http://www.jianshu.com/p/1d84ba23f4d2" target="_blank" rel="external">Dagger2 入门,以初学者角度</a><br><a href="https://gold.xitu.io/post/5858a8f3b123db00658b1191" target="_blank" rel="external">探索日期滚轮控件的源码</a></p>
<h4 id="书籍-11"><a href="#书籍-11" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>无</p>
</blockquote>
<h3 id="2016-12-22"><a href="#2016-12-22" class="headerlink" title="2016.12.22"></a>2016.12.22</h3><h4 id="博客-12"><a href="#博客-12" class="headerlink" title="博客"></a>博客</h4><p><a href="http://blog.kaush.co/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/" target="_blank" rel="external">用RxJava来实现Otto—RxBus</a></p>
<h4 id="书籍-12"><a href="#书籍-12" class="headerlink" title="书籍"></a>书籍</h4><blockquote>
<p>无</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2016-10-31&quot;&gt;&lt;a href=&quot;#2016-10-31&quot; class=&quot;headerlink&quot; title=&quot;2016.10.31&quot;&gt;&lt;/a&gt;2016.10.31&lt;/h3&gt;&lt;h4 id=&quot;博客&quot;&gt;&lt;a href=&quot;#博客&quot; class=&quot;headerli
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="阅读" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>Dagger2 入门详解</title>
    <link href="http://yoursite.com/2016/12/21/Dagger2%20%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/12/21/Dagger2 入门详解/</id>
    <published>2016-12-21T06:12:26.000Z</published>
    <updated>2016-12-21T11:32:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Dagger2"><a href="#什么是Dagger2" class="headerlink" title="什么是Dagger2"></a>什么是Dagger2</h2><blockquote>
<p>Dagger2是Android中<strong>比较热门</strong>的<strong>依赖注入框架</strong>，而Android开发当前非常流行框架就是<strong>MVP模式</strong>了，Dagger2的目标便是将MVP中的V和P 进一步解耦，达到模块化最大的解耦，使得代码更容易维护。</p>
</blockquote>
<p><strong>Google官方主页介绍</strong></p>
<blockquote>
<p>Dagger is a fully static, compile-time dependency injection framework for both Java and Android. It is an adaptation of an earlier version created by Square and now maintained by Google.<br>Dagger aims to address many of the development and performance issues that have plagued reflection-based solutions. More details can be found in this talk(slides) by +Gregory Kick.</p>
</blockquote>
<p><strong>翻译理解</strong></p>
<blockquote>
<p>Dagger是为Android和Java平台提供的一个完全静态的，在编译时进行依赖注入的框架。 早期的版本由Square公司进行改编，现在由Google进行维护。<br>Dagger旨在解决基于反射带来的开发和性能上的问题（因为Dagger并没有用反射来做依赖注入）。更多详细内容可以看一下<a href="https://plus.google.com/+GregoryKick/" target="_blank" rel="external">Gregory Kicktalk</a>这个人的<a href="https://www.youtube.com/watch?v=oK_XtfXPkqw" target="_blank" rel="external">talk</a>。</p>
</blockquote>
<p><strong>通俗理解</strong></p>
<blockquote>
<p>其实就是告诉我们Dagger可以用来进行依赖注入，搞过Spring的人肯定都知道这是啥，SpringMVC里用到了大量依赖注入，下面聊一聊<strong>依赖注入</strong>。</p>
</blockquote>
<h2 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h2><p><strong>维基百科</strong></p>
<blockquote>
<p><strong>控制反转</strong>(Inversion of Control，缩写为<strong>IoC</strong>)，是面向对象编程中的一种<strong>设计原则</strong>，可以用来<strong>降低计算机代码之间的耦合度</strong>。其中最常见的方式叫做依赖注入(Dependency Injection，简称DI)，还有一种方式叫“依赖查找”(Dependency Lookup)。通过控制反转，对象在被创建的时候，由一个调度者调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p>
</blockquote>
<p><strong>通俗理解</strong></p>
<blockquote>
<p>当一个类中需要依赖其他对象时,不需要你亲自为那些需要依赖的对象赋值,为那些对象赋值的操作交给了<strong>IOC框架</strong>(如Dagger2)。例如，我们在做项目时，经常需要在一个对象里去创建另一个对象的示例，这种行为是<strong>产生耦合</strong>的常见形式，对于一个大型项目来说，过多的相互依赖会导致代码难以维护，很容易就会碰到修改一个小需求需要大面积的修改各种代码，特别是代码原来不是自己维护的，麻烦会更大。</p>
</blockquote>
<h2 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h2><blockquote>
<p>有一家咖啡店CoffeeShop，向顾客提供咖啡，我们非常容易明白咖啡店CoffeeShop是不能自己生产咖啡给顾客的，他们只能通过不同咖啡制作方法来生产咖啡供顾客饮用，此时抽象一个接口CoffeeMaker。</p>
</blockquote>
<h3 id="传统做法"><a href="#传统做法" class="headerlink" title="传统做法"></a>传统做法</h3><ul>
<li><p>业务核心类是CoffeeShop，通过CoffeeMaker负责生产Coffee并进行售卖</p>
<p>  /**</p>
<ul>
<li>这是一个售卖Coffee的例子</li>
<li>CoffeeMaker是对生成Coffee过程的一个封装</li>
<li><p>制作Coffee需要实现CoffeeMaker的produceCoffee方法<br>*/<br>public class CoffeeShop {</p>
<p> private CoffeeMaker mCoffeeMachine;</p>
<p> public CoffeeShop(CoffeeMaker coffeeMachine) {</p>
<pre><code>mCoffeeMachine = new SimpleCoffeeMachine();
</code></pre><p> }</p>
<p> public String provideCoffee() {</p>
<pre><code>return mCoffeeMachine.produceCoffee();
</code></pre><p> }<br>}</p>
</li>
</ul>
</li>
<li><p>Coffee的实际生产接口CoffeeMaker</p>
<p>  public interface CoffeeMaker {</p>
<pre><code>String produceCoffee(); // 实际生成咖啡的方法
</code></pre><p>  }</p>
</li>
<li><p>实际的Coffee生产者，下面是简单的咖啡机SimpleCoffeeMachine</p>
<p>  public class SimpleCoffeeMachine implements CoffeeMaker {</p>
<pre><code>@Override
public String produceCoffee() {
    return &quot;Coffee is made by SimpleCoffeeMachine&quot;;
}
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>刚开始咖啡都是咖啡机做出来的，这家咖啡店很简单，在CoffeeShop中可以看到，CoffeeShop持有了一个CoffeeMaker生产接口，而具体制作Coffee的过程是由实现了CoffeeMaker的自动咖啡机SimpleCoffeeMachine实现的，CoffeeMaker是在构造方法中new 出了一个实现CoffeeMaker接口的SimpleCoffeeMachine。当前的功能很简单，这么写看着也没什么问题。</p>
<p>随着业务的扩展，消费人群改变了，自动咖啡机SimpleCoffeeMachine也完全不能满足现有客户的需求，这个时候我们的CoffeeShop该进行业务升级。</p>
</blockquote>
<ul>
<li><p>雇佣<strong>咖啡师</strong>CoffeeCooker来制作咖啡。</p>
<p>  public class CoffeeCooker {</p>
<pre><code>private String mName; // 咖啡师名字
private String MCoffeeType; // 生产的Coffee类型

public CoffeeCooker(String name, String MCoffeeType) {
    mName = name;
    this.MCoffeeType = MCoffeeType;
}

public String produceCoffee() {
    return mName + &quot;制作了&quot; + MCoffeeType + &quot;的Coffee.&quot;;
}
</code></pre><p>  }</p>
</li>
<li><p>此时要升级SimpleCoffeeMachine了</p>
<p>  public class SimpleCoffeeMachine implements CoffeeMaker {</p>
<p>  //    @Override<br>  //    public String produceCoffee() {<br>  //        return “Coffee is made by SimpleCoffeeMachine”;<br>  //    }</p>
<pre><code>// 升级后
private CoffeeCooker mCoffeeCooker;

public SimpleCoffeeMachine(CoffeeCooker coffeeCooker) {
    mCoffeeCooker = coffeeCooker;
}
@Override
public String produceCoffee() {
    return mCoffeeCooker.produceCoffee();
}
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>基于目前的情况，我们制作咖啡的流程发生了变化，原来的业务随着CoffeeCooker的加入发生了改变，但细心的小伙伴会发现目前还有一个地方受到了影响，那就是我们的CoffeeShop，</p>
</blockquote>
<pre><code>public class CoffeeShop {

    private CoffeeMaker mCoffeeMaker;

//    public CoffeeShop(CoffeeMaker coffeeMachine) {
//        mCoffeeMachine = new SimpleCoffeeMachine();
//    }

    // 升级后
    public CoffeeShop(CoffeeCooker coffeeCooker) {
        mCoffeeMaker = new SimpleCoffeeMachine(coffeeCooker);
    }

    public String provideCoffee() {
        return mCoffeeMaker.produceCoffee();
    }
}
</code></pre><blockquote>
<p>我们的SimpleCoffeeMachine升级了，业务波动影响到了我们的CoffeeShop，这时候不得不对CoffeeShop也进行修改。这时候我们的CoffeeShop就懵逼了，你SimpleCoffeeMachine业务升级就升级呗，为毛我制造CoffeeShop的过程也要变动，非常的不愿意，但迫于老板的压力。最后还是给整改了。很明显，这是一个<strong>不合适的流程</strong>，简单的一个业务的升级，还要我们对整个咖啡店进行修改，那如果业务非常复杂，引用了SimpleCoffeeMachine的可不仅仅是CoffeeShop一个，那是不是每个引用的地方都需要进行修改，业务庞大的情况下，这种修改就是致命的，不仅需要做大量没有意义的体力劳动来修改，还可能导致大片业务代码的变动直接<strong>增加测试的成本</strong>，其他接收这个需求的开发人员直接得跪键盘了，一个S SimpleCoffeeMachine的改动对CoffeeShop产生了直接的影响，肯定有什么地方是不对的。原因就是CoffeeShop里的SimpleCoffeeMachine是<strong>自己new出来的</strong>。这就是一个很不好的地方。这种糟糕的<strong>实例引用的方式</strong>我们称之为<strong>硬初始化（Hard init）</strong>，和<strong>硬编码（Hard coding）</strong>一样，都是糟糕代码滋生的好方法，Hard init不仅增加了<strong>各个模块的耦合</strong>，还让<strong>单元测试</strong>变得<strong>更加困难</strong>了。</p>
</blockquote>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote>
<p>那么该用什么方法来尽量地<strong>降低各个模块的耦合</strong>，避免<strong>new对象</strong>带来的问题呢。我们知道，类的初始化可以<strong>描述成new</strong>,get和set，new就是我们上面说的Hard init，容易增加各个模块之间的耦合，而<strong>get，则可以看做是工厂模式</strong>，工厂模式是new的一个<strong>升级版本</strong>，相对硬初始化来说，工厂模式把<strong>对象的创建都集中在工厂</strong>里了，对于需要依赖的类来说，无需再考虑对象的创建工作了，只需要关注如何从工厂里获得，在发生修改时也不会有太多的改动，和以前的方案比起来要好了不少。但工厂模式的对象创建依然非常的不灵活，对象的实现<strong>完全取决于工厂</strong>，会导致原来的<strong>依赖由具体的对象</strong>变为<strong>依赖相应的工厂</strong>，本质上还是有依赖关系的！！！对，工厂模式并没有改变本质的<strong>依赖关系</strong>，而且，对于简单职责的工厂来说，抽出一层工厂似乎并不会太麻烦，但当我们的工厂中提供的类的实现复杂起来时，又回到了最初的问题上，我们是在工厂中new对象还是继续给工厂中的内容再提供一个工厂呢，这种层层嵌套会让我们的代码变得干涩难懂，也会有<strong>设计过度</strong>的嫌疑，工厂模式在解决依赖问题还是有点尴尬。</p>
</blockquote>
<h3 id="手动依赖注入"><a href="#手动依赖注入" class="headerlink" title="手动依赖注入"></a>手动依赖注入</h3><blockquote>
<p>那么最后还有一个<strong>set</strong>，也就是我们的<strong>依赖注入</strong>了，依赖注入的依赖是<strong>从外部传递过来的</strong>，而且在Java平台上很多时候都是通过<strong>反射或者动态编译</strong>来提供<strong>依赖注入</strong>，这样就更加剥离的各个部分的耦合性，也让上述两种方式只能望其项背了。</p>
<p>依赖注入主要有三种途径：</p>
</blockquote>
<pre><code>public class CoffeeShopWithInjection implements InjectMaker {

    private CoffeeMaker mCoffeeMaker;

    // 第1种依赖注入方式: 构造器注入
    public CoffeeShopWithInjection(CoffeeMaker coffeeMaker) {
        mCoffeeMaker = coffeeMaker;
    }

    // 第2种依赖注入方式: Setter注入
    public void setCoffeeMaker(CoffeeMaker coffeeMaker) {
        mCoffeeMaker = coffeeMaker;
    }

    // 第3种依赖注入方式: 接口注入
    @Override
    public void injectMaker(CoffeeMaker coffeeMaker) {
        mCoffeeMaker = coffeeMaker;
    }

    public String produceCoffee() {
        return mCoffeeMaker.produceCoffee();
    }
}
</code></pre><blockquote>
<p>InjectMarker接口内容如下：</p>
</blockquote>
<pre><code>public interface InjectMaker {
    void injectMaker(CoffeeMaker coffeeMaker);
}
</code></pre><blockquote>
<p>依赖注入的最基本的原理比较容易理解，就是不要在需要依赖的类中通过<strong>new</strong>来创建依赖而是<strong>通过方法提供的参数注入进来</strong>，这样我们的需要依赖的类和提供依赖的类的实现方法分隔开了。不过这种<strong>手动提供依赖</strong>也是很繁杂的工作，充满的浓浓的重复体力劳动的气息，如何来尽量减少这些冗余代码的制作呢，答案就是下一部分。</p>
</blockquote>
<h3 id="依赖注入框架-Dagger2"><a href="#依赖注入框架-Dagger2" class="headerlink" title="依赖注入框架(Dagger2)"></a>依赖注入框架(Dagger2)</h3><blockquote>
<p>一般的IOC框架都是通过<strong>反射</strong>来实现的,但Dagger2作为Android端的IOC框架,为了不影响性能,它是通过<strong>apt动态生成代码</strong>来实现的.</p>
</blockquote>
<h4 id="Dagger2主要分为三个模块"><a href="#Dagger2主要分为三个模块" class="headerlink" title="Dagger2主要分为三个模块"></a>Dagger2主要分为三个模块</h4><ul>
<li>依赖提供方Module,负责提供依赖中所需要的对象,实际编码中类似于<strong>工厂类</strong></li>
<li>依赖需求方实例,它声明依赖对象,它在实际编码中对应<strong>业务类</strong>,例如Activity,当你在Activity中需要某个对象时,你只要在其中<strong>声明</strong>就行,声明的方法在下面会讲到</li>
<li>依赖注入组件Component,负责将对象注入到依赖需求方,它在实际编码中是<strong>一个接口</strong>,编译时Dagger2会自动为它生成一个实现类</li>
</ul>
<h4 id="Dagger2的主要工作流程"><a href="#Dagger2的主要工作流程" class="headerlink" title="Dagger2的主要工作流程"></a>Dagger2的主要工作流程</h4><ul>
<li>将依赖需求方实例传入给Component实现类</li>
<li>Component实现类根据依赖需求方实例中<strong>依赖声明</strong>,来确定该实例需要依赖哪些对象</li>
<li>确定依赖对象后,Component会在与自己关联的<strong>Module类</strong>中查找有没有提供<strong>这些依赖对象的方法</strong>,有的话就将Module类中提供的对象<strong>设置到依赖需求方实例中</strong></li>
</ul>
<blockquote>
<p>通俗上来讲就好比你现在需要一件衣服,自己做太麻烦了,你就去商店买,你跟商店老板说明你想要购买的类型后,商店老板就会在自己的衣服供应商中查找有没有你所说的类型,有就将它卖给你.其中<strong>你就对应上面所说的依赖需求方实例</strong>,你只要说明你需要什么,<strong>商店老板则对应Component实现类</strong>,负责满足别人的需求,而<strong>衣服供应商则对应Module类</strong>,他负责生产衣服.也许这里有点绕,但经过下面的Demo,也许能够帮助你理解.</p>
</blockquote>
<h4 id="在项目中引入Dagger2"><a href="#在项目中引入Dagger2" class="headerlink" title="在项目中引入Dagger2"></a>在项目中引入Dagger2</h4><p><strong>在项目下的build.gradle文件中添加apt插件</strong></p>
<pre><code>buildscript {
    ...
    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.2.2&apos;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
        //添加apt插件
        classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;
    }
}
...
</code></pre><p><strong>在app目录的build.gradle文件中添加</strong></p>
<pre><code>apply plugin: &apos;com.android.application&apos;
//应用apt插件,一定要放在下面
apply plugin: &apos;com.neenbedankt.android-apt&apos;
...
dependencies {
    ...
    //引入dagger2
    compile &apos;com.google.dagger:dagger:2.4&apos;
    apt &apos;com.google.dagger:dagger-compiler:2.4&apos;
    //java注解
    provided &apos;org.glassfish:javax.annotation:10.0-b28&apos;
}
</code></pre><h4 id="Module类注入方式"><a href="#Module类注入方式" class="headerlink" title="Module类注入方式"></a>Module类注入方式</h4><p><strong>编写布料类Cloth</strong></p>
<blockquote>
<p>写一个Cloth类用作依赖对象,它包含一个color属性</p>
</blockquote>
<pre><code>public class Cloth {
    private String color;

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return color + &quot;布料&quot;;
    }
}
</code></pre><p><strong>书写Module类</strong></p>
<blockquote>
<p>现在的需求是MainActivity中需要使用到Cloth对象,所以我们要为MainActivity书写一个Module类用来提供Cloth对象,相当于创建了一个<strong>提供商</strong></p>
</blockquote>
<pre><code>@Module
public class MainModule {
    @Provides
    public Cloth getCloth() {
        Cloth cloth = new Cloth();
        cloth.setColor(&quot;红色&quot;);
        return cloth;
    }
}
</code></pre><blockquote>
<p>嗯?怎么多了两个注解?这两个注解有什么用呢?<br><strong>注解</strong>是Dagger2中的关键,编写<strong>Module类</strong>时要在该类上声明<strong>@Module</strong>以表明该类是Module类,这样Dagger2才能识别,那<strong>@Provides</strong>又是干嘛的呢?它的作用是声明Module类中<strong>哪些方法是用来提供依赖对象的</strong>,当<strong>Component类</strong>需要<strong>依赖对象</strong>时,他就会根据<strong>返回值的类型</strong>来在<strong>有@Provides注解的方法中选择调用哪个方法</strong>.在一个方法上声明@Provides注解,就相当于创建了<strong>一条生产线</strong>,这条生产线的产物就是方法的<strong>返回值类型</strong>.有了这条生产线,供应商就能<strong>提供这种类型的商品</strong>了,当商店老板（Component类）发现有人（依赖需求方）需要这种类型的商品时,<strong>供应商Module</strong>就可以提供给他了。</p>
</blockquote>
<p><strong>书写Component接口</strong></p>
<pre><code>@Component(modules = MainModule.class)
public interface MainComponent {
    void inject(MainActivity mainActivity);
}
</code></pre><blockquote>
<p>和Module类一样,<strong>Component类</strong>也是需要注解声明的,那个注解就是<strong>@Component</strong>,但是@Component注解的作用可<strong>不是单单用来声明Component类</strong>,他还有更强大的功能,@Component注解有<strong>modules和dependencies</strong>两个属性,这两个属性的类型都是<strong>Class数组</strong>,modules的作用就是<strong>声明该Component含有哪几个Module</strong>,即有几个供应商,当Component需要<strong>某个依赖对象</strong>时,就会通过<strong>这些Module类中对应的方法</strong>获取依赖对象,MainComponent中只包含<strong>MainModule</strong>,所以令modules=MainModule.class,<strong>相当于供应商和商店老板确定合作关系的合同</strong>.而<strong>dependencies属性则是声明Component类的依赖关系</strong>,这个下面再详讲.</p>
<p><strong>接口中那个方法</strong>又是干嘛用的呢?</p>
<p>我们现在只是声明了Component类,但我们要怎么将<strong>Component类和依赖需求方</strong>对象联合起来呢?答案就是通过这个<strong>inject方法</strong>,这个方法可以将依赖需求方对象送到Component类中,Component类就会根据<strong>依赖需求方对象中声明的依赖关系</strong>来<strong>注入依赖需求方对象中所需要的对象</strong>,本Demo中<strong>MainActivity（依赖需求方）</strong>中需要<strong>Cloth对象</strong>,所以我们通过inject方法将MainActivity实例传入到MainComponent中,MainComponent就会从MainModule中的getCloth方法获取Cloth实例,并将该实例赋值给MainActivity中的cloth字段.相当于你去商店的道路,没有这条路,<strong>你就无法去商店和老板说明你所需要的东西</strong>.但是这里需要注意的是,<strong>inject方法的参数不能用子类来接收,例如本Demo中,如果inject的参数是Activity,那么Dagger2就会报错.</strong></p>
</blockquote>
<p><strong>在MainActivity中声明</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private TextView mTextView;
    @Inject
    Cloth mCloth;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mTextView = (TextView) findViewById(R.id.tv);

        MainComponent build = DaggerMainComponent.builder()
                .mainModule(new MainModule())
                .build();
        build.inject(this);

        mTextView.setText(&quot;我现在有&quot; + mCloth);
    }
}
</code></pre><blockquote>
<p>上面代码中有两处关键:</p>
</blockquote>
<ul>
<li><strong>声明依赖对象Cloth</strong>,就是在cloth字段上添加<strong>@Inject</strong>注解,Dagger2中<strong>声明依赖对象</strong>都是通过@Inject注解,但是@Inject注解的字段不能是<strong>private和protected的</strong>. </li>
<li>通过Dagger2自动生成的类来创建<strong>Component的实现类</strong>,创建时需要传入该Component实现类所需要的<strong>Module类实例</strong>,传入方法就是调用Module类类名首字母小写对应的方法.这里我们通过Dagger2自动生成的<strong>DaggerMainComponent</strong>类创建了MainComponent的实例,相当于我们创建了一个实实在在的商店,不再是理论上的商店,但是创建商店一定也要创建真实的供应商嘛,所以创建Component实现类时一定要<strong>传入Module的实例.</strong>(注意编写完Component接口后Dagger2并不会自动创建对应的类,需要我们点击Android Studio中bulid菜单下的Rebulid Poject选项,或者直接书写代码,编译时Dagger2就会帮你自动生成).<br>  再将MainActivity通过inject方法发送到MainComponent中,调用完<strong>inject方法</strong>后,你就会发现,MainActivity中的<strong>mCloth字段已经被赋值</strong>,而且该mCloth对应的就是我们在<strong>MainModule类getCloth方法中创建的Cloth对象.</strong></li>
</ul>
<p><strong>运行结果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1818011-f8884b1f3c71e61d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="注解依赖对象注入方式"><a href="#注解依赖对象注入方式" class="headerlink" title="注解依赖对象注入方式"></a>注解<strong>依赖对象</strong>注入方式</h4><blockquote>
<p>前面的例子可能给人最大的感受就是麻烦吧?就是为mCloth赋个值,又要写什么Module类,又是要写什么Component接口.其实Dagger2还可以用注解来提供依赖对象.让我们来瞧瞧怎么使用.</p>
</blockquote>
<p><strong>创建依赖类Shoe</strong></p>
<blockquote>
<p>我们又创建一个依赖类Shoe</p>
</blockquote>
<pre><code>public class Shoe {
    @Inject
    public Shoe() {}

    @Override
    public String toString() {
        return &quot;鞋子&quot;;
    }
}
</code></pre><blockquote>
<p>但是这次我们创建的方<strong>式和Cloth不一样了</strong>,我们在<strong>构造函数上声明了@Inject注解</strong>,这个注解有什么用呢?作用可大了,<strong>当Component在所拥有的Module类中找不到依赖需求方需要类型的提供方法时</strong>,Dagger2就会检查该需要类型的<strong>有没有用@Inject声明的构造方法</strong>,<strong>有则用该构造方法创建一个</strong>.</p>
<p>相当于你去商店购买东西,你需要的东西商店的供应商不生产,商店老板就只好帮你去网上看看有没有你需要的东西,有则帮你网购一个.</p>
</blockquote>
<p><strong>在MainActivity中声明Shoe依赖</strong></p>
<blockquote>
<p>我们修改之前的MainActivity,添加一点东西</p>
</blockquote>
<pre><code>public class MainActivity extends AppCompatActivity {
    private TextView mTextView;
    @Inject
    Cloth mCloth;
    @Inject
    Shoe mShoe;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mTextView = (TextView) findViewById(R.id.tv);

        MainComponent build = DaggerMainComponent.builder()
                .mainModule(new MainModule())
                .build();
        build.inject(this);

        //mTextView.setText(&quot;我现在有&quot; + mCloth);
        mTextView.setText(&quot;我现在有&quot; + mCloth + &quot;和&quot; + mShoe);
    }
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1818011-e9598e0d6581d92f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>注意</strong></p>
<blockquote>
<p>有些读者可能会这样想:为什么不都用这种方法来声明呢?为什么要用Module类?<br>答案是这样的,项目中我们会用到<strong>别人的jar包</strong>,我们无法修改别人的源码,就更别说<strong>在人家的类上添加注解了</strong>,所以我们只能通过Module类来提供.</p>
</blockquote>
<h4 id="复杂一点的使用情况"><a href="#复杂一点的使用情况" class="headerlink" title="复杂一点的使用情况"></a>复杂一点的使用情况</h4><blockquote>
<p>我们创建的这些<strong>依赖类</strong>都<strong>不用依赖于其它依赖类</strong>,但是如果需要依赖于其它依赖类又要怎么弄呢?</p>
</blockquote>
<p><strong>创建依赖类Clothes</strong></p>
<blockquote>
<p>我们又来创建一个<strong>衣服类Clothes</strong>,制作衣服时<strong>需要布料</strong>,所以我们在创建Clothes的实例时需要<strong>用到Cloth实例</strong>(依赖到Cloth类)</p>
</blockquote>
<pre><code>public class Clothes {
    private Cloth cloth;
    public Clothes(Cloth cloth) {
        this.cloth = cloth;
    }
    public Cloth getCloth() {
        return cloth;
    }
    @Override
    public String toString() {
        return cloth.getColor() + &quot;衣服&quot;;
    }
}
</code></pre><p><strong>在Module类中增加提供方法</strong></p>
<blockquote>
<p>现在我们的MainActivity中需要<strong>依赖于Clothes对象</strong>,所以我们在MianModule中<strong>添加提供Clothes对象的方法</strong>,但是<strong>Clothes需要依赖于Cloth对象</strong>,这要怎么办呢?可能最先想到的办法就是这样:</p>
</blockquote>
<pre><code>@Provides
    public Clothes getClothes() {
        Cloth cloth = new Cloth();
        cloth.setColor(&quot;红色&quot;);
        return new Clothes(cloth);
}
</code></pre><blockquote>
<p>直接在方法中创建一个Cloth不就得了,但是你有没有发现,创建Cloth的代码已经在<strong>getCloth方法中有了</strong>,我们能不能用getCloth方法中创建的Cloth实例来创建Clothes实例呢?</p>
<p>Dagger2提供了这样的功能,我们只要在getClothes方法中<strong>添加Cloth参数</strong>,Dagger2就会像帮<strong>依赖需求方找依赖对象一样帮你找到该方法依赖的Cloth实例</strong>,所以我们代码可以这样改:</p>
</blockquote>
<pre><code>@Provides
    public Clothes getClothes(Cloth cloth) {
        return new Clothes(cloth);
}
</code></pre><p><strong>在MainActivity中声明Clothes依赖</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {
    ...
    @Inject
    Clothes clothes;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        tv.setText(&quot;我现在有&quot; + cloth + &quot;和&quot; + shoe + &quot;和&quot; + clothes);
    }
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1818011-edb92a97c1ae2c15.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>同理,在带有@Inject注解的构造函数要是依赖于其它对象,Dagger2也会帮你自动注入.</p>
</blockquote>
<p><strong> 创建依赖类Shirt</strong></p>
<pre><code>public class Shirt {
    Cloth mCloth;
    @Inject
    public Shirt(Cloth cloth) {
        mCloth = cloth;
    }
    @Override
    public String toString() {
        return mCloth + &quot;T恤&quot;;
    }
}
</code></pre><p><strong>在MainActivity中声明Shirt依赖</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {
    ...
    @Inject
    Shirt mShirt;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        mTextView.setText(&quot;我现在有&quot; + mCloth + &quot;和&quot; + mShoe + &quot;和&quot; + mClothes + &quot;和&quot; + mShirt);
    }
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo1.png" alt=""></p>
<h4 id="依赖总结"><a href="#依赖总结" class="headerlink" title="依赖总结"></a>依赖总结</h4><blockquote>
<p>引用<a href="https://dreamerhome.github.io/2016/07/07/dagger/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">依赖注入神器：Dagger2详解系列</a>中的一段话:<br>我们有<strong>两种方式可以提供依赖</strong>，一个是<strong>注解了@Inject的构造方法</strong>，一个是在<strong>Module里提供的依赖</strong>，那么Dagger2是怎么选择依赖提供的呢，规则是这样的：</p>
</blockquote>
<ul>
<li>步骤1：查找Module中是否存在创建该类的方法</li>
<li>步骤2：若存在创建类方法，查看该方法是否存在参数<ul>
<li>步骤2.1：若存在参数，则按从步骤1开始依次初始化每个参数</li>
<li>步骤2.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束</li>
</ul>
</li>
<li>步骤3：若不存在创建类方法，则查找Inject注解的构造函数，看构造函数是否存在参数<ul>
<li>步骤3.1：若存在参数，则从步骤1开始依次初始化每个参数</li>
<li>步骤3.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束</li>
</ul>
</li>
</ul>
<p><strong>也就说Dagger2会递归的提供依赖</strong></p>
<h4 id="Named和-Qulifier注解的使用"><a href="#Named和-Qulifier注解的使用" class="headerlink" title="@Named和@Qulifier注解的使用"></a>@Named和@Qulifier注解的使用</h4><p><strong>@Named</strong></p>
<blockquote>
<p>假设我们现在又有了新的需求,MainActivity中需要<strong>两种布料</strong>,分别是红布料和蓝布料,但我们的MainModule类中只能提供红布料,怎么办呢?<br>读者可能会想:在MainModule类中再添加一个提供蓝布料的方法不就行了:</p>
</blockquote>
<pre><code>@Provides
public Cloth getRedCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;红色&quot;);
    return cloth;
}
@Provides
public Cloth getBlueCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;蓝色&quot;);
    return cloth;
}
</code></pre><blockquote>
<p>可问题就来了,Dagger2<strong>是通过返回值类型来确定的</strong>,当你需要红布料时,它又怎么知道哪个是红布料呢?所以Dagger2为我们提供<strong>@Named</strong>注解,它怎么使用呢?它有一个value值,<strong>用来标识这个方法是给谁用的</strong>.修改我们的代码:</p>
</blockquote>
<pre><code>@Provides
@Named(&quot;red&quot;)
public Cloth getRedCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;红色&quot;);
    return cloth;
}
@Provides
@Named(&quot;blue&quot;)
public Cloth getBlueCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;蓝色&quot;);
    return cloth;
}
</code></pre><blockquote>
<p>我们在getRedCloth方法上使用<strong>@Named(“red”)表明此方法返回的是红布料</strong>,同理,在<strong>getBlueCloth方法上使用@Named(“blue”)</strong>表明此方法返回的是蓝布料,接下我们只要在MainActivity中的布料字段上<strong>同样使用@Named注解</strong>,就可以<strong>一一配对</strong>了.</p>
</blockquote>
<pre><code>public class MainActivity extends AppCompatActivity {
    ...
    @Inject
    @Named(&quot;red&quot;)
    Cloth redCloth;
    @Inject
    @Named(&quot;blue&quot;)
    Cloth blueCloth;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        tv.setText(&quot;我现在有&quot; + mRedCloth + &quot;和&quot; + mBlueCloth );
    }
}
</code></pre><blockquote>
<p>在redCloth上用@Named(“red”)标记后,他就会对应Module中对应的方法.</p>
</blockquote>
<p><strong>运行结果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1818011-2fcd4ed5a6a53f9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>@Qulifier</strong></p>
<blockquote>
<p>@Qulifier功能和@Named一样,并且@Named就是继承@Qulifier的,我们要怎么使用@Qulifier注解呢?答案就是自定义一个注解:</p>
</blockquote>
<pre><code>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface RedCloth {
}
</code></pre><blockquote>
<p>有了这个注解,我们就可以用它在替换掉上面的@Named(“red”),效果是一样的.</p>
</blockquote>
<p><strong>略</strong></p>
<blockquote>
<p>而且这两个注解还能使用在依赖参数上,比如这个:</p>
</blockquote>
<pre><code>@Provides
 public Clothes getClothes(@Named(&quot;blue&quot;) Cloth cloth){
     return new Clothes(cloth);
 }
</code></pre><blockquote>
<p>效果和上面说明的一样,进入这个方法的cloth由上面有@Named(“blue”)的方法提供</p>
</blockquote>
<h4 id="Singleton和-Scope的使用"><a href="#Singleton和-Scope的使用" class="headerlink" title="@Singleton和@Scope的使用"></a>@Singleton和@Scope的使用</h4><p><strong>@Singleton</strong></p>
<blockquote>
<p>假设现在MainActivity中需要依赖Clothes和Cloth,我们在MainModule中提供这两个类的提供方法:</p>
</blockquote>
<pre><code>@Provides
@Named(&quot;blue&quot;)
public Cloth getBlueCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;蓝色&quot;);
    return cloth;
}
@Provides
public Clothes getClothes(@Named(&quot;blue&quot;) Cloth cloth) {
    return new Clothes(cloth);
}
</code></pre><blockquote>
<p>接着在MainActivity中声明</p>
</blockquote>
<pre><code>mTextView.setText(&quot;mBlueCloth=mClothes中的mBlueCloth吗?:&quot; + (mBlueCloth == mClothes.getCloth()));
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo2.png" alt=""></p>
<blockquote>
<p>你会发现,MainActivity中的<strong>Cloth对象</strong>和<strong>Clothes中的Cloth对象</strong>并<strong>不是同一个对象</strong>,注入过程中,对mBlueCloth注入时会调用一次getBlueCloth方法,<strong>创建了一个Cloth对象</strong>;注入mClothes时又会调用一次getBlueCloth方法,这时<strong>又会创建一个Cloth对象</strong>,所以才会出现上面的结果.但是如果需要MainActivity中的mBlueCloth对象和mClothes中的mBlueCloth对象是<strong>同一个对象</strong>又要怎么办呢?Dagger2为我们提供了<strong>@Singleton</strong>注解,和名字一样,这个注解的作用就是<strong>声明单例模式</strong>,我们先看看它怎么使用,下面再讲原理.</p>
</blockquote>
<p><strong>首先,在getRedCloth方法上添加该注解</strong></p>
<pre><code>@Provides
@Named(&quot;blue&quot;)
@Singleton
public Cloth getBlueCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;蓝色&quot;);
    return cloth;
}
</code></pre><p><strong>再在MainComponent接口上添加该注解</strong></p>
<pre><code>@Singleton
@Component(modules = MainModule.class)
public interface MainComponent {
    void inject(MainActivity mainActivity);
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo3.png" alt=""></p>
<blockquote>
<p>有没有发现,MainActivity中的Cloth对象和Clothes中的Cloth对象是同一个对象了,是不是很神奇!</p>
</blockquote>
<p><strong>Scope</strong></p>
<blockquote>
<p>@Singleton是怎么实现的呢?我们先看看<strong>@Scope注解</strong>,弄懂它,@Singleton你也就会明白了,下面我们就来分析分析<br>顾名思义,@Scope就是用来<strong>声明作用范围的</strong>.@Scope和@Qulifier一样,需要我们<strong>自定义注解才能使用,</strong>我们先自定义一个注解:</p>
</blockquote>
<pre><code>@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface PreActivity {
}
</code></pre><blockquote>
<p>这个注解有什么用呢?答案就是<strong>声明作用范围</strong>,当我们将这个注解使用在Module类中的Provide方法上时,就是声明这个Provide方法是在PerActivity作用范围内的,并且当一个Component要引用这个Module时,必须也要声明这个Component是PerActivity作用范围内的,否则就会报错,声明方法也很简单,就是在Component接口上使用这个注解.但是我们声明这个作用范围又有什么用呢?</p>
<p>原来Dagger2有这样一个机制:在同一个作用范围内,Provide方法<strong>提供的依赖对象就会变成单例</strong>,也就是说依赖需求方不管依赖几次Provide方法提供的依赖对象,Dagger2都<strong>只会调用一次这个方法</strong>.就和上面那个例子一样,正常情况下,在注入MainActivity中的mBlueCloth对象时会调用一次getBlueCloth方法,注入mClothes对象时因为依赖Cloth对象,所以又会调用一次getBlueCloth方法,导致这两个Cloth对象并不是同一个实例.但是我们给它<strong>声明作用范围</strong>后,这两次对Cloth的依赖<strong>只会调用一次getBlueCloth方法</strong>,这样这两个Cloth对象就是同一实例了,这样就保证了在给MainActivity注入时,所有声明的<strong>Cloth</strong>依赖都是指向同一个实例.(注意:只有Module类中声明了作用范围的Provide方法才能实现单例,没声明的方法就不是单例的)</p>
<p>查看源码你会发现Singleton其实是<strong>继承@Scope注解的</strong>,所以你知道了Singleton是怎么实现单例模式的吧.</p>
<p>可能有些读者可能会问,Dagger2既然有了Singleton为什么还要我们<strong>自定义PerActivity注解</strong>?这就涉及到<strong>代码可读性</strong>了,当<strong>依赖需求方是Activity</strong>时,我们可以自定义一个PerActivity注解,当<strong>依赖需求方是Fragment时</strong>,我们又可以自定义一个PerFragment注解,这样我们就能清楚的区分依赖对象的提供目标了.</p>
<p>那我们通过<strong>构造函数提供依赖的方式又要怎么声明作用范围</strong>呢?答案就是在<strong>类名上使用注解标明</strong>,<strong>切记不要在构造函数上用注解标明,这样是无效的</strong>.<br>读者可以试试用PerActivity注解代替上面例子中的Singleton注解,你会发现效果是一样的.</p>
<p><strong>注意注意注意</strong>:单例是在<strong>同一个Component实例提供依赖的前提下才有效的</strong>,<strong>不同的Component实例只能通过Component依赖才能实现单例</strong>.也就是说,你虽然在两个Component接口上都添加了PerActivity注解,但是这两个Component提供依赖时是<strong>没有联系</strong>的,他们<strong>只能在各自的范围内实现单例</strong>.(下面会降到)</p>
</blockquote>
<h4 id="组件依赖dependencies的使用"><a href="#组件依赖dependencies的使用" class="headerlink" title="组件依赖dependencies的使用"></a>组件依赖dependencies的使用</h4><blockquote>
<p>在实际开发中,我们经常会使用到工具类,工具类一般在<strong>整个App的生命周期内都是单例的</strong>,我们现在给我们的Demo添加一个工具类ClothHandler:</p>
</blockquote>
<pre><code>public class ClothHandler {
    public Clothes handle(Cloth cloth){
        return new Clothes(cloth);
    }
}
</code></pre><blockquote>
<p>它的功能就是<strong>将cloth加工成clothes,</strong>假设我们现在有<strong>两个Activity</strong>中都要使用该工具类,我们要怎么使用Dagger2帮我们注入呢?</p>
<p>我们先用上面所学的方法试试,先在MainModule中添加提供方法:</p>
</blockquote>
<pre><code>@Module
public class MainModule {
     .....
    @PerActivity
    @Provides
    public ClothHandler getClothHandler(){
        return new ClothHandler();
    }
}
</code></pre><blockquote>
<p>再在MainActivity中声明依赖</p>
</blockquote>
<pre><code>public class MainActivity extends AppCompatActivity {
        .....    
    @Inject
    ClothHandler mClothHandler;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ......
    mTextView.setText(&quot;红布料加工后变成了&quot; + mClothHandler.handle(mRedCloth) + &quot;\nmClothHandler地址:&quot; + mClothHandler);
    }
    //在布局文件中声明的点击方法
    public void onclick(View view) {
        Intent intent = new Intent(this,SecondActivity.class);
        startActivity(intent);
    }
}
</code></pre><blockquote>
<p>同理在书写第二个Activity,并为它书写Module类Component接口</p>
</blockquote>
<pre><code>public class SecondActivity extends AppCompatActivity {
    private TextView tv;
    @Inject
    Cloth mBlueCloth;
    @Inject
    ClothHandler mClothHandler;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
        tv = (TextView) findViewById(R.id.tv2);
        SecondComponent component = DaggerSecondComponent.builder()
                .secondModule(new SecondModule())
                .build();
        component.inject(this);
        tv.setText(&quot;蓝布料加工后变成了&quot; + mClothHandler.handle(mBlueCloth) + &quot;\nmClothHandler地址:&quot; + mClothHandler);
    }
}

@Module
public class SecondModule {
    @PreActivity
    @Provides
    public Cloth getBlueCloth(){
        Cloth cloth = new Cloth();
        cloth.setColor(&quot;蓝色&quot;);
        return cloth;
    }
    @PreActivity
    @Provides
    public ClothHandler getClothHandler(){
        return new ClothHandler();
    }
}

@Component(modules = SecondModule.class)
@PreActivity
public interface SecondComponent {
    void inject(SecondActivity secondActivity);
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo4.png" alt=""><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo5.png" alt=""></p>
<blockquote>
<p>你会发现,虽然我们成功的将ClothHandler注入到了这两个Activity中,但是你会发现,这两个Activity中的ClothHandler<strong>实例不是一样的</strong>(验证了上面那个结论),并且我们发现这种注入方式要在每一个Module中都要提供getClothHandler方法, 假如有20个Activity都需要用到ClothHandler,那我们都这样写,不就代码重复了吗.并且我们还要实现单例,怎么办呢?Dagger2很贴心的为我们<strong>提供了Component依赖</strong>,就能完美的解决这个问题.</p>
<p>在面向对象的思想中,我们碰到这种情况一般都要<strong>抽取父类,</strong>Dagger2也是用的这种思想,我们先创建一个<strong>BaseModule</strong>,用来提供工具类:</p>
</blockquote>
<pre><code>@Module
public class BaseModule {
    @Singleton //单例
    @Provides
    public ClothHandler getClothHandler(){
        return new ClothHandler();
    }
}
</code></pre><blockquote>
<p>在创建一个BaseComponent接口:</p>
</blockquote>
<pre><code>@Singleton
@Component(modules = BaseModule.class)
public interface BaseComponent {
    ClothHandler getClothHandler();
}
</code></pre><blockquote>
<p>嗯?</p>
<p>这个Component怎么有点不一样,怎<strong>么没有inject方法呢?</strong>上面讲过,我们通过inject方法依赖需求方实例送到Component中,从而帮助依赖需求方实现依赖,但是我们<strong>这个BaseComponent是给其他Component提供依赖的</strong>,所以我们就可以不用inject方法,但是BaseComponent中多了一个<strong>getClothHandler方法,它的返回值是ClothHandler对象</strong>,这个方法有什么用呢?它的作用就是告诉<strong>依赖于BaseComponent的Component</strong>,<strong>BaseComponent能为你们提供ClothHandler对象</strong>,如果没有这个方法,BaseComponent就不能提供ClothHandler对象(这个提供规则和上面的依赖规则相同,可以实现单例).既然有了BaseComponent,那我们就可在其它Component中依赖它了.我们删除MainModule和SecondModule中的getClothHandler方法即可。</p>
<p>接下来在MainComponent和SecondComponent中声明依赖,就要用到@Component中的dependencies属性了:</p>
</blockquote>
<pre><code>@PreActivity
@Component(modules=MainModule.class,dependencies = BaseComponent.class)
public interface MainComponent {
    void inject(MainActivity mainActivity);
}

@PreActivity
@Component(modules = SecondModule.class,dependencies = BaseComponent.class)
public interface SecondComponent {
    void inject(SecondActivity secondActivity);
}
</code></pre><blockquote>
<p>下面我们用Android Studio中build菜单下的Rebuild Object选项后,你会发现创建MainComponent和SecondComponent实例时多了一个baseComponent方法:</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo6.png" alt=""> <img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo7.png" alt=""></p>
<blockquote>
<p>这个方法需要我们传入一个<strong>BaseComponent实例</strong>,原因很简单,MainComponent和SecondComponent既然<strong>依赖BaseComponent</strong>,肯定需要你传入一个<strong>BaseComponent实例</strong>给它,它才能从BaseComponent实例中获取到它需要的对象嘛.但是需要注意的是,如果要MainComponent和SecondComponent依赖到的对象是同一个的话(<strong>也就是单例</strong>),创建它们是<strong>传入的BaseComponent实例也必须是同一个</strong>,上面说过,不同的Component实例是无法提供相同的依赖实例的,因为它们之间是没有联系的.这样的话,我们就需要在MainActivity和SecondActivity中能获取到同一个BaseComponent实例,怎么样能实现呢?很多人一开始都会想到用<strong>静态工厂</strong>,这种方法可行,但是我们一般都会自定义一个<strong>Application类</strong>,用它来提供BaseComponent实例,因为在<strong>整个App生命周期内都只有一个Application实例</strong>,所以其中的BaseComponent实例也不会变.我们自定义一个MyApplication类</p>
</blockquote>
<pre><code>public class MyApplication extends Application {
    private BaseComponent baseComponent;
    @Override
    public void onCreate() {
        super.onCreate();
        baseComponent = DaggerBaseComponent.builder().baseModule(new BaseModule()).build();
    }

    public BaseComponent getBaseComponent() {
        return baseComponent;
    }
}
</code></pre><blockquote>
<p>我们在onCreate方法中创建BaseComponent实例,并对外提供获取方法.<br>这种方式还有一种好处,就是当我们在BaseModule中需要用到Application实例时,我们就可以在创建BaseModule时传入this.</p>
<p>接下来在AndroidManifest.xml中声明我们新建的MyApplication</p>
<p>接下来修改MainActivity和SecondActivity中的代码</p>
</blockquote>
<pre><code>MainComponent build = DaggerMainComponent
                .builder()
                .baseComponent(((MyApplication)getApplication()).getBaseComponent())
                .mainModule(new MainModule())
                .build();

SecondComponent component = DaggerSecondComponent
                .builder()
                .baseComponent(((MyApplication)getApplication()).getBaseComponent())
                .secondModule(new SecondModule())
                .build();
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo8.png" alt=""><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo9.png" alt=""></p>
<blockquote>
<p>我们成功的将ClothHandler注入到了这两个Activity中,并且还实现了单例.(注意:这里能实现单例跟BaseComponent中声明了@Singleton有很大关系,因为BaseComponent都没有单例的话,外部依赖它的Component就更不可能单例了).</p>
</blockquote>
<h4 id="Component的生命周期"><a href="#Component的生命周期" class="headerlink" title="Component的生命周期"></a>Component的生命周期</h4><blockquote>
<p>一般情况下我们都是在Activity的onCreate方法中创建Component实例,再调用inject方法完成依赖.所以Component依赖可以分为三个过程:</p>
</blockquote>
<ul>
<li><p>创建Component实例</p>
<p>  MainComponent component = DaggerMainComponent</p>
<pre><code>.builder()
.baseComponent(((MyApplication)getApplication()).getBaseComponent())
.mainModule(new MainModule())
.build();
</code></pre></li>
<li><p>调用inject方法</p>
<p>  component.inject(this);</p>
</li>
</ul>
<blockquote>
<p>调用完这个方法整个依赖就完成了.</p>
</blockquote>
<ul>
<li>Component实例被销毁</li>
</ul>
<blockquote>
<p>onCreate()方法调用完成后,Component实例就会因为没有被引用而被垃圾回收器回收.其中传入给Component实例的Module实例也会一同被回收,这也就能说明不同的Component实例之间是没有联系的(Component依赖除外).</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>至此,Dagger2<strong>基础</strong>已讲完,对于Dagger2在项目中的使用方法,可以参考github上的开源项目.</p>
<p>最后我们引用一下<a href="http://blog.piasy.com/2016/04/11/Dagger2-Scope-Instance/" target="_blank" rel="external">Dagger2 Scope 注解能保证依赖在 component 生命周期内的单例性吗？</a>中的注意事项:</p>
</blockquote>
<ul>
<li>component 的 inject 函数不要声明基类参数；</li>
<li>Scope 注解必须用在 module 的 provide 方法上，否则并不能达到局部单例的效果；</li>
<li>如果 module 的 provide 方法使用了 scope 注解，那么 component 就必须使用同一个注解，否则编译会失败；</li>
<li>如果 module 的 provide 方法没有使用 scope 注解，那么 component 和 module 是否加注解都无关紧要，可以通过编译，但是没有局部单例效果；</li>
<li>对于直接使用 @Inject 构造函数的依赖，如果把 scope 注解放到它的类上，而不是构造函数上，就能达到局部单例的效果了；</li>
<li>被依赖的Component能提供某个对象时,一定要在接口中声明以该对象为返回值的方法(也就是<strong>暴露接口</strong>).这样依赖它的Component才能获取到这种对象.</li>
</ul>
<blockquote>
<p><a href="https://github.com/sh2zqp/Dagger2Demo" target="_blank" rel="external">源码入口</a></p>
</blockquote>
<p><strong>参考资料</strong></p>
<p><a href="https://google.github.io/dagger/" target="_blank" rel="external">Google官方介绍</a><br><a href="https://dreamerhome.github.io/2016/07/07/dagger/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">依赖注入神器：Dagger2详解系列</a><br><a href="http://www.jianshu.com/p/1d84ba23f4d2" target="_blank" rel="external">Dagger2 入门,以初学者角度</a><br><a href="https://github.com/luxiaoming/dagger2Demo" target="_blank" rel="external">Dagger2图文完全教程</a><br><a href="http://blog.piasy.com/2016/04/11/Dagger2-Scope-Instance/" target="_blank" rel="external">Dagger2 Scope 注解能保证依赖在 component 生命周期内的单例性吗？</a><br><a href="https://github.com/codeestX/GeekNews" target="_blank" rel="external">GeekNews</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Dagger2&quot;&gt;&lt;a href=&quot;#什么是Dagger2&quot; class=&quot;headerlink&quot; title=&quot;什么是Dagger2&quot;&gt;&lt;/a&gt;什么是Dagger2&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Dagger2是Android中&lt;strong&gt;比
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="注解" scheme="http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="Dagger2" scheme="http://yoursite.com/tags/Dagger2/"/>
    
      <category term="依赖注入" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="Ioc" scheme="http://yoursite.com/tags/Ioc/"/>
    
      <category term="控制反转" scheme="http://yoursite.com/tags/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>Android内存优化之OOM</title>
    <link href="http://yoursite.com/2016/11/08/Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E4%B9%8BOOM/"/>
    <id>http://yoursite.com/2016/11/08/Android内存优化之OOM/</id>
    <published>2016-11-08T14:34:10.000Z</published>
    <updated>2016-11-08T14:34:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Android的<strong>内存优化</strong>是<strong>性能优化</strong>中很重要的一部分，而<strong>避免OOM</strong>又是内存优化中比较核心的一点，这是一篇关于内存优化中如何避免OOM的总结性概要文章，内容大多都是和OOM有关的实践总结概要。</p>
</blockquote>
<h3 id="Android的内存管理机制"><a href="#Android的内存管理机制" class="headerlink" title="Android的内存管理机制"></a>Android的内存管理机制</h3><blockquote>
<p>Google在Android的官网上有这样<a href="http://developer.android.com/training/articles/memory.html" target="_blank" rel="external">一篇文章</a>，初步介绍了Android是<strong>如何管理应用的进程与内存分配</strong>。 Android系统的<strong>Dalvik虚拟机</strong>扮演了<strong>常规的内存垃圾自动回收的角色</strong>，Android系统没有为内存提供<strong>交换区</strong>，它使用paging与memory-mapping(mapping)的机制来管理内存，下面简要概述一些Android系统中重要的内存管理基础概念。</p>
</blockquote>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><blockquote>
<p>Android系统通过下面几种方式来实现<strong>共享内存</strong>：</p>
</blockquote>
<ul>
<li>Android应用的<strong>进程</strong>都是从一个叫做<strong>Zygote的进程fork出来的</strong>。Zygote进程在系统启动并且载入通用的framework的代码与资源之后开始启动。为了启动一个<strong>新的程序进程</strong>，系统会fork Zygote进程生成一个新的进程，然后在新的进程中<strong>加载并运行应用程序的代码</strong>。这使得大多数的RAM pages被用来分配给framework的代码，同时使得RAM资源能够在应用的所有进程之间进行共享。</li>
<li>大多数static的数据被mapped到一个进程中。这不仅仅使得同样的数据能够在进程间进行共享，而且使得它能够在需要的时候被paged out。常见的static数据包括Dalvik Code，app resources，so文件等。</li>
<li>大多数情况下，Android通过显式的分配共享内存区域(例如ashram或者galloc)来实现动态RAM区域能够在不同进程之间进行共享的机制。例如，Window Surface在App与Screen Compositor之间使用共享的内存，Cursor Buffers在Content Provider与Clients之间共享内存。</li>
</ul>
<h4 id="分配与回收内存"><a href="#分配与回收内存" class="headerlink" title="分配与回收内存"></a>分配与回收内存</h4><ul>
<li>每一个进程的Dalvik heap都反映了使用内存的占用范围。这就是通常逻辑意义上提到的Dalvik Heap Size，它可以随着需要进行增长，但是增长行为会有一个系统为它设定的上限。</li>
<li>逻辑上讲的Heap Size和实际物理意义上使用的内存大小是不对等的，Proportional Set Size(PSS)记录了应用程序自身占用以及和其他进程进行共享的内存。</li>
<li>Android系统并不会对Heap中空闲内存区域做碎片整理。系统仅仅会在新的内存分配之前判断Heap的尾端剩余空间是否足够，如果空间不够会触发gc操作，从而腾出更多空闲的内存空间。在Android的高级系统版本里面针对Heap空间有一个Generational Heap Memory的模型，最近分配的对象会存放在Young Generation区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后累积一定时间再移动到Permanent Generation区域。系统会根据内存中不同的内存数据类型分别执行不同的gc操作。例如，刚分配到Young Generation区域的对象通常更容易被销毁回收，同时在Young Generation区域的gc操作速度会比Old Generation区域的gc操作速度更快。如下图所示：</li>
</ul>
<p><img src="http://hukai.me/images/memory_mode_generation.png" alt=""></p>
<p><img src="http://hukai.me/images/android_memory_gc_mode.png" alt=""></p>
<blockquote>
<p>每一个Generation的内存区域都有固定的大小，随着新的对象陆续被分配到此区域，当这些对象总的大小快达到这一级别内存区域的阀值时，会<strong>触发GC</strong>的操作，以便腾出空间来存放其他新的对象。如下图所示：</p>
</blockquote>
<p><img src="http://hukai.me/images/gc_threshold.png" alt=""></p>
<blockquote>
<p>通常情况下，GC发生的时候，所有的线程都是会被暂停的。执行GC所占用的时间和它发生在哪一个Generation也有关系，Young Generation中的每次GC操作时间是最短的，Old Generation其次，Permanent Generation最长。执行时间的长短也和当前Generation中的对象数量有关，遍历树结构查找20000个对象比起遍历50个对象自然是要慢很多的。</p>
</blockquote>
<h4 id="限制应用的内存"><a href="#限制应用的内存" class="headerlink" title="限制应用的内存"></a>限制应用的内存</h4><ul>
<li>为了整个Android系统的内存控制需要，Android系统为每一个应用程序都设置了一个硬性的<strong>Dalvik Heap Size</strong>最大限制阈值，这个阈值在不同的设备上会因为RAM大小不同而各有差异。如果你的应用占用内存空间已经接近这个阈值，此时再尝试分配内存的话，很容易引起<strong>OutOfMemoryError</strong>的错误。</li>
<li>ActivityManager.getMemoryClass()可以用来查询当前应用的Heap Size阈值，这个方法会返回一个整数，表明你的应用的Heap Size阈值是多少Mb(megabytes)。</li>
</ul>
<h4 id="应用切换操作"><a href="#应用切换操作" class="headerlink" title="应用切换操作"></a>应用切换操作</h4><ul>
<li>Android系统并不会在用户切换应用的时候做<strong>交换内存的操作</strong>。Android会把那些不包含<strong>Foreground组件</strong>的应用进程放到<strong>LRU Cache</strong>中。例如，当用户开始启动了一个应用，系统会为它创建了一个进程，但是当用户离开这个应用，此进程并<strong>不会立即被销毁</strong>，而是会被放到系统的<strong>Cache</strong>当中，如果用户后来再切换回到这个应用，此进程就能够被马上完整的恢复，从而实现应用的快速切换。</li>
<li>如果你的应用中有一个被缓存的进程，这个进程会占用一定的内存空间，它会对系统的整体性能有影响。因此当系统开始进入<strong>Low Memory的状态</strong>时，它会由系统根据<strong>LRU的规则与应用的优先级</strong>，<strong>内存占用情况</strong>以及其他因素的影响综合评估之后决定是否被杀掉。</li>
<li>对于那些非foreground的进程，Android系统是如何判断Kill掉哪些进程的问题，请参考<a href="http://developer.android.com/guide/components/processes-and-threads.html" target="_blank" rel="external">Processes and Threads</a>。</li>
</ul>
<h3 id="OOM-Out-Of-Memory-内存溢出"><a href="#OOM-Out-Of-Memory-内存溢出" class="headerlink" title="OOM(Out Of Memory)内存溢出"></a>OOM(Out Of Memory)内存溢出</h3><h4 id="什么是OOM"><a href="#什么是OOM" class="headerlink" title="什么是OOM?"></a>什么是OOM?</h4><pre><code>03-21 21:05:28.771: E/dalvikvm-heap(13316): Out of memory on a 10485776-byte allocation.
03-21 21:05:28.779: E/AndroidRuntime(13316): java.lang.OutOfMemoryError
</code></pre><blockquote>
<p>意思是: 我们程序申请需要10485776byte太大了，虚拟机无法满足我们，便Crash掉了。这个现象通常出现在用到<strong><em>很多图片或者很大图片</em></strong>的APP开发中。通俗讲就是当我们的APP需要申请一块内存来装图片的时候，系统觉得我们的APP所使用的内存已经够多了。即使它有1G的空余内存，它不同意给我的APP更多的内存里，然后即使系统马上抛出OOM错误，而程序没有捕捉该错误，故弹框崩溃了。</p>
<p>前面我们提到过使用<strong>getMemoryClass()</strong>的方法可以得到Dalvik Heap的阈值。简要的获取某个应用的内存占用情况可以参考下面的示例（ 关于更多内存查看的知识，可以参考这篇官方教程：<a href="http://developer.android.com/tools/debugging/debugging-memory.html" target="_blank" rel="external">Investigating Your RAM Usage</a> ）</p>
</blockquote>
<h4 id="为什么会有OOM"><a href="#为什么会有OOM" class="headerlink" title="为什么会有OOM?"></a>为什么会有OOM?</h4><blockquote>
<p>Android系统的app的每个进程或者每个虚拟机有个<strong>最大内存限制</strong>，如果申请的内存资源超过这个限制，系统就会抛出OOM错误。跟整个设备的剩余内存没太大关系。比如比较早的android系统的一个虚拟机最多<strong>16M内存</strong>，当一个app启动后，虚拟机不停的申请内存资源来装载图片，当超过内存上限时就出现OOM。Android系统的APP内存限制怎么确定？</p>
</blockquote>
<h4 id="Android的app内存组成"><a href="#Android的app内存组成" class="headerlink" title="Android的app内存组成"></a>Android的app内存组成</h4><blockquote>
<p>app内存由 <strong>dalvik内存 和 native内存</strong> 2部分组成:</p>
</blockquote>
<ul>
<li>dalvik也就是java堆，创建的对象就是就是在这里分配的</li>
<li>native是通过c/c++方式申请的内存，Bitmap就是以这种方式分配的</li>
</ul>
<blockquote>
<p>Android3.0以后，系统都默认通过dalvik分配的，native作为堆来管理。这2部分加起来不能超过android对单个进程，虚拟机的内存限制。</p>
<p>每个手机的内存限制大小是多少？</p>
</blockquote>
<pre><code>ActivityManager activityManager = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
activityManager.getMemoryClass();
</code></pre><blockquote>
<p>以上方法会返回以M为单位的数字，不同的系统平台或设备上的值都不太一样，比如HTC默认24M, Galaxy36M, emulator-2.3 24M，等等。我的moto xt681是42M。上面取到是虚拟机的最大内存资源。</p>
<p>而对于heap堆的大小限制，可以查看/system/build.prop文件</p>
</blockquote>
<pre><code>dalvik.vm.heapstartsize  =  5m
dalvik.vm.heapgrowthlimit = 48m
dalvik.vm.heapsize = 256m
</code></pre><blockquote>
<p>注： heapsize参数表示单个进程heap可用的最大内存，但如果存在以下参数”dalvik.vm.headgrowthlimit =48m”表示单个进程heap内存被限定在48m，即程序运行过程实际只能使用48m内存。</p>
</blockquote>
<h4 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h4><ul>
<li><p>通过命令行查看内存详细占用情况</p>
<p>  adb shell dumpsys meminfo -a com.zqp2sh.oomsample</p>
</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/App-MemoryInfo.png" alt=""></p>
<ul>
<li>通过Android Studio的Memory Monitor查看内存中Dalvik Heap的实时变化</li>
</ul>
<p><img src="http://hukai.me/images/android_perf_oom_studio_mem_monitor.png" alt=""></p>
<h4 id="发生OOM的条件"><a href="#发生OOM的条件" class="headerlink" title="发生OOM的条件"></a>发生OOM的条件</h4><blockquote>
<p>关于Native Heap，Dalvik Heap，Pss等内存管理机制比较复杂，这里不展开描述。简单的说，通过不同的内存分配方式（malloc/mmap/JNIEnv/etc）对不同的对象（bitmap，etc）进行操作会因为Android系统版本的差异而产生不同的行为，对Native Heap与Dalvik Heap以及OOM的判断条件都会有所影响。在2.x的系统上，我们常常可以看到Heap Size的total值明显超过了通过getMemoryClass()获取到的阈值而不会发生OOM的情况，那么针对2.x与4.x的Android系统，到底是如何判断会发生OOM呢？</p>
</blockquote>
<ul>
<li><p>Android 2.x系统 GC LOG中的dalvik allocated + external allocated + 新分配的大小 >= getMemoryClass()值的时候就会发生OOM。 例如，假设有这么一段Dalvik输出的GC LOG：GC_FOR_MALLOC free 2K, 13% free 32586K/37455K, external 8989K/10356K, paused 20ms，那么32586+8989+(新分配23975)=65550>64M时，就会发生OOM。</p>
</li>
<li><p>Android 4.x系统 Android 4.x的系统废除了external的计数器，类似bitmap的分配改到dalvik的java heap中申请，只要allocated + 新分配的内存 >= getMemoryClass()的时候就会发生OOM，如下图所示（虽然图示演示的是art运行环境，但是统计规则还是和dalvik保持一致）</p>
</li>
</ul>
<p><img src="http://hukai.me/images/android_perf_oom_gc_log.png" alt=""></p>
<h3 id="如何避免OOM总结"><a href="#如何避免OOM总结" class="headerlink" title="如何避免OOM总结"></a>如何避免OOM总结</h3><blockquote>
<p>前面介绍了一些基础的<strong>内存管理机制</strong>以及<strong>OOM的基础知识</strong>，那么在实践操作当中，有哪些指导性的规则可以参考呢？归纳下来，可以从四个方面着手，首先是<strong>减小对象的内存占用</strong>，其次是<strong>内存对象的重复利用</strong>，然后是<strong>避免对象的内存泄露</strong>，最后是<strong>内存使用策略优化</strong>。</p>
</blockquote>
<h4 id="减小对象的内存占用"><a href="#减小对象的内存占用" class="headerlink" title="减小对象的内存占用"></a>减小对象的内存占用</h4><blockquote>
<p>避免OOM的第一步就是要尽量<strong>减少新分配出来的对象占用内存的大小</strong>，尽量<strong>使用更加轻量的对象</strong>。</p>
</blockquote>
<ul>
<li>使用更加轻量的数据结构</li>
</ul>
<blockquote>
<p>例如，我们可以考虑使用<strong>ArrayMap/SparseArray</strong>而不是<strong>HashMap</strong>等传统数据结构，下图演示了HashMap的简要工作原理，相比起Android系统专门为移动操作系统编写的ArrayMap容器，在大多数情况下，都显示效率低下，更占内存。通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效在于他们避免了对key与value的autobox自动装箱，并且避免了装箱后的解箱。</p>
</blockquote>
<p><img src="http://hukai.me/images/android_perf_3_arraymap_key_value.png" alt=""></p>
<blockquote>
<p>关于更多ArrayMap/SparseArray的讨论，请参考<a href="http://hukai.me/android-performance-patterns-season-3/" target="_blank" rel="external">此文</a>的前三个段落</p>
</blockquote>
<ul>
<li>避免在Android里面使用Enum</li>
</ul>
<blockquote>
<p>Android官方培训课程提到过“Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.”，具体原理<a href="http://hukai.me/android-performance-patterns-season-3/" target="_blank" rel="external">请参考</a>，所以请避免在Android里面使用到枚举。</p>
</blockquote>
<ul>
<li>减小Bitmap对象的内存占用</li>
</ul>
<blockquote>
<p>Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用是很重要的，通常来说有下面2个措施：</p>
<ul>
<li>inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。</li>
<li>decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。</li>
</ul>
</blockquote>
<ul>
<li>使用更小的图片</li>
</ul>
<blockquote>
<p>在设计给到资源图片的时候，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用一张更小的图片。尽量使用更小的图片不仅仅可以减少内存的使用，还可以避免出现大量的InflationException。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图的时候就会因为内存不足而发生InflationException，这个问题的根本原因其实是发生了OOM。</p>
</blockquote>
<h4 id="内存对象的重复利用"><a href="#内存对象的重复利用" class="headerlink" title="内存对象的重复利用"></a>内存对象的重复利用</h4><blockquote>
<p>大多数对象的复用，最终实施的方案都是利用<strong>对象池技术</strong>，要么是在编写代码的时候显式的在程序里面去创建对象池，然后处理好复用的实现逻辑，要么就是利用系统框架既有的某些复用特性达到减少对象的重复创建，从而减少内存的分配与回收。</p>
</blockquote>
<p><img src="http://hukai.me/images/android_perf_2_object_pool.png" alt=""></p>
<blockquote>
<p>在Android上面最常用的一个缓存算法是LRU(Least Recently Use)，简要操作原理如下图所示：</p>
</blockquote>
<p><img src="http://hukai.me/images/android_perf_2_lru_mode.png" alt=""></p>
<ul>
<li>复用系统自带的资源</li>
</ul>
<blockquote>
<p>Android系统本身内置了很多的资源，例如字符串/颜色/图片/动画/样式以及简单布局等等，这些资源都可以在应用程序中直接引用。这样做不仅仅可以减少应用程序的自身负重，减小APK的大小，另外还可以一定程度上减少内存的开销，复用性更好。但是也有必要留意Android系统的版本差异性，对那些不同系统版本上表现存在很大差异，不符合需求的情况，还是需要应用程序自身内置进去。</p>
</blockquote>
<ul>
<li>注意在ListView/GridView等出现大量重复子组件的视图里面对ConvertView的复用</li>
</ul>
<p><img src="http://hukai.me/images/android_perf_oom_listview_recycle.png" alt=""></p>
<ul>
<li>Bitmap对象的复用<ul>
<li>在ListView与GridView等显示大量图片的控件里面需要使用LRU的机制来缓存处理好的Bitmap。<br>  <img src="http://hukai.me/images/android_perf_2_inbitmap_old.png" alt=""> </li>
<li>利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率上的提升(3.0以及4.4以后存在一些使用限制上的差异)。使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。<br>  <img src="http://hukai.me/images/android_perf_2_inbitmap_new.png" alt=""></li>
<li>使用inBitmap需要注意几个限制条件：<ul>
<li>在SDK 11 -> 18之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小。</li>
<li>新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了。 我们可以创建一个包含多种典型可重用bitmap的对象池，这样后续的bitmap创建都能够找到合适的“模板”去进行重用。如下图所示：<br>  <img src="http://hukai.me/images/android_perf_2_inbitmap_pool.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>另外提一点：在2.x的系统上，尽管bitmap是分配在native层，但是还是无法避免被计算到OOM的引用计数器里面。这里提示一下，不少应用会通过反射BitmapFactory.Options里面的inNativeAlloc来达到扩大使用内存的目的，但是如果大家都这么做，对系统整体会造成一定的负面影响，建议谨慎采纳。</p>
</blockquote>
<h4 id="避免在onDraw方法里面执行对象的创建"><a href="#避免在onDraw方法里面执行对象的创建" class="headerlink" title="避免在onDraw方法里面执行对象的创建"></a>避免在onDraw方法里面执行对象的创建</h4><blockquote>
<p>类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。</p>
</blockquote>
<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><blockquote>
<p>在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</p>
</blockquote>
<h3 id="避免对象的内存泄露"><a href="#避免对象的内存泄露" class="headerlink" title="避免对象的内存泄露"></a>避免对象的内存泄露</h3><blockquote>
<p>内存对象的泄漏，会导致一些不再使用的对象无法及时释放，这样一方面占用了宝贵的内存空间，很容易导致后续需要分配内存的时候，空闲空间不足而出现OOM。显然，这还使得每级Generation的内存区域可用空间变小，gc就会更容易被触发，容易出现内存抖动，从而引起性能问题。</p>
</blockquote>
<p><img src="http://hukai.me/images/android_perf_3_leak.png" alt=""></p>
<blockquote>
<p>最新的LeakCanary开源控件，可以很好的帮助我们发现内存泄露的情况，更多关于LeakCanary的介绍，请看<a href="https://github.com/square/leakcanary" target="_blank" rel="external">这里</a>(<a href="http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/" target="_blank" rel="external">中文</a>)。另外也可以使用传统的MAT工具查找内存泄露，请参考<a href="http://android-developers.blogspot.pt/2011/03/memory-analysis-for-android.html" target="_blank" rel="external">这里</a>（<a href="http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/" target="_blank" rel="external">中文</a>）.</p>
</blockquote>
<h4 id="注意Activity的泄漏"><a href="#注意Activity的泄漏" class="headerlink" title="注意Activity的泄漏"></a>注意Activity的泄漏</h4><blockquote>
<p>通常来说，<strong>Activity的泄漏</strong>是内存泄漏里面最严重的问题，它占用的内存多，影响面广，我们需要特别注意以下两种情况导致的Activity泄漏：</p>
</blockquote>
<ul>
<li><p><strong>内部类引用</strong>导致Activity的泄漏</p>
<blockquote>
<p>最典型的场景是<strong>Handler导致的Activity泄漏</strong>，如果Handler中有延迟的任务或者是等待执行的任务队列过长，都有可能因为Handler继续执行而导致Activity发生泄漏。此时的引用关系链是<strong>Looper -> MessageQueue -> Message -> Handler -> Activity</strong>。为了解决这个问题，可以在UI退出之前，<strong>执行remove Handler消息队列中的消息与runnable对象</strong>。或者是使用<strong>Static + WeakReference的方式</strong>来达到断开Handler与Activity之间存在引用关系的目的。</p>
</blockquote>
</li>
<li><p>Activity Context被传递到其他实例中，这可能导致自身被引用而发生泄漏。</p>
<blockquote>
<p>内部类引起的泄漏不仅仅会发生在Activity上，其他任何内部类出现的地方，都需要特别留意！我们可以考虑尽量使用static类型的内部类，同时使用WeakReference的机制来避免因为互相引用而出现的泄露。</p>
</blockquote>
</li>
</ul>
<h4 id="考虑使用Application-Context而不是Activity-Context"><a href="#考虑使用Application-Context而不是Activity-Context" class="headerlink" title="考虑使用Application Context而不是Activity Context"></a>考虑使用Application Context而不是Activity Context</h4><blockquote>
<p>对于大部分非必须使用Activity Context的情况（Dialog的Context就必须是Activity Context），我们都可以考虑使用Application Context而不是Activity的Context，这样可以避免不经意的Activity泄露。</p>
</blockquote>
<h4 id="注意临时Bitmap对象的及时回收"><a href="#注意临时Bitmap对象的及时回收" class="headerlink" title="注意临时Bitmap对象的及时回收"></a>注意临时Bitmap对象的及时回收</h4><blockquote>
<p>虽然在大多数情况下，我们会对Bitmap增加缓存机制，但是在某些时候，部分Bitmap是需要及时回收的。例如临时创建的某个相对比较大的bitmap对象，在经过变换得到新的bitmap对象之后，应该尽快回收原始的bitmap，这样能够更快释放原始bitmap所占用的空间。</p>
<p>需要特别留意的是Bitmap类里面提供的createBitmap()方法：</p>
</blockquote>
<p><img src="http://hukai.me/images/android_perf_oom_create_bitmap.png" alt=""></p>
<blockquote>
<p>这个函数返回的bitmap有可能和source bitmap是同一个，在回收的时候，需要特别检查source bitmap与return bitmap的引用是否相同，只有在不等的情况下，才能够执行source bitmap的recycle方法。</p>
</blockquote>
<h4 id="注意监听器的注销"><a href="#注意监听器的注销" class="headerlink" title="注意监听器的注销"></a>注意监听器的注销</h4><blockquote>
<p>在Android程序里面存在很多需要register与unregister的监听器，我们需要确保在合适的时候及时unregister那些监听器。自己手动add的listener，需要记得及时remove这个listener。</p>
</blockquote>
<h4 id="注意缓存容器中的对象泄漏"><a href="#注意缓存容器中的对象泄漏" class="headerlink" title="注意缓存容器中的对象泄漏"></a>注意缓存容器中的对象泄漏</h4><blockquote>
<p>有时候，我们为了提高对象的复用性把某些对象放到缓存容器中，可是如果这些对象没有及时从容器中清除，也是有可能导致内存泄漏的。例如，针对2.3的系统，如果把drawable添加到缓存容器，因为drawable与View的强应用，很容易导致activity发生泄漏。<strong>而从4.0开始，就不存在这个问题</strong>。解决这个问题，需要对2.3系统上的缓存drawable做特殊封装，处理引用解绑的问题，避免泄漏的情况。</p>
</blockquote>
<h4 id="注意WebView的泄漏"><a href="#注意WebView的泄漏" class="headerlink" title="注意WebView的泄漏"></a>注意WebView的泄漏</h4><blockquote>
<p>Android中的WebView存在很大的兼容性问题，不仅仅是Android系统版本的不同对WebView产生很大的差异，另外不同的厂商出货的ROM里面WebView也存在着很大的差异。更严重的是标准的WebView存在内存泄露的问题，看这里WebView causes memory leak - leaks the parent Activity。所以通常根治这个问题的办法是为WebView开启另外一个进程，通过AIDL与主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。</p>
</blockquote>
<h4 id="注意Cursor对象是否及时关闭"><a href="#注意Cursor对象是否及时关闭" class="headerlink" title="注意Cursor对象是否及时关闭"></a>注意Cursor对象是否及时关闭</h4><blockquote>
<p>在程序中我们经常会进行查询数据库的操作，但时常会存在不小心使用Cursor之后没有及时关闭的情况。这些Cursor的泄露，反复多次出现的话会对内存管理产生很大的负面影响，我们需要谨记对Cursor对象的及时关闭。</p>
</blockquote>
<h3 id="内存使用策略优化"><a href="#内存使用策略优化" class="headerlink" title="内存使用策略优化"></a>内存使用策略优化</h3><h4 id="谨慎使用large-heap"><a href="#谨慎使用large-heap" class="headerlink" title="谨慎使用large heap"></a>谨慎使用large heap</h4><blockquote>
<p>正如前面提到的，Android设备根据硬件与软件的设置差异而存在不同大小的内存空间，他们为应用程序设置了不同大小的Heap限制阈值。你可以通过调用getMemoryClass()来获取应用的可用Heap大小。在一些特殊的情景下，你可以通过在manifest的application标签下添加largeHeap=true的属性来为应用声明一个更大的heap空间。然后，你可以通过getLargeMemoryClass()来获取到这个更大的heap size阈值。然而，声明得到更大Heap阈值的本意是为了一小部分会消耗大量RAM的应用(例如一个大图片的编辑应用)。不要轻易的因为你需要使用更多的内存而去请求一个大的Heap Size。只有当你清楚的知道哪里会使用大量的内存并且知道为什么这些内存必须被保留时才去使用large heap。因此请谨慎使用large heap属性。使用额外的内存空间会影响系统整体的用户体验，并且会使得每次gc的运行时间更长。在任务切换时，系统的性能会大打折扣。另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行getMemoryClass()来检查实际获取到的heap大小。</p>
</blockquote>
<h4 id="综合考虑设备内存阈值与其他因素设计合适的缓存大小"><a href="#综合考虑设备内存阈值与其他因素设计合适的缓存大小" class="headerlink" title="综合考虑设备内存阈值与其他因素设计合适的缓存大小"></a>综合考虑设备内存阈值与其他因素设计合适的缓存大小</h4><blockquote>
<p>例如，在设计ListView或者GridView的Bitmap LRU缓存的时候，需要考虑的点有：</p>
<ul>
<li>应用程序剩下了多少可用的内存空间?</li>
<li>有多少图片会被一次呈现到屏幕上？有多少图片需要事先缓存好以便快速滑动时能够立即显示到屏幕？</li>
<li>设备的屏幕大小与密度是多少? 一个xhdpi的设备会比hdpi需要一个更大的Cache来hold住同样数量的图片。</li>
<li>不同的页面针对Bitmap的设计的尺寸与配置是什么，大概会花费多少内存？</li>
<li>页面图片被访问的频率？是否存在其中的一部分比其他的图片具有更高的访问频繁？如果是，也许你想要保存那些最常访问的到内存中，或者为不同组别的位图(按访问频率分组)设置多个LruCache容器。</li>
</ul>
</blockquote>
<h4 id="onLowMemory-与onTrimMemory"><a href="#onLowMemory-与onTrimMemory" class="headerlink" title="onLowMemory()与onTrimMemory()"></a>onLowMemory()与onTrimMemory()</h4><blockquote>
<p>Android用户可以随意在不同的应用之间进行快速切换。为了让background的应用能够迅速的切换到forground，每一个background的应用都会占用一定的内存。Android系统会根据当前的系统的内存使用情况，决定回收部分background的应用内存。如果background的应用从暂停状态直接被恢复到forground，能够获得较快的恢复体验，如果background应用是从Kill的状态进行恢复，相比之下就显得稍微有点慢。</p>
</blockquote>
<p><img src="http://hukai.me/images/android_perf_3_memory_bg_2_for.png" alt=""></p>
<ul>
<li><p>onLowMemory()：Android系统提供了一些回调来通知当前应用的内存使用情况，通常来说，当所有的background应用都被kill掉的时候，forground应用会收到onLowMemory()的回调。在这种情况下，需要尽快释放当前应用的非必须的内存资源，从而确保系统能够继续稳定运行。</p>
</li>
<li><p>onTrimMemory(int)：Android系统从4.0开始还提供了onTrimMemory()的回调，当系统内存达到某些条件的时候，所有正在运行的应用都会收到这个回调，同时在这个回调里面会传递以下的参数，代表不同的内存使用情况，收到onTrimMemory()回调的时候，需要根据传递的参数类型进行判断，合理的选择释放自身的一些内存占用，一方面可以提高系统的整体运行流畅度，另外也可以避免自己被系统判断为优先需要杀掉的应用。下图介绍了各种不同的回调参数：</p>
<ul>
<li><p>TRIM_MEMORY_UI_HIDDEN：你的应用程序的所有UI界面被隐藏了，即用户点击了Home键或者Back键退出应用，导致应用的UI界面完全不可见。这个时候应该释放一些不可见的时候非必须的资源  </p>
<blockquote>
<p>当程序正在前台运行的时候，可能会接收到从onTrimMemory()中返回的下面的值之一:</p>
</blockquote>
</li>
</ul>
</li>
<li><p>TRIM_MEMORY_RUNNING_MODERATE：你的应用正在运行并且不会被列为可杀死的。但是设备此时正运行于低内存状态下，系统开始触发杀死LRU Cache中的Process的机制。</p>
<ul>
<li>TRIM_MEMORY_RUNNING_LOW：你的应用正在运行且没有被列为可杀死的。但是设备正运行于更低内存的状态下，你应该释放不用的资源用来提升系统性能。</li>
<li><p>TRIM_MEMORY_RUNNING_CRITICAL：你的应用仍在运行，但是系统已经把LRU Cache中的大多数进程都已经杀死，因此你应该立即释放所有非必须的资源。如果系统不能回收到足够的RAM数量，系统将会清除所有的LRU缓存中的进程，并且开始杀死那些之前被认为不应该杀死的进程，例如那个包含了一个运行态Service的进程。</p>
<blockquote>
<p>当应用进程退到后台正在被Cached的时候，可能会接收到从onTrimMemory()中返回的下面的值之一：</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>-TRIM_MEMORY_BACKGROUND: 系统正运行于低内存状态并且你的进程正处于LRU缓存名单中最不容易杀掉的位置。尽管你的应用进程并不是处于被杀掉的高危险状态，系统可能已经开始杀掉LRU缓存中的其他进程了。你应该释放那些容易恢复的资源，以便于你的进程可以保留下来，这样当用户回退到你的应用的时候才能够迅速恢复。</p>
<ul>
<li><p>TRIM_MEMORY_MODERATE: 系统正运行于低内存状态并且你的进程已经已经接近LRU名单的中部位置。如果系统开始变得更加内存紧张，你的进程是有可能被杀死的。</p>
<ul>
<li><p>TRIM_MEMORY_COMPLETE: 系统正运行于低内存的状态并且你的进程正处于LRU名单中最容易被杀掉的位置。你应该释放任何不影响你的应用恢复状态的资源。</p>
<p>  <img src="http://hukai.me/images/android_perf_3_memory_ontrimmemory.png" alt=""></p>
</li>
</ul>
</li>
<li><p>因为onTrimMemory()的回调是在API 14才被加进来的，对于老的版本，你可以使用onLowMemory)回调来进行兼容。onLowMemory相当与TRIM_MEMORY_COMPLETE。</p>
</li>
<li>请注意：当系统开始清除LRU缓存中的进程时，虽然它首先按照LRU的顺序来执行操作，但是它同样会考虑进程的内存使用量以及其他因素。占用越少的进程越容易被留下来。</li>
</ul>
<h4 id="资源文件需要选择合适的文件夹进行存放"><a href="#资源文件需要选择合适的文件夹进行存放" class="headerlink" title="资源文件需要选择合适的文件夹进行存放"></a>资源文件需要选择合适的文件夹进行存放</h4><blockquote>
<p>我们知道hdpi/xhdpi/xxhdpi等等不同dpi的文件夹下的图片在不同的设备上会经过scale的处理。例如我们只在hdpi的目录下放置了一张100*100的图片，那么根据换算关系，xxhdpi的手机去引用那张图片就会被拉伸到200*200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下。</p>
</blockquote>
<h4 id="Try-catch某些大内存分配的操作"><a href="#Try-catch某些大内存分配的操作" class="headerlink" title="Try catch某些大内存分配的操作"></a>Try catch某些大内存分配的操作</h4><blockquote>
<p>在某些情况下，我们需要事先评估那些可能发生OOM的代码，对于这些可能发生OOM的代码，加入catch机制，可以考虑在catch里面尝试一次降级的内存分配操作。例如decode bitmap的时候，catch到OOM，可以尝试把采样比例再增加一倍之后，再次尝试decode。</p>
</blockquote>
<h4 id="谨慎使用static对象"><a href="#谨慎使用static对象" class="headerlink" title="谨慎使用static对象"></a>谨慎使用static对象</h4><blockquote>
<p>因为static的生命周期过长，和应用的进程保持一致，使用不当很可能导致对象泄漏，在Android中应该谨慎使用static对象。</p>
</blockquote>
<p><img src="http://hukai.me/images/android_perf_3_leak_static.png" alt=""></p>
<h4 id="特别留意单例对象中不合理的持有"><a href="#特别留意单例对象中不合理的持有" class="headerlink" title="特别留意单例对象中不合理的持有"></a>特别留意单例对象中不合理的持有</h4><blockquote>
<p>虽然单例模式简单实用，提供了很多便利性，但是因为单例的生命周期和应用保持一致，使用不合理很容易出现持有对象的泄漏。</p>
</blockquote>
<h4 id="珍惜Services资源"><a href="#珍惜Services资源" class="headerlink" title="珍惜Services资源"></a>珍惜Services资源</h4><blockquote>
<p>如果你的应用需要在后台使用service，除非它被触发并执行一个任务，否则其他时候Service都应该是停止状态。另外需要注意当这个service完成任务之后因为停止service失败而引起的内存泄漏。 当你启动一个Service，系统会倾向为了保留这个Service而一直保留Service所在的进程。这使得进程的运行代价很高，因为系统没有办法把Service所占用的RAM空间腾出来让给其他组件，另外Service还不能被Paged out。这减少了系统能够存放到LRU缓存当中的进程数量，它会影响应用之间的切换效率，甚至会导致系统内存使用不稳定，从而无法继续保持住所有目前正在运行的service。 建议使用IntentService，它会在处理完交代给它的任务之后尽快结束自己。更多信息，请阅读Running in a Background Service。</p>
</blockquote>
<h4 id="优化布局层次，减少内存消耗"><a href="#优化布局层次，减少内存消耗" class="headerlink" title="优化布局层次，减少内存消耗"></a>优化布局层次，减少内存消耗</h4><blockquote>
<p>越扁平化的视图布局，占用的内存就越少，效率越高。我们需要尽量保证布局足够扁平化，当使用系统提供的View无法实现足够扁平的时候考虑使用自定义View来达到目的。</p>
</blockquote>
<h4 id="谨慎使用“抽象”编程"><a href="#谨慎使用“抽象”编程" class="headerlink" title="谨慎使用“抽象”编程"></a>谨慎使用“抽象”编程</h4><blockquote>
<p>很多时候，开发者会使用抽象类作为”好的编程实践”，因为抽象能够提升代码的灵活性与可维护性。然而，抽象会导致一个显著的额外内存开销：他们需要同等量的代码用于可执行，那些代码会被mapping到内存中，因此如果你的抽象没有显著的提升效率，应该尽量避免他们。</p>
</blockquote>
<h4 id="使用nano-protobufs序列化数据"><a href="#使用nano-protobufs序列化数据" class="headerlink" title="使用nano protobufs序列化数据"></a>使用nano protobufs序列化数据</h4><blockquote>
<p>Protocol buffers是由Google为序列化结构数据而设计的，一种语言无关，平台无关，具有良好的扩展性。类似XML，却比XML更加轻量，快速，简单。如果你需要为你的数据实现序列化与协议化，建议使用nano protobufs。关于更多细节，请参考protobuf readme的”Nano version”章节。</p>
</blockquote>
<h4 id="谨慎使用依赖注入框架"><a href="#谨慎使用依赖注入框架" class="headerlink" title="谨慎使用依赖注入框架"></a>谨慎使用依赖注入框架</h4><blockquote>
<p>使用类似Guice或者RoboGuice等框架注入代码，在某种程度上可以简化你的代码。下面是使用RoboGuice前后的对比图：</p>
</blockquote>
<p><img src="http://hukai.me/images/android_perf_oom_roboguice_1.png" alt=""></p>
<p><img src="http://hukai.me/images/android_perf_oom_roboguice_2.png" alt=""></p>
<blockquote>
<p>使用RoboGuice之后，代码是简化了不少。然而，那些注入框架会通过扫描你的代码执行许多初始化的操作，这会导致你的代码需要大量的内存空间来mapping代码，而且mapped pages会长时间的被保留在内存中。除非真的很有必要，建议谨慎使用这种技术。</p>
</blockquote>
<h4 id="谨慎使用多进程"><a href="#谨慎使用多进程" class="headerlink" title="谨慎使用多进程"></a>谨慎使用多进程</h4><blockquote>
<p>使用多进程可以把应用中的部分组件运行在单独的进程当中，这样可以扩大应用的内存占用范围，但是这个技术必须谨慎使用，绝大多数应用都不应该贸然使用多进程，一方面是因为使用多进程会使得代码逻辑更加复杂，另外如果使用不当，它可能反而会导致显著增加内存。当你的应用需要运行一个常驻后台的任务，而且这个任务并不轻量，可以考虑使用这个技术。</p>
<p>一个典型的例子是创建一个可以长时间后台播放的Music Player。如果整个应用都运行在一个进程中，当后台播放的时候，前台的那些UI资源也没有办法得到释放。类似这样的应用可以切分成2个进程：一个用来操作UI，另外一个给后台的Service。</p>
</blockquote>
<h4 id="使用ProGuard来剔除不需要的代码"><a href="#使用ProGuard来剔除不需要的代码" class="headerlink" title="使用ProGuard来剔除不需要的代码"></a>使用ProGuard来剔除不需要的代码</h4><blockquote>
<p>ProGuard能够通过移除不需要的代码，重命名类，域与方法等等对代码进行压缩，优化与混淆。使用ProGuard可以使得你的代码更加紧凑，这样能够减少mapping代码所需要的内存空间。</p>
</blockquote>
<h4 id="谨慎使用第三方libraries"><a href="#谨慎使用第三方libraries" class="headerlink" title="谨慎使用第三方libraries"></a>谨慎使用第三方libraries</h4><blockquote>
<p>很多开源的library代码都不是为移动网络环境而编写的，如果运用在移动设备上，并不一定适合。即使是针对Android而设计的library，也需要特别谨慎，特别是在你不知道引入的library具体做了什么事情的时候。例如，其中一个library使用的是nano protobufs, 而另外一个使用的是micro protobufs。这样一来，在你的应用里面就有2种protobuf的实现方式。这样类似的冲突还可能发生在输出日志，加载图片，缓存等等模块里面。另外不要为了1个或者2个功能而导入整个library，如果没有一个合适的库与你的需求相吻合，你应该考虑自己去实现，而不是导入一个大而全的解决方案。</p>
</blockquote>
<h4 id="考虑不同的实现方式来优化内存占用"><a href="#考虑不同的实现方式来优化内存占用" class="headerlink" title="考虑不同的实现方式来优化内存占用"></a>考虑不同的实现方式来优化内存占用</h4><blockquote>
<p>在某些情况下，设计的某个方案能够快速实现需求，但是这个方案却可能在内存占用上表现的效率不够好。例如：</p>
</blockquote>
<p><img src="http://hukai.me/images/android_perf_2_waer_animation.png" alt=""></p>
<blockquote>
<p>对于上面这样一个时钟表盘的实现，最简单的就是使用很多张包含指针的表盘图片，使用帧动画实现指针的旋转。但是如果把指针扣出来，单独进行旋转绘制，显然比载入N多张图片占用的内存要少很多。当然这样做，代码复杂度上会有所增加，这里就需要在优化内存占用与实现简易度之间进行权衡了。</p>
</blockquote>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><ul>
<li>设计风格很大程度上会影响到程序的内存与性能，相对来说，如果大量使用类似Material Design的风格，不仅安装包可以变小，还可以减少内存的占用，渲染性能与加载性能都会有一定的提升。</li>
<li>内存优化并不就是说程序占用的内存越少就越好，如果因为想要保持更低的内存占用，而频繁触发执行gc操作，在某种程度上反而会导致应用性能整体有所下降，这里需要综合考虑做一定的权衡。</li>
<li>Android的内存优化涉及的知识面还有很多：内存管理的细节，垃圾回收的工作原理，如何查找内存泄漏等等都可以展开讲很多。OOM是内存优化当中比较突出的一点，尽量减少OOM的概率对内存优化有着很大的意义。</li>
</ul>
<p><strong>参考资料</strong><br><a href="http://hukai.me/android-performance-oom/" target="_blank" rel="external">http://hukai.me/android-performance-oom/</a><br><a href="http://hukai.me/android-performance-oom/" target="_blank" rel="external">Android内存优化之OOM</a><br><a href="https://my.oschina.net/caikezhan/blog/168955" target="_blank" rel="external">Android Out Of Memory(OOM) 的详细研究</a><br><a href="https://segmentfault.com/a/1190000005180612" target="_blank" rel="external">一次解决OOM的经历</a><br><a href="http://www.yinqisen.cn/blog-316.html#static" target="_blank" rel="external">Android 内存优化，如何避免OOM</a><br><a href="http://mzh3344258.blog.51cto.com/1823534/804237" target="_blank" rel="external">Android 内存溢出解决方案（OOM） 整理总结</a><br><a href="http://www.runoob.com/w3cnote/android-oom.html" target="_blank" rel="external">Android应用中OOM问题剖析和解决方案</a><br><a href="http://www.jianshu.com/p/f5d8d3066b36" target="_blank" rel="external">Android避免OOM（内存优化）</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/9316683" target="_blank" rel="external">Android高效加载大图、多图解决方案，有效避免程序OOM</a><br><a href="http://www.jianshu.com/p/c49f778e7acf" target="_blank" rel="external">使用Android studio分析内存泄露</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android的&lt;strong&gt;内存优化&lt;/strong&gt;是&lt;strong&gt;性能优化&lt;/strong&gt;中很重要的一部分，而&lt;strong&gt;避免OOM&lt;/strong&gt;又是内存优化中比较核心的一点，这是一篇关于内存优化中如何避免OOM的总结性概要文章
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OOM" scheme="http://yoursite.com/tags/OOM/"/>
    
      <category term="内存优化" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio打包～生成jks密钥～签名apk～多渠道打包</title>
    <link href="http://yoursite.com/2016/10/29/AndroidStudio%E7%94%9F%E6%88%90jks%E5%AF%86%E9%92%A5%EF%BD%9E%E7%AD%BE%E5%90%8Dapk%EF%BD%9E%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/2016/10/29/AndroidStudio生成jks密钥～签名apk～多渠道打包/</id>
    <published>2016-10-29T13:05:55.000Z</published>
    <updated>2016-11-01T01:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h3 id="生成jks签名"><a href="#生成jks签名" class="headerlink" title="生成jks签名"></a>生成jks签名</h3><p><img src="http://o9zgq2ik9.bkt.clouddn.com/release1.png" alt=""></p>
<blockquote>
<p>1.选择Build > Generate Signed APK</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release2.png" alt=""></p>
<blockquote>
<p>2.选择项目app > Next</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release3.png" alt=""></p>
<blockquote>
<p>如果以前没有生成过 .jks密钥 文件，选择Create new，否则选择Choose existing</p>
<p>3.我们选择Create new新创建一个 .jks密钥 文件</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release4.png" alt=""></p>
<blockquote>
<p>4.选择签名文件的路径，把这些信息填完点击OK</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release5.png" alt=""></p>
<blockquote>
<p>5.选择Next继续完成下一步</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release6.png" alt=""></p>
<blockquote>
<p>Build Type 选择 release，由于我们还没有为项目添加任何第三方的打包渠道，所以此时No Flavors可以选择。</p>
<p>6.选择Finish，签名生成</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release7.png" alt=""></p>
<blockquote>
<p><strong>注意</strong>：在第3步，我们选择了Create new去生成一个新的 .jks 密钥文件，之后我们在对项目进行打包签名时则可以直接选择Choose existing即可。</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release8.png" alt=""></p>
<blockquote>
<p>选择已经存在的.jks密钥文件，点击OK即可，后面步骤如前所描述。</p>
</blockquote>
<h3 id="多渠道打包"><a href="#多渠道打包" class="headerlink" title="多渠道打包"></a>多渠道打包</h3><blockquote>
<p>国内Android App市场很多，每次发版几十个<strong>渠道包</strong>。Android Gradle给我们提供了<strong>productFlavors</strong>，让我们可以很方便地对生成的APK包进行定制。</p>
<p>1.在AndroidManifest.xml文件中<strong>添加渠道表示标签</strong></p>
</blockquote>
<pre><code>&lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;@string/app_name&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/AppTheme&quot;&gt;
        &lt;activity android:name=&quot;.WebViewActivity&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;
                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;

        &lt;!-- UMeng 配置--&gt;
        &lt;meta-data android:value=&quot;${UMENG_CHANNEL_VALUE}&quot; android:name=&quot;UMENG_CHANNEL&quot;/&gt;

&lt;/application&gt;
</code></pre><blockquote>
<p>2.在build.gradle(Module: app)文件中添加多渠道</p>
</blockquote>
<pre><code>apply plugin: &apos;com.android.application&apos;

android {
    compileSdkVersion 24
    buildToolsVersion &quot;24.0.2&quot;
    defaultConfig {
        applicationId &quot;com.zqp2sh.webviewwraph5&quot;
        minSdkVersion 15
        targetSdkVersion 24
        versionCode 1
        versionName &quot;1.0&quot;
        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;
    }
buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        }
}

// 添加多渠道
productFlavors {
        xiaomi {}
        qihu360 {}
        baidu {}
        wandoujia {}
}
productFlavors.all {
        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]
    }
}

dependencies {
    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, {
        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;
    })
    compile &apos;com.android.support:appcompat-v7:24.2.1&apos;
    testCompile &apos;junit:junit:4.12&apos;
    compile &apos;com.android.support:design:24.2.1&apos;
}
</code></pre><blockquote>
<p>添加完之后我们在点击一下Gradle 的构建按钮重新构建一下 </p>
</blockquote>
<p><strong>回顾</strong></p>
<blockquote>
<p>此时我们在进行.jks密钥文件生成时，就会发现此时的Flavors会出现4个渠道选项，我们可以任意选择，如下：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release.22.png" alt=""></p>
<blockquote>
<p>选中之后，点击Finish即可进行签名打包，生成响应的apk：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release.23.png" alt=""></p>
<blockquote>
<p>3.测试</p>
<p>通过Java代码获取到<strong>meta标签</strong>中的value来测试是否成功实现了多渠道打包：</p>
</blockquote>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
//        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
//                WindowManager.LayoutParams.FLAG_FULLSCREEN);
        setContentView(R.layout.activity_webview);

        getWindow().setBackgroundDrawableResource(android.R.color.transparent);

        init();
        initWebView();

        String umeng_channel = getApplicationMetaValue(&quot;UMENG_CHANNEL&quot;);
        Log.d(&quot;Science&quot;, umeng_channel);
}

/**
*  测试多渠道打包
*/
private String  getApplicationMetaValue(String name) {
        String value= &quot;&quot;;
        try {
            ApplicationInfo appInfo =getPackageManager()
                    .getApplicationInfo(getPackageName(),
                            PackageManager.GET_META_DATA);
            value = appInfo.metaData.getString(name);
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
        }
        return value;
}
</code></pre><blockquote>
<p>测试代码添加完毕之后，我们现在点击AS左下角的Gradle，我们此时就可以看到我们刚才添加的xiaomi、qihu360、baidu、wandoujia都出现了，如下图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release9.png" alt=""><img src="http://o9zgq2ik9.bkt.clouddn.com/release10.png" alt=""></p>
<blockquote>
<p>此时我们双击［installBaiduDebug］, apk成功的安装到你的手机上了，手机不会自动给你打开app，需要手动打开，然后就可以在控制台看到日志如下：</p>
</blockquote>
<pre><code>10-29 22:55:04.154 12335-12335/com.zqp2sh.webviewwraph5 D/Science: baidu
</code></pre><blockquote>
<p>进入图示目录可以看到生成的响应apk，此时还没有签名：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release11.png" alt=""></p>
<blockquote>
<p><strong>注意：保持有手机与AS相连接</strong></p>
<p>然后我们在双击［installXiaomiDebug］，然后看看</p>
</blockquote>
<pre><code>&apos;&apos;10-29 22:55:04.154 12335-12335/com.zqp2sh.webviewwraph5 D/Science: xiaomi
</code></pre><blockquote>
<p>进入图示目录可以看到生成的响应apk，此时还没有签名：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release12.png" alt=""></p>
<blockquote>
<p>其他的渠道也是一样的操作方式，不在一一说明。</p>
<p>小结: 这里我们在AndroidManifest.xml文件中添加了<strong>meta标签</strong>、在build.gradle(Module: app)中添加了渠道产品对应的<strong>渠道名称</strong> ，最后我们<strong>测试多渠道打包</strong>，这里还最重要的一点就是: 没有让大家去运行什么命令，全部是让大家点击来实现的，其实点击就是在<strong>运行命令</strong>：</p>
</blockquote>
<pre><code>./gradew installXiaomiDebug 
</code></pre><h3 id="一键完成打包-全部产品-并签名"><a href="#一键完成打包-全部产品-并签名" class="headerlink" title="一键完成打包(全部产品)并签名"></a>一键完成打包(全部产品)并签名</h3><blockquote>
<p>正如标题所示，我们如果要<strong>打包所有的产品</strong>，肯定不能像刚才一样一个一个来打，那么现在来使用另外一个按钮(命令)<strong>assemble</strong>，如下：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release13.png" alt=""></p>
<blockquote>
<p>然后切换项目到Project视图，找到app>build>outputs>apk,结果如下我们看到所有版本的apk都有了，有debug版的，debug没有签名的，release没有签名的。</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release14.png" alt=""></p>
<blockquote>
<p>如果我们现在只想打包所有的release版本怎么办呢？看下面的图，如果想打release版就双击(assembleRelease),如果想打所有的debug版本就双击(assembleDebug)</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release15.png" alt=""></p>
<blockquote>
<p>现在我们就可以通过不同的按钮打包不同类型的apk了。</p>
</blockquote>
<p><strong>常用的打包命令</strong></p>
<pre><code>./gradlew assembleDebug 编译并打Debug包
./gradlew assembleRelease 编译并打Release的包
./gradlew installRelease Release模式打包并安装
./gradlew uninstallRelease 卸载Release模式包
 .....
</code></pre><p><strong>问题: 所有的apk生成了，但是没有签名是发布不了的，怎么办？</strong></p>
<blockquote>
<p>1.点击项目架构按钮，如下，或使快捷键：Command + ;</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release16.png" alt=""></p>
<blockquote>
<p>2.然后点击app>Signing > + ，然后填写上签名信息，最后点击OK</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release17.png" alt=""></p>
<blockquote>
<p>我们做的上述操作其实就是在build.gradle(Module: app)文件中添加如下信息：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release18.png" alt=""></p>
<blockquote>
<p>此时我们把apk下面的apk文件删掉，然后双击assembleRelease，结果发现还是没有签名，你在逗我？</p>
<p><strong>注意：</strong> 我们目前为止只是<strong>配置了签名信息</strong>，但是并没有给产品(apk)指定，我们只需要在build.gradle(Module: app)文件中添加如下的代码就 ok了，我们来试试看。</p>
</blockquote>
<pre><code>//指定签名为release
signingConfig signingConfigs.release
</code></pre><p><img src="http://o9zgq2ik9.bkt.clouddn.com/release19.png" alt=""></p>
<blockquote>
<p>现在删掉apk文件夹下所有的apk，然后选择assembleRelease, 然后点击run按钮，如下图，这里的run会记录我们最近使用的run脚本名称.</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release20.png" alt=""></p>
<blockquote>
<p>现在我们来看看apk目录下的安装包是否签名：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/release21.png" alt=""></p>
<p><strong>补充</strong></p>
<blockquote>
<p>安装apk的命令(包名一样版本号一样，所以只能存在一个，在进行多个渠道apk安装测试时，一台手机上只能安装一个)</p>
</blockquote>
<pre><code>adb install apk路径/app-渠道名-release.apk
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>我们在第一部分生成了.jks密钥文件，以便于后续部分的使用，然后进行多渠道打包：在<strong>manifast文件</strong>中添加了<strong>meta渠道标签</strong>，然后修改了<strong>gradle的文件</strong>添加了<strong>不同的渠道产品</strong>，最后我们在代码中读取了meta标签的value并且在进行了日志打印。最后我们又添加了签名配置，指定了给release版本的签名，签名的名称是release，并最终搞定了一键多渠道打包签名。</p>
</blockquote>
<p><strong>参考资料</strong><br><a href="http://blog.csdn.net/yy1300326388/article/details/48344411" target="_blank" rel="external">http://blog.csdn.net/yy1300326388/article/details/48344411</a><br><a href="http://blog.csdn.net/yy1300326388/article/details/48296221" target="_blank" rel="external">http://blog.csdn.net/yy1300326388/article/details/48296221</a><br><a href="http://wuxiaolong.me/2016/04/01/gradle4android3/" target="_blank" rel="external">http://wuxiaolong.me/2016/04/01/gradle4android3/</a><br><a href="http://www.rocidea.com/roc-23118.aspx" target="_blank" rel="external">http://www.rocidea.com/roc-23118.aspx</a><br><a href="http://mouxuejie.com/blog/2016-08-06/build-and-multichannel-package-practice/" target="_blank" rel="external">http://mouxuejie.com/blog/2016-08-06/build-and-multichannel-package-practice/</a><br><a href="http://www.jianshu.com/p/bb681879a291" target="_blank" rel="external">http://www.jianshu.com/p/bb681879a291</a><br><a href="http://blog.qiji.tech/archives/1050" target="_blank" rel="external">http://blog.qiji.tech/archives/1050</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;生成jks签名&quot;&gt;&lt;a href=&quot;#生成jks签名&quot; class=&quot;headerlink&quot; title=&quot;生成jks签名&quot;&gt;&lt;/a&gt;生成jks签名&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://o9zgq2ik9.bkt.clouddn.com/re
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="AndroidStudio" scheme="http://yoursite.com/tags/AndroidStudio/"/>
    
      <category term="AS" scheme="http://yoursite.com/tags/AS/"/>
    
      <category term="jks密钥生成" scheme="http://yoursite.com/tags/jks%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90/"/>
    
      <category term="apk签名" scheme="http://yoursite.com/tags/apk%E7%AD%BE%E5%90%8D/"/>
    
      <category term="多渠道打包" scheme="http://yoursite.com/tags/%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/"/>
    
      <category term="打包" scheme="http://yoursite.com/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Android中的图片加载框架</title>
    <link href="http://yoursite.com/2016/10/28/Android%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2016/10/28/Android中的图片加载框架/</id>
    <published>2016-10-28T12:47:28.000Z</published>
    <updated>2016-10-29T03:49:40.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>引子</strong></p>
<blockquote>
<p>对于很多App来说，都会有<strong>图片加载</strong>的需求，毕竟有图片的App才能显得更加多姿多彩。要实现图片加载，其基础的原理并不麻烦，大概有这么几点：</p>
</blockquote>
<ul>
<li><p>图片应该是<strong>异步加载</strong>的，从网络上下载图片会是一个比较耗时的过程，如果是在UI主线程里进行，那么ANR肯定无法避免了。任何耗时操作都在<strong>异步线程</strong>里进行</p>
</li>
<li><p>图片从网上下载完之后，需要<strong>在本地进行Bitmap的处理</strong>，最重要的就是<strong>图片的压缩</strong>。这一步是比较难办的，压缩的力度太大，图片的显示效果就会比较差；压缩的不够，那么图片就会占用大量内存，动辄就搞出<strong>OOM</strong></p>
</li>
<li><p>最好实现一个自己的<strong>缓存策略</strong>，即把图片下载到本地内存和磁盘中，需要保存下来并有一定的策略，这样下次再加载同样的图片的时候，就可以直接在本地加载而不需要去网络下载了，大大提升了加载速度并节省了流量，当然这一步也是比较麻烦的</p>
</li>
</ul>
<blockquote>
<p>实现了以上3点，你就可以做出一个<strong>基本的图片加载库</strong>了，当然，可能会比较粗糙。实际上呢，网上有大量的图片加载库，而且是<strong>开源的</strong>，最重要的在于，这些库都有<strong>各自的缓存策略</strong>，而且经过了大量开发者的实践考验，都很可靠。其中，比较有名的有：Universal-Image-Loader、Picasso、Glide和Fresco，今天的工作就是对它们进行比较。</p>
</blockquote>
<p><strong>四大图片缓存框架基本信息</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/image-cache-compare-before.jpeg" alt=""></p>
<p><strong>基本概念</strong></p>
<blockquote>
<p>在正式对比前，先了解几个图片缓存框架通用的概念：</p>
</blockquote>
<ul>
<li>RequestManager：请求生成和管理模块</li>
<li>Engine：引擎部分，负责创建任务(获取数据)，并调度执行</li>
<li><p>GetDataInterface：数据获取接口，负责从各个数据源获取数据</p>
<blockquote>
<p>比如 MemoryCache 从内存缓存获取数据、DiskCache 从本地缓存获取数据，下载器从网络获取数据等。</p>
</blockquote>
</li>
<li><p>Displayer：资源(图片)显示器，用于显示或操作资源。</p>
<blockquote>
<p>比如 ImageView，这几个图片缓存都不仅仅支持 ImageView，同时支持其他 View 以及虚拟的 Displayer 概念。</p>
</blockquote>
</li>
<li><p>Processor 资源(图片)处理器</p>
<blockquote>
<p>负责处理资源，比如旋转、压缩、截取等。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>以上概念的称呼在不同图片缓存框架中可能不同，比如 Displayer 在 ImageLoader 中叫做 <strong>ImageAware</strong>，在 Picasso 和 Glide 中叫做 <strong>Target</strong>。</p>
</blockquote>
<p><strong>共同的优点</strong></p>
<ul>
<li><p>使用简单 </p>
<blockquote>
<p>一句代码就可以实现图片获取和显示</p>
</blockquote>
</li>
<li><p>可配置度高，自适应程度高</p>
<blockquote>
<p>图片缓存的下载器(重试机制)、解码器、显示器、处理器、内存缓存、本地缓存、线程池、缓存算法等大都可轻松配置。<br>自适应程度高，根据系统性能初始化缓存配置、系统信息变更后动态调整策略。比如根据 CPU 核数确定最大并发数，根据可用内存确定内存缓存大小，网络状态变化时调整最大并发数等。</p>
</blockquote>
</li>
<li><p>多级缓存</p>
<blockquote>
<p>至少两级缓存，提高加载速率</p>
</blockquote>
</li>
<li><p>支持多种数据源</p>
<blockquote>
<p>网络、本地、资源、Assets等</p>
</blockquote>
</li>
<li><p>支持多种displayer</p>
<blockquote>
<p>不仅支持ImageView 还支持其他的View以及虚拟的 Displayer 概念等</p>
</blockquote>
</li>
<li><p>其他小的共同点包括支持动画、支持 transform 处理、获取 EXIF 信息等</p>
</li>
</ul>
<hr>
<h3 id="Universal-Image-Loader-UIL"><a href="#Universal-Image-Loader-UIL" class="headerlink" title="Universal Image Loader(UIL)"></a>Universal Image Loader(UIL)</h3><p><strong> <a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="external">Github</a></strong></p>
<blockquote>
<p>很早开源的图片缓存，在早期被很多应用使用，作者前阵子（2015/11/27）宣布不再维护这个项目了，换言之，以后它不会更新了——虽然有可能被其他开发者接手，但考虑到现在图片加载库十分丰富，有这个兴致的人怕是不多。如果你要开发新项目，可以不考虑UIL了，但如果是一个比较老而又庞大的项目并且使用了UIL，那么倒也不必太着急替换它，至少目前它还是能很好的完成图片加载任务的，<strong>不推荐使用</strong>。</p>
</blockquote>
<p><strong>总体设计及流程</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/overall-design-imageloader.jpg" alt=""></p>
<blockquote>
<p>上面是 ImageLoader 的总体设计图。整个库分为 ImageLoaderEngine，Cache 及 ImageDownloader，ImageDecoder，BitmapDisplayer，BitmapProcessor 五大模块，其中 Cache 分为 MemoryCache 和 DiskCache 两部分。</p>
<p>简单的讲就是 ImageLoader 收到加载及显示图片的任务，并将它交给 ImageLoaderEngine，ImageLoaderEngine 分发任务到具体线程池去执行，任务通过 Cache 及 ImageDownloader 获取图片，中间可能经过 BitmapProcessor 和 ImageDecoder 处理，最终转换为Bitmap 交给 BitmapDisplayer 在 ImageAware 中显示。</p>
</blockquote>
<p><strong>添加库文件</strong></p>
<pre><code>universal-image-loader-1.9.5.jar
</code></pre><p><strong>基本使用</strong></p>
<pre><code>// 单例模式 在application中创建配置图片的参数，直接使用
ImageLoader imageloader = Imageloader.getInstance();
imageloder.displayerImage(imagerUrl[position],holder.image,
options,loadingListener)
</code></pre><p><a href="http://blog.csdn.net/huangbiao86/article/details/22781701" target="_blank" rel="external">使用参考</a></p>
<p><strong>特点</strong></p>
<ul>
<li><p>支持下载进度监听</p>
<blockquote>
<p>如果你有特殊需求，则可以在图片开始下载前、刚开始下载等<strong>各个时间段</strong>来做一些额外的事情，非常方便</p>
</blockquote>
</li>
<li><p>可以在View滚动中暂停图片加载</p>
<blockquote>
<p>通过pauseOnScrollListener接口可以在view滚动中暂停图片加载，有利于提升界面的流畅度</p>
</blockquote>
</li>
<li><p>默认实现多种内存缓存算法(多种缓存策略)</p>
<blockquote>
<p>这几个图片缓存框架都可以配置<strong>缓存算法</strong>，不过 ImageLoader 默认实现了较多缓存算法，如 最大尺寸先删除、使用最少先删除、最近最少使用、先进先删除、时间最长先删除等。</p>
</blockquote>
</li>
<li><p>支持本地缓存文件名规则定义</p>
</li>
</ul>
<hr>
<h3 id="Picasso"><a href="#Picasso" class="headerlink" title="Picasso"></a>Picasso</h3><p><strong> <a href="https://github.com/square/picasso" target="_blank" rel="external">Github</a></strong> &amp; <strong> <a href="http://square.github.io/picasso/" target="_blank" rel="external">官网</a></strong></p>
<blockquote>
<p>Square 开源的项目，总体来看它比较小巧，但也有着一些自己的特色，最重要的是他的主导者是 JakeWharton，所以广为人知。Picasso使用起来比较简单，不过对于新项目来说，<strong>也不是很推荐</strong>，原因就在于，<strong>Glide比它更优秀</strong>，而且使用起来几乎是一样的。</p>
</blockquote>
<p><strong>总体设计及流程</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/overall-design-picasso.jpg" alt=""></p>
<blockquote>
<p>上面是 Picasso 的总体设计图。整个库分为 Dispatcher，RequestHandler 及 Downloader，PicassoDrawable 等模块。</p>
<p>Dispatcher 负责分发和处理 Action，包括提交、暂停、继续、取消、网络状态变化、重试等等。</p>
<p>简单的讲就是 Picasso 收到加载及显示图片的任务，创建 Request 并将它交给 Dispatcher，Dispatcher 分发任务到具体 RequestHandler，任务通过 MemoryCache 及 Handler(数据获取接口) 获取图片，图片获取成功后通过 PicassoDrawable 显示到 Target 中。</p>
<p>需要注意的是上面 <strong>Data 的 File system </strong>部分，Picasso 没有自定义本地缓存的接口，默认使用 http 的本地缓存，API 9 以上使用 okhttp，以下使用 Urlconnection，所以如果需要自定义本地缓存就需要重定义 Downloader。</p>
</blockquote>
<p><strong>添加依赖</strong></p>
<pre><code>compile &apos;com.square.picasso:picasso:2.5.1&apos;
</code></pre><p><strong>基本使用</strong></p>
<pre><code>Picasso.with(context)
   .load(&quot;图片url&quot;)
   .into(显示控件);
</code></pre><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/0731/1639.html" target="_blank" rel="external">参考</a></p>
<p><strong>特点</strong></p>
<ul>
<li><p>自带统计监控功能</p>
<blockquote>
<p>支持图片缓存使用的监控，包括缓存命中率，已使用内存大小，节省的流量等</p>
</blockquote>
</li>
<li><p>支持优先级处理</p>
<blockquote>
<p>每次任务调度前会选择优先级高的任务，比如app页面的Banner的优先级高于Icon时很使用。</p>
</blockquote>
</li>
<li><p>支持延迟到图片尺寸计算完成加载</p>
</li>
<li><p>支持飞行模式，并发线程根据网络类型而改变 </p>
<blockquote>
<p>手机切换到飞行模式或网络类型变换时会自动调整线程池最大并发数，比如 wifi 最大并发为 4， 4g 为 3，3g 为 2。这里 Picasso 根据网络类型来决定最大并发数，而不是 CPU 核数。这里Picasso 根据网络类型来决定最大并发数，而不是cpu核数。</p>
</blockquote>
</li>
<li><p>“无”本地缓存(本身没有什么缓存策略，而是依赖所用的网络库的缓存策略)</p>
<blockquote>
<p>无”本地缓存，不是说没有本地缓存，而是 Picasso 自己没有实现，交给了 Square 的另外一个网络库 okhttp 去实现，这样的好处是可以通过请求 Response Header 中的 Cache-Control 及 Expired 控制图片的过期时间。</p>
</blockquote>
</li>
<li><p>在adapter中需要取消已经不在视野范围的ImageView图片资源的加载，否则会导致图片错位，Picasso已经解决了这个问题。</p>
</li>
<li><p>使用复杂的图片压缩转换来尽可能的减少内存消耗</p>
</li>
<li><p>自带内存和磁盘二级缓存功能，存储的结构采用了LinkedHashMap, 底层的缓存功能使用的是LruCache类，缓存路径默认是放在应用目录的／cache／picasso-cache／</p>
</li>
<li><p>如果加载发生错误会重复三次请求，三次都失败才会显示erro Place holder</p>
<pre><code>Picasso.with(context)
   .load(url)
   .placeholder(R.drawable.user_placeholder)
   .error(R.drawable.user_placeholder_error)
   .into(imageView);
</code></pre></li>
<li><p>使用简单，源码简单易懂。Picasso 代码虽然只在一个包下，没有严格的包区分，但代码简单、逻辑清晰</p>
</li>
<li><p>Picasso的方式则因为需要在显示之前重新调整大小而导致一些延迟，Glide加载显示更快。</p>
</li>
<li><p>ARGB_8888</p>
</li>
<li><p>包大小：1.2MB</p>
</li>
</ul>
<hr>
<h3 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h3><p><strong> <a href="https://github.com/bumptech/glide" target="_blank" rel="external">Github</a></strong></p>
<blockquote>
<p>来自于Google员工bumptech的开源项目，被Google官方所推荐，专注于流畅的滚动，甚至在许多Android的原生应用中都采用了Glide来加载图片，可见其受推崇的程度，所以，<strong>推荐使用</strong>。</p>
</blockquote>
<p><strong>总体设计及流程</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/overall-design-glide.jpg" alt=""></p>
<blockquote>
<p>上面是 Glide 的总体设计图。整个库分为 RequestManager(请求管理器)，Engine(数据获取引擎)、 Fetcher(数据获取器)、MemoryCache(内存缓存)、DiskLRUCache、Transformation(图片处理)、Encoder(本地缓存存储)、Registry(图片类型及解析器配置)、Target(目标) 等模块。</p>
<p>简单的讲就是 Glide 收到加载及显示资源的任务，创建 Request 并将它交给RequestManager，Request 启动 Engine 去数据源获取资源(通过 Fetcher )，获取到后 Transformation 处理后交给 Target。</p>
<p>Glide 依赖于 DiskLRUCache、GifDecoder 等开源库去完成本地缓存和 Gif 图片解码工作。</p>
</blockquote>
<p><strong>添加依赖</strong></p>
<pre><code>compile &apos;com.github.bumptech.glide:glide:3.5.2&apos;
</code></pre><p><strong>基本使用</strong></p>
<pre><code>Glide.with(context)
   .load(&quot;图片url&quot;)
   .into(显示控件);
</code></pre><blockquote>
<p>Picasso和Glide的基本使用方法是很相似的，从某种程度上说，Glide可以看作是Picasso的改进版。</p>
</blockquote>
<p><a href="http://blog.csdn.net/fancylovejava/article/details/44747759" target="_blank" rel="external">详细使用方法</a></p>
<p><strong>特点</strong></p>
<ul>
<li><p>支持优先级处理(与Picasso类似)</p>
</li>
<li><p>Glide更易用，因为其with方法不但可以接受context，还可以接受Activity和Fragment，Context会自动的从它们中获取。同时将Activity／Fragment作为with的参数的好处是：图片加载会和Activity／Fragment的生命周期保持一致，比如Paused状态在暂停加载，在Resumed状态的时候又会自动重新开始加载，所以，建议传递参数Activity和Fragment给Glide，而不是Context</p>
</li>
<li><p>支持trimMemory（OnTrimMemory是Android 4.0之后提供的API，系统会根据<strong>不同的内存状态来回调</strong>。根据不同的内存状态，来响应不同的内存释放策略。）Glide对每个Context都保持一个RequestManager ,通过FragmentTransaction保持和activity/fragment生命周期一致，并且有相应的trimMemory接口可以实现</p>
</li>
<li><p>内存友好  </p>
<ul>
<li><p>Glide的内存缓存有个active的设计</p>
<blockquote>
<p>从内存缓存中取数据时，不像一般的实现用get，而是remove，再把这个缓存数据放到一个value为软引用的activeResurces map中，并计数引用数，在图片加载完成后进行判断，如果引用数为空，则回收掉。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>内存缓存更小的图片</p>
<blockquote>
<p>Glide以url, view_width，view_height,屏幕分辨率等作为联合的Key，将处理后的图片缓存在内存缓存中，而不是原始图片以节省大小。</p>
</blockquote>
</li>
<li><p>图片默认使用 RGB_565 而不是ARGB_888，内存占用比Picasso小一半，清晰度差，但是图片更小，也可以配置888</p>
</li>
<li><p>Picasso和Glide在磁盘缓存策略上有很大不同。Picasso缓存的是全尺寸的，而Glide缓存的是跟ImageView尺寸相同的。Glide的这种方式优点是<strong>加载显示快</strong>。而Picasso的方式则因为需要在显示之前<strong>重新调整大小</strong>而导致一些延迟</p>
<blockquote>
<p>比如加载的图片是1920*1080的大小，而在你的App中，显示该图片的ImageView大小只有1280*720，那么Glide就会很聪明的自动缓存1280*720大小的图片。</p>
</blockquote>
</li>
<li><p>图片缓存 -> 媒体缓存</p>
<blockquote>
<p>Glide 不仅是一个图片缓存，它支持 Gif、WebP、缩略图。甚至是 Video，所以更该当做一个媒体缓存，而Picasso不能。但是Glide 动画会消费太多的内存，因此<strong>谨慎使用</strong>。</p>
</blockquote>
</li>
<li><p>默认使用HttpUrlConnection下载图片，可以配置为OkHttp或者Volley进行下载，也可以<strong>自定义下载方式</strong>。实际image-loader，Picasso都支持OkHttp，Volley</p>
</li>
<li><p>默认使用手机内置存储进行磁盘缓存，可以配置为外部存储，可以配置缓存大小，图片池大小</p>
</li>
<li><p>默认使用两个线程池来分别执行读取缓存和下载任务，都可以自定义</p>
</li>
<li><p>Glide 可以通过 signature 或不使用本地缓存支持 url 过期</p>
</li>
<li><p>在页面不可见时停止网络请求，停止对图片的解析操作</p>
</li>
<li><p>专注于流畅的滚动，当列表在滑动的时候，调用pauseRequests()取消请求，滑动停止时，调用resumeRequests()恢复请求。</p>
</li>
<li><p>Glide 功能强大，但代码量大、流转复杂。在较深掌握的情况下才推荐使用，免得出了问题难以下手解决</p>
</li>
<li><p>使用Glide，你可以配置图片显示的动画，而Picasso只有一种动画：fading in</p>
</li>
<li><p>可以使用thumbnail()产生一个你所加载图片的thumbnail</p>
</li>
<li><p>Glide还可以将任何的本地视频解码成一张静态图片</p>
</li>
<li><p>将 ImageView 还原到真实大小时，Glide 加载的图片没有 Picasso 那么平滑</p>
</li>
<li><p>包大小：1.3MB</p>
</li>
</ul>
<p><strong>自定义缓存大小</strong></p>
<blockquote>
<p>想要提高Glide的图片效果，可以创建一个新的 GlideModule 将 Bitmap 格式转换到 ARGB-8888。同时在 AndroidManifest.xml 中将 GlideModule 定义为 meta-data，如下：</p>
</blockquote>
<ul>
<li><p>首先创建一个GlideModule子类实现GlideModule接口</p>
<pre><code>public class MyGlideModule implements GlideModule {
@Override
public void applyOptions(Context context, GlideBuilder builder) {
     // Apply options to the builder here
}
@Override
public void registerComponents(Context contxt, Glide glide) {
    // register ModuleLoaders here
}
}
</code></pre></li>
<li><p>创建一个混淆文件, 针对于该GlideModule类的:</p>
</li>
</ul>
<blockquote>
<p>文件夹名: proguard.cfg</p>
</blockquote>
<pre><code>-keepnames class com.mypackage.MyGlideModule
# or more generally:
#-keep public class * implements com.bumptech.glide.module.GlideModule
</code></pre><ul>
<li><p>添加如下标签到AndroidManifest.xml文件中, 以便Glide可以找到你配置的GlideModule类</p>
<pre><code>&lt;meta-data
       android:name=&quot;com.mypackage.MyGlideModule&quot;
       android:value=&quot;GlideModule&quot; /&gt;
</code></pre></li>
</ul>
<blockquote>
<p>修改了 Bitmap 格式后，Glide 将花费两倍于上次的内存，但是仍远远小于 Picasso 的内存开销，原因在于 Picasso 是加载了全尺寸的图片到内存，然后让 GPU 来实时重绘大小。而 Glide 加载的大小和 ImageView 的大小是一致的，当然，Picasso 也是可以指定加载图片大小的，但是问题在于你需要<strong>主动计算 ImageView 的大小</strong>，或者说你的 ImageView 大小是具体的值（而不是 wrap_content ）</p>
<p>在加载图片这个问题上 Glide 完胜 Picasso，因为 Glide 可以自动计算出任意情况下的 ImageView 大小。</p>
</blockquote>
<p><strong>磁盘缓存Disk Cache</strong></p>
<blockquote>
<p>默认缓存在手机内置存储</p>
</blockquote>
<pre><code>builder.setDiskCache(new InternalCacheDiskCacheFactory(context,yourSizeInBytes));
</code></pre><blockquote>
<p>缓存到外置的SD卡</p>
</blockquote>
<pre><code>builder.setDiskCache(new ExternalCacheDiskCacheFactory(context, cacheDirectoty, yourSizeInBytes));
</code></pre><p><strong>内存缓存Memory Cache</strong></p>
<pre><code>builder.setMemoryCache(new LruResourceCache(yourSizeInBytes));
</code></pre><blockquote>
<p>Bitmap pool</p>
</blockquote>
<pre><code>builder.setBitmapPool(new LruBitmapPool(yourSizeInBytes));
</code></pre><blockquote>
<p>Bitmap Format</p>
</blockquote>
<pre><code>builder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);
</code></pre><blockquote>
<p>Picasso 和 Glide 在磁盘缓存策略上有很大的不同。Picasso 缓存的是全尺寸的，而 Glide 缓存的是跟 ImageView 尺寸相同的。我们可以将 ImageView 调整成不同大小，但不管大小如何 Picasso 只缓存一个全尺寸的。Glide 则不同，它会为每种大小的 ImageView 缓存 一次。尽管一张图片已经缓存了一次，但是假如你要在另外一个地方再次以不同尺寸显示，需要重新下载，调整成新尺寸的大小，然后将这个尺寸的也缓存起来。具体说来就是：假如在第一个页面有一个 200×200 的 ImageView，在第二个页面有一个 100×100 的 ImageView，这两个 ImageView 本来是要显示同一张图片，却需要下载两次。不过，你可以通过代码改变这种行为，让Glide既缓存全尺寸又缓存其他尺寸，这样就使得下次在任何 ImageView 中加载图片的时候，全尺寸的图片将从缓存中取出，重新调整大小，然后缓存。<br>Glide 的这种方式优点是加载显示非常快。而 Picasso 的方式则因为需要在显示之前重新调整大小而导致一些延迟。不过 Glide 比 Picasso 需要更大的空间来缓存。</p>
</blockquote>
<hr>
<h3 id="Fresco"><a href="#Fresco" class="headerlink" title="Fresco"></a>Fresco</h3><p><strong> <a href="https://github.com/facebook/fresco" target="_blank" rel="external">Github</a></strong> &amp; <strong> <a href="http://fresco-cn.org/docs/index.html" target="_blank" rel="external">官网</a></strong></p>
<blockquote>
<p>这个可以称为是Android平台上目前最为强大的图片加载库了，来源于地球人都知道的Facebook公司。</p>
</blockquote>
<p><strong>添加依赖</strong></p>
<pre><code>compile &apos;com.facebook.fresco:fresco:0.6.0+&apos;
</code></pre><p><strong>用法</strong></p>
<ul>
<li><p>application 中 初始化</p>
<p>  Fresco.initialize(context);</p>
</li>
<li><p>布局文件中 加入命名空间</p>
<p>  \&lt;LinearLayout  </p>
<pre><code>xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;     xmlns:fresco=&quot;http://schemas.android.com/apk/res-auto&quot;\&gt;
</code></pre></li>
<li><p>加入SimpleDraweeView</p>
<p>  \&lt;com.facebook.drawee.view.SimpleDraweeView </p>
<pre><code>android:id=&quot;@+id/my_image_view&quot; 
android:layout_width=&quot;20dp&quot; 
android:layout_height=&quot;20dp&quot; 
fresco:placeholderImage=&quot;@drawable/my_drawable&quot; /&gt;
</code></pre><p>  Uri uri = Uri.parse(“<a href="https://XXXX" target="_blank" rel="external">https://XXXX</a>“);<br>  SimpleDraweeView draweeView = (SimpleDraweeView) findViewById(R.id.my_image_view);<br>  draweeView.setImageURI(uri);</p>
</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li><p>Fresco 中设计有一个叫做 image pipeline 的模块。它负责从网络，从本地文件系统，本地资源加载图片。为了最大限度节省空间和CPU时间，它含有3级缓存设计（<strong>2级内存，1级文件</strong>）。</p>
</li>
<li><p>Fresco 中设计有一个叫做 Drawees 模块，方便地显示loading图，当图片不再显示在屏幕上时，及时地释放内存和空间占用。</p>
</li>
<li><p>Fresco 支持 Android2.3(API level 9) 及其以上系统。</p>
</li>
<li><p>内存管理(内存方面的表现更是无敌)</p>
<blockquote>
<p>解压后的图片，即Android中的<strong>Bitmap</strong>，占用大量的内存。大的内存占用势必引发<strong>更加频繁的GC</strong>。在5.0以下，GC将会显著地引发<strong>界面卡顿</strong>。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>在5.0以下系统，使用了Native缓存，Fresco将图片放到一个特别的内存区域。当然，在图片不显示的时候，占用的内存会自动被释放。这会使得APP更加流畅，减少因图片内存占用而引发的OOM。</p>
<p>为什么说是5.0以下，因为在5.0以后系统默认就是存储在Ashmem区了。</p>
<p>Android中的每个App的Java堆内存大小都是被严格控制的，每个对象都是使用Java的new在堆内存实例化，这是内存中相对安全的一块区域，内存有垃圾回收机制，App不在内存时，系统会自动回收内存。当内存进行垃圾回收机制时，还把Android应用完全终止了，也是使用App最常见的卡顿或假死的原因之一。</p>
<p>Ashmem Android 在操作Ashmem堆时,会把该堆中存有数据的内存区域从Ashmem对中抽取出来,而不是把它释放掉，这是一种<strong>弱内存释放模式</strong>; 被抽取出来的这部分内存只有当系统真正需要更多的内存那时候才会被释放，当Android把被抽取出来的这部分内存放回Ashmem堆,只是被抽取的内存空间没有被释放，之前的数据就被回复到相应的位置。</p>
<p>由于将图片放在Ashmem（匿名共享内存）中，大大降低了App的内存占用（因为Ashmem没有被统计到App的内存使用里），再加上各种优化，使得Fresco基本上告别了OOM。</p>
<p>Fresco 在低端机器上表现一样出色，你再也不用因图片内存占用而思前想后，但是源代码基于C/C++，阅读困难度提升。</p>
</blockquote>
<ul>
<li><p>图片的渐进式呈现(类似WebView)</p>
<blockquote>
<p><strong>渐进式的JPEG图片</strong>格式已经流行数年了，渐进式图片格式<strong>先呈现大致的图片轮廓</strong>，然后随着图片下载的继续，<strong>呈现逐渐清晰的图片</strong>，这对于移动设备，尤其是<strong>慢网络有极大的利好</strong>，可带来更好的用户体验。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Android 本身的图片库不支持此格式，但是Fresco支持。使用时，和往常一样，仅仅需要提供<strong>一个图片的URI</strong>即可，剩下的事情，Fresco会处理.</p>
</blockquote>
<ul>
<li><p>Gif图和WebP格式</p>
<blockquote>
<p>是的，支持加载Gif图(与Glide一样)，支持WebP格式</p>
</blockquote>
</li>
<li><p>图像的呈现</p>
<blockquote>
<p>Fresco 的 Drawees 设计，带来一些有用的特性：</p>
</blockquote>
</li>
<li><p>自定义居中焦点(对人脸等图片显示非常有帮助)</p>
<ul>
<li>圆角图，当然圆圈也行。</li>
<li>下载失败之后，点击重现下载</li>
<li>自定义占位图，自定义overlay, 或者进度条</li>
<li>指定用户按压时的overlay</li>
</ul>
</li>
<li><p>图像的加载</p>
<blockquote>
<p>Fresco 的 image pipeline 设计，允许用户在多方面控制图片的加载：</p>
</blockquote>
</li>
<li><p>为同一个图片指定不同的远程路径，或者使用已经存在本地缓存中的图片</p>
<ul>
<li>先显示一个低解析度的图片，等高清图下载完之后再显示高清图</li>
<li>加载完成回调通知</li>
<li>对于本地图，如有EXIF缩略图，在大图加载完成之前，可先显示缩略图</li>
<li>缩放或者旋转图片</li>
<li>处理已下载的图片</li>
<li><p>WebP 支持</p>
<blockquote>
<p>Fresco的图片直接显示为<strong>ARGB8888</strong>这种最高质量的级别，即使是在这种高质量的情况下依然保证了<strong>比其他库更少的内存占用</strong>，不得不佩服Facebook的实力。而且类似于进度监听、缓存策略等，也是应有尽有，总之作为一个图片加载库，Fresco在功能和性能方面已经趋于完美了。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>能够根据View的展示状态控制网络请求和图片解析的状态（在页面不可见时停止对图片的网络请求和解析操作，在页面可见时恢复操作）</p>
</li>
<li><p>对外提供清除缓存的方法</p>
</li>
<li><p>体积较大，集成后增大apk体积</p>
</li>
<li><p>需要使用特定的view，需要xml支持</p>
</li>
<li><p>包大小：4MB</p>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="http://o9zgq2ik9.bkt.clouddn.com/image-cache-compare-after.jpeg" alt=""></p>
<blockquote>
<p>总体上来说，ImageLoader 的功能以及代理容易理解长度都一般。</p>
<p>Picasso与Glide有着近乎相同的 API 的使用风格，但 Glide 在缓存策略和加载 gif 方面略胜一筹。</p>
<p>Glide 和 Picasso 都是非常完美的库。Glide 加载图像以及磁盘缓存的方式都要优于 Picasso，速度更快，并且 Glide 更有利于减少 OutOfMemoryError 的发生，GIF 动画是 Glide 的杀手锏。不过Picasso 的图片质量更高。如果使用 Glide，建议将 Bitmap 格式换成 ARGB_8888、让 Glide 缓存同时缓存全尺寸和改变尺寸两种</p>
<p>Picasso 代码虽然只在一个包下，没有严格的包区分，但代码简单、逻辑清晰，一两个小时就能叫深入的了解完。</p>
<p>Glide 功能强大，但代码量大、流转复杂。在较深掌握的情况下才推荐使用，免得出了问题难以下手解决。</p>
<p>Picasso 所能实现的功能 Glide 都能做到，只是所需设置不同。两者的区别是 Picasso 比 Glide 体积小很多且图像质量比 Glide 高，但Glide 的速度比 Picasso 更快，Glide 的长处是处理大型的图片流，如 gif、video，如果要制作视频类应用，Glide 当为首选。</p>
<p>Fresco 可以说是综合了之前图片加载库的优点，其在5.0以下的内存优化非常好，但它的不足是<strong>体积太大</strong>，按体积进行比较：<strong>Fresco>Glide>Picasso</strong>，所以 Fresco 在图片较多的应用中更能凸显其价值，如果应用没有太多图片需求，不推荐使用 Fresco。</p>
<p>项目比较老，代码量较大，又没什么时间去大改，那么继续维持当前的选择是比较稳妥的办法。如果是新上马的项目，那么UIL由于不再维护、<strong>Picasso基本被Glide全方位超越</strong>，我<strong>推荐使用Glide或Fresco</strong>。如果你的App里，图片特别多，而且都是很大、质量很高的图片，而且你不太在乎App的体积（这可能吗？），那么Fresco就是很好的选择了，而<strong>Glide相比较Fresco要轻量一些</strong>，而且是Google官方推荐，所以在多数时候，会是开发者的首选。话说回来，如果你非常在意App的体积，不肯让App多增加多余的1KB，那么，也许自己实现一个图片加载库也是不错的选择哦，而且能很好的锻炼自己的能力。</p>
</blockquote>
<p><strong>参考资料</strong><br><a href="http://www.aichengxu.com/view/10139294" target="_blank" rel="external">http://www.aichengxu.com/view/10139294</a><br><a href="http://www.trinea.cn/android/android-image-cache-compare/" target="_blank" rel="external">http://www.trinea.cn/android/android-image-cache-compare/</a><br><a href="http://www.jianshu.com/p/ada9b90fa9e6" target="_blank" rel="external">http://www.jianshu.com/p/ada9b90fa9e6</a><br><a href="http://www.kaelli.com/15.html" target="_blank" rel="external">http://www.kaelli.com/15.html</a><br><a href="http://blog.csdn.net/a910626/article/details/50688637" target="_blank" rel="external">http://blog.csdn.net/a910626/article/details/50688637</a><br><a href="http://blog.qiji.tech/archives/6344" target="_blank" rel="external">http://blog.qiji.tech/archives/6344</a><br><a href="https://www.zhihu.com/question/40028112" target="_blank" rel="external">https://www.zhihu.com/question/40028112</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;引子&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于很多App来说，都会有&lt;strong&gt;图片加载
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图片加载" scheme="http://yoursite.com/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="开源库" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
      <category term="Glide" scheme="http://yoursite.com/tags/Glide/"/>
    
      <category term="UIL" scheme="http://yoursite.com/tags/UIL/"/>
    
      <category term="Picasso" scheme="http://yoursite.com/tags/Picasso/"/>
    
      <category term="Fresco" scheme="http://yoursite.com/tags/Fresco/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Android中网络请求框架</title>
    <link href="http://yoursite.com/2016/10/23/Android%E4%B8%AD%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2016/10/23/Android中网络请求框架/</id>
    <published>2016-10-23T07:46:16.000Z</published>
    <updated>2016-10-24T00:22:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>在实际开发中，频繁的接触<strong>网络请求</strong>，而网络请求的方式很多，最常见的也就那么几个。本篇文章对常见的网络请求库进行一个总结，说说网络请求到底哪家强。</p>
<p>一般网络请求专指 <strong>http请求</strong>，在选择一个框架之前，尽量选择比较专注于一项功能的库，不选大而全的库，其实在软件设计领域有一个原则叫做 「<strong>单一职责原则</strong>」一个库能把一件事做好就很不错了。在上面原则的基础上，所以目前来说单纯的网络请求库就锁定在了 Volley、OkHttp、Retrofit 三个，android-async-http 的作者已经不维护，所以这里就不多说了。</p>
<p>使用过程中不要忘记添加<strong>网络访问权限</strong></p>
</blockquote>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;
</code></pre><blockquote>
<p> 在 Android 开发中是可以直接使用现成的 api 进行网络请求的，就是使用 <strong>HttpClient、HttpUrlConnection</strong> 进行操作，目前 HttpClient 已经被废弃，而 <strong>android-async-http</strong> 是基于 HttpClient 的，我想可能也是因为这个原因作者放弃维护。我们下面先依次介绍这三种。</p>
</blockquote>
<h3 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h3><p><strong>特点</strong></p>
<blockquote>
<p>高效稳定，但是维护成本高昂，故android 开发团队不愿意在维护该库而是转投更为轻便的<strong>HttpUrlConnection</strong></p>
</blockquote>
<p><strong>用法</strong></p>
<ul>
<li>HttpClient是一个接口，因此无法直接创建它的实例，一般都是创建一个<strong>DefaultHttpClient</strong>实例</li>
<li>如果要发起Get请求，需要创建一个<strong>HttpGet</strong>对象，并传入请求地址</li>
<li>如果要发起Post请求，需要创建一个<strong>HttpPost</strong>对象。并传入请求地址，通过<strong>setEntity</strong>函数<strong>设置请求参数</strong></li>
<li>调用<strong>execute</strong>方法，传入HttpGet或者HttpPost实例，执行后返回<strong>HttpResponse</strong>对象，<strong>判断响应状态码</strong></li>
<li>解析响应结果，通过调用<strong>getEntity</strong>函数获得一个<strong>HttpEntity</strong>对象，之后可以通过<strong>EntityUtils.toString</strong>方法将其转换为字符串</li>
</ul>
<blockquote>
<p>由于在android2.3之后就被<strong>HttpUrlConnection</strong>取代了，这里也不过多介绍了，不过当初学习它的时候还没接触到其他库，就感觉它好方便，下面简单贴出使用方法:</p>
<p>GET</p>
</blockquote>
<pre><code>private String get(String url){
    HttpClient client=null;
    HttpGet request=null;
    try {
         client=new DefaultHttpClient();
         request=new HttpGet(url);
         HttpResponse response=client.execute(request);
         if(response.getStatusLine().getStatusCode()== HttpStatus.SC_OK) {
              String result=EntityUtils.toString(response.getEntity(),&quot;UTF-8&quot;);
              return result;
         }
     } catch (IOException e) {
            e.printStackTrace();
     }
     return  null;
}
</code></pre><blockquote>
<p>POST</p>
</blockquote>
<pre><code>private String post(String url,List&lt;NameValuePair&gt; params){
    HttpClient client=null;
    HttpPost request=null;
    try {
        client=new DefaultHttpClient();
        request=new HttpPost(url);
        request.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));
        HttpResponse response=client.execute(request);
        if(response.getStatusLine().getStatusCode()== HttpStatus.SC_OK){
             String result=EntityUtils.toString(response.getEntity(),&quot;UTF-8&quot;);
             return result;
        }
    } catch (IOException e) {
           e.printStackTrace();
    }
    return  null;
}
</code></pre><h3 id="HttpUrlConnection"><a href="#HttpUrlConnection" class="headerlink" title="HttpUrlConnection"></a>HttpUrlConnection</h3><blockquote>
<p>在Android 2.2版本之前，HttpClient拥有较少的bug，因此使用它是最好的选择。而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。<strong>压缩和缓存机制</strong>可以有效地减少网络访问的流量，在提升速度和省电方面也起到了较大的作用。对于新的应用程序应该更加偏向于使用HttpURLConnection，因为在以后的工作当中我们也会将更多的时间放在优化HttpURLConnection上面。</p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>比较轻便，灵活，易于扩展</li>
<li>在3.0后以及4.0中都进行了改善，如<strong>对HTTPS的支持</strong></li>
<li>在4.0中，还增加了<strong>对缓存的支持</strong></li>
</ul>
<p><strong>用法</strong></p>
<ul>
<li>首先我们需要获取到一个<strong>HttpURLConnection</strong>实例，一般需要new出一个URL对象，并传入目标网络地址，通过调用<strong>openConnection()</strong>方法获得HttpURLConnection实例。</li>
<li>得到该实例后。我们需要设置一下http请求的的方法，这里我们主要研究get和post，默认是使用get方法。get一般用于从服务器获取数据，post一般用于向服务器提交数据，设置请求方法使用函数<strong>setRequestMethod(“POST”)</strong>进行设置。</li>
<li>此外可以进行一些请求的限制，比如连接超时的时间等，可以通过<strong>setConnectTimeout</strong>设置超时时间。</li>
<li>获取服务器返回的输入流，使用<strong>getInputStream</strong>方法获取。</li>
<li>读取内容并处理</li>
<li>关闭连接，通过调用<strong>disconnect方法</strong>关闭当前的连接。 </li>
</ul>
<blockquote>
<p>GET</p>
</blockquote>
<pre><code>public String get(String urlPath) {
        HttpURLConnection connection = null;
        InputStream is = null;
        try {
            URL url = new URL(urlPath); // 获得URL对象
            connection = (HttpURLConnection) url.openConnection(); // 获得HttpURLConnection对象
            connection.setRequestMethod(&quot;GET&quot;); // 默认为GET
            connection.setUseCaches(false); // 不使用缓存
            connection.setConnectTimeout(10000); // 设置超时时间
            connection.setReadTimeout(10000); // 设置读取超时时间
            connection.setDoInput(true); // 设置是否从httpUrlConnection读入，默认情况下是true;
            if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
                // 相应码是否为200
                is = connection.getInputStream(); // 获得输入流
                BufferedReader reader = new BufferedReader(new InputStreamReader(is)); // 包装字节流为字符流
                StringBuilder response = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    response.append(line);
                }
                return response.toString();
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (connection != null) {
                connection.disconnect();
                connection = null;
            }
            if (is != null) {
                try {
                    is.close();
                    is = null;
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return null;
}
</code></pre><blockquote>
<p>POST</p>
</blockquote>
<pre><code>private String post(String urlPath, Map&lt;String, String&gt; params) {
        if (params == null || params.size() == 0) {
            return get(urlPath); // 变成get请求
        }
        OutputStream os = null;
        InputStream is = null;
        HttpURLConnection connection = null;
        StringBuffer body = getParamString(params);
        byte[] data = body.toString().getBytes();
        try {
            URL url = new URL(urlPath); //获得URL对象
            connection = (HttpURLConnection) url.openConnection(); //获得HttpURLConnection对象
            connection.setRequestMethod(&quot;POST&quot;); // 设置请求方法为post
            connection.setUseCaches(false); //不使用缓存
            connection.setConnectTimeout(10000); //设置超时时间
            connection.setReadTimeout(10000); //设置读取超时时间
            connection.setDoInput(true); //设置是否从httpUrlConnection读入，默认情况下是true;
            connection.setDoOutput(true); //设置为true后才能写入参数（必须的）
            connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
            connection.setRequestProperty(&quot;Content-Length&quot;, String.valueOf(data.length));
            os = connection.getOutputStream();
            os.write(data); //写入Post请求参数
            if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
                //相应码是否为200
                is = connection.getInputStream(); //获得输入流
                BufferedReader reader = new BufferedReader(new InputStreamReader(is)); //包装字节流为字符流
                StringBuilder response = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    response.append(line);
                }
                return response.toString();
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //关闭
            if (os != null) {
                try {
                    os.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (is != null) {
                try {
                    is.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (connection != null) {
                connection.disconnect();
                connection = null;
            }
        }
        return null;
    }
    private StringBuffer getParamString(Map&lt;String, String&gt; params) {
        StringBuffer result = new StringBuffer();
        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = params.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry&lt;String, String&gt; param = iterator.next();
            String key = param.getKey();
            String value = param.getValue();
            result.append(key).append(&apos;=&apos;).append(value);
            if (iterator.hasNext()) {
                result.append(&apos;&amp;&apos;);
            }
        }
        return result;
 }
</code></pre><h3 id="android-async-http"><a href="#android-async-http" class="headerlink" title="android-async-http"></a>android-async-http</h3><p><strong> <a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">Github</a></strong> &amp; <strong> <a href="http://loopj.com/android-async-http/" target="_blank" rel="external">官网</a></strong></p>
<blockquote>
<p>android-async-http是<strong>基于Http Client</strong>的，但是呢在安卓中<strong>Http Client已经废弃</strong>了，所以也<strong>不建议使用</strong>这个库了。然后仍然有一些可取的内容值得学习，所以这里也介绍一下。</p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>所以<strong>请求在子线程</strong>中完成，<strong>请求回调</strong>在调用该请求的线程中完成</li>
<li>使用线程池</li>
<li>使用<strong>RequestParams</strong>类封装请求参数</li>
<li>支持文件上传</li>
<li><strong>持久化cookie到SharedPreferences</strong>，个人感觉这一点也是这个库的重要特点，可以很方便的完成一些模拟登录</li>
<li>支持json</li>
<li>支持HTTP Basic Auth</li>
</ul>
<p><strong>用法</strong></p>
<ul>
<li><p>编写一个静态的HttpClient</p>
<p>  public class TestClient {</p>
<pre><code>private static final String BASE_URL = &quot;http://121.41.119.107/&quot;;
private static AsyncHttpClient client = new AsyncHttpClient();

public static void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
    client.get(getAbsoluteUrl(url), params, responseHandler);
}
public static void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {
    client.post(getAbsoluteUrl(url), params, responseHandler);
}
private static String getAbsoluteUrl(String relativeUrl) {
    return BASE_URL + relativeUrl;
}
</code></pre><p>  }</p>
</li>
<li><p>调用get或者post方法</p>
</li>
</ul>
<blockquote>
<p>参数通过RequestParams传递，没有参数则传递null</p>
</blockquote>
<pre><code>RequestParams  params = new RequestParams();
params.put(&quot;&quot;,&quot;&quot;);
</code></pre><ul>
<li><p>如果要<strong>保存cookie</strong>，在发起请求之前调用以下代码</p>
<p>  PersistentCookieStore myCookieStore = new PersistentCookieStore(this);<br>  client.setCookieStore(myCookieStore);</p>
</li>
</ul>
<blockquote>
<p>之后请求所得到的cookie都会<strong>自动持久化</strong></p>
<p>如果要自己添加cookie，则调用以下代码</p>
</blockquote>
<pre><code>BasicClientCookie newCookie = new BasicClientCookie(&quot;cookiesare&quot;, &quot;awesome&quot;);
newCookie.setVersion(1);
newCookie.setDomain(&quot;mydomain.com&quot;);
newCookie.setPath(&quot;/&quot;);
myCookieStore.addCookie(newCookie);
</code></pre><ul>
<li>使用</li>
</ul>
<blockquote>
<p>在回调函数中处理返回结果</p>
</blockquote>
<pre><code>private void get(){
        TestClient.get(&quot;test/index.php&quot;, null, new AsyncHttpResponseHandler() {
            @Override
            public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
            }
            @Override
            public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
            }
        });
    }
    private void post(){
        RequestParams params = new RequestParams();
        params.put(&quot;user&quot;,&quot;asas&quot;);
        params.put(&quot;pass&quot;,&quot;12121&quot;);
        params.put(&quot;time&quot;,&quot;1212121&quot;);
        TestClient.post(&quot;test/login.php&quot;, params, new AsyncHttpResponseHandler() {
            @Override
            public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
            }
            @Override
            public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
            }
        });
}
</code></pre><h3 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h3><p><strong> <a href="https://github.com/square/okhttp" target="_blank" rel="external">Github</a></strong> &amp; <strong> <a href="http://square.github.io/okhttp/" target="_blank" rel="external">官网</a></strong> &amp; <strong><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">源码解析</a></strong></p>
<blockquote>
<p>Google推出的<strong>异步网络请求框架</strong>和<strong>图片加载框架</strong>，该框架封装的扩展性很强，支持 <strong>HttpClient、HttpUrlConnection，甚至支持 OkHttp</strong>。Volley 里面也封装了 <strong>ImageLoader</strong> ，所以如果你愿意你甚至不需要使用图片加载框架，不过这块功能没有一些专门的图片加载框架强大，对于简单的需求可以使用，对于稍复杂点的需求还是需要用到<strong>专门的图片加载框架</strong>。</p>
<p>既然在android2.2之后不建议使用Http Client，那么有没有一个库是android2.2及以下版本使用Http Client，而android2.3及以上版本使用HttpUrlConnection的呢，答案是肯定的，就是<strong>Volley</strong>。</p>
<p>Volley可以说是把<strong>AsyncHttpClient</strong>和<strong>Universal-Image-Loader</strong>的优点集于了一身，既可以像AsyncHttpClient一样非常简单地进行<strong>HTTP通信</strong>，也可以像Universal-Image-Loader一样轻松<strong>加载网络上的图片</strong>。除了简单易用之外，Volley在性能方面也进行了大幅度的调整，它的设计目标就是非常适合去<strong>进行数据量不大，但通信频繁的网络操作</strong>，而对于<strong>大数据量的网络操作</strong>，比如说下载文件等，Volley的表现就会<strong>非常糟糕</strong><br>Volley提供了JsonObjectRequest  JsonArrayRequest  StringRequest  ImageRequest  NetworkImageView 等<strong>Request</strong>形式。</p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>Volley的优势在于处理小文件的http请求</li>
<li>特别适合数据量小，通信频繁的网络操作。android绝大多数都属于这种类型。</li>
<li>不支持 post 大数据，所以不适合上传文件</li>
<li>在Volley中也是可以使用Okhttp作为传输层</li>
<li>Volley在处理高分辨率的图像压缩上有很好的支持</li>
<li>NetworkImageView在GC的使用模式上<strong>更加保守</strong>，在请求清理上也更加积极，networkimageview仅仅依赖于强大的内存引用，并当一个新请求是来自ImageView或ImageView离开屏幕时便会清理掉所有的请求数据</li>
<li>基于接口设计, 扩展性强 </li>
<li><p>一定程度上符合http规范</p>
<blockquote>
<p>返回包括ResponseCode 的处理，请求头的处理，缓存机制的支持</p>
</blockquote>
</li>
<li><p>重试以及优先级的定义</p>
</li>
<li>提供简单的图片加载工具</li>
</ul>
<p><strong>用法</strong></p>
<ul>
<li>创建一个<strong>RequestQueue</strong>对象</li>
<li>创建一个<strong>Request</strong>对象</li>
<li>将Request对象添加到RequestQueue里面</li>
</ul>
<blockquote>
<p><strong>GET</strong></p>
</blockquote>
<pre><code>private void get(){
        RequestQueue queue= Volley.newRequestQueue(getApplicationContext());
        String url=&quot;http://121.41.119.107/test/index.php&quot;;
        StringRequest request=new StringRequest(url, new Response.Listener&lt;String&gt;() {
            @Override
            public void onResponse(String response) {
                Log.d(&quot;TAG&quot;,response);
            }
        }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
            }
        });
        queue.add(request);
}
</code></pre><blockquote>
<p><strong>POST</strong> </p>
<p>通过指定请求方法为<strong>Request.Method.POST</strong>使其成为<strong>post请求</strong>，然后重新getParams方法设置请求参数。当发出POST请求的时候，Volley会尝试调用StringRequest的父类——Request中的getParams()方法来获取POST参数</p>
</blockquote>
<pre><code>private void post() {
        RequestQueue queue = Volley.newRequestQueue(getApplicationContext());
        String url = &quot;http://121.41.119.107/test/login.php&quot;;
        StringRequest request = new StringRequest(Request.Method.POST, url, new Response.Listener&lt;String&gt;() {
            @Override
            public void onResponse(String response) {
                Log.d(&quot;TAG&quot;, response);
            }
        }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
            }
        }) {
            // 重写getParams方法设置参数
            @Override
            protected Map&lt;String, String&gt; getParams() throws AuthFailureError {
                Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
                params.put(&quot;user&quot;, &quot;asas&quot;);
                params.put(&quot;pass&quot;, &quot;12121&quot;);
                params.put(&quot;time&quot;, &quot;1212121&quot;);
                return params;
            }
        };
        queue.add(request);
}
</code></pre><blockquote>
<p><strong>加载图片</strong></p>
<p>加载图像的方法和前面类似，只不过不在是<strong>StringRequest</strong>而是<strong>ImageRequest</strong></p>
</blockquote>
<pre><code>private void getImage() {
        RequestQueue queue = Volley.newRequestQueue(getApplicationContext());
        String url = &quot;https://www.baidu.com/img/bdlogo.png&quot;;
        //第3第4个参数分别用于指定允许图片最大的宽度和高度，如果指定的网络图片的宽度或高度大于这里的最大值，则会对图片进行压缩，指定成0的话就表示不管图片有多大，都**不会进行压缩**
        //第五个参数就是ImageView里中的属性ScaleType
        //第六个参数用于指定图片的颜色属性
        ImageRequest request = new ImageRequest(url, new Response.Listener&lt;Bitmap&gt;() {
            @Override
            public void onResponse(Bitmap response) {
                ImageView iv= (ImageView) findViewById(R.id.iv);
                iv.setImageBitmap(response);
            }
        }, 0, 0, ImageView.ScaleType.CENTER, Bitmap.Config.ARGB_8888, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
            }
     });
     queue.add(request);
}
</code></pre><blockquote>
<p>其实加载图片的功能还远远不止这些，使用<strong>ImageLoader</strong>可以实现对图片的<strong>缓存</strong>，还可以<strong>过滤重复链接，避免发送重复的请求</strong> </p>
<p>ImageLoader的使用方法概括为以下几步:</p>
</blockquote>
<ul>
<li>创建一个RequestQueue对象</li>
<li>创建一个ImageLoader对象</li>
<li>获取一个ImageListener对象</li>
<li><p>调用ImageLoader的get()方法加载网络上的图片</p>
<p>  //继承ImageCache，使用LruCache实现缓存<br>  public class BitmapCache implements ImageLoader.ImageCache {</p>
<pre><code>    private LruCache&lt;String, Bitmap&gt; mCache;
    public BitmapCache() {
        int maxSize = 10 * 1024 * 1024;
        mCache = new LruCache&lt;String, Bitmap&gt;(maxSize) {
            @Override
            protected int sizeOf(String key, Bitmap bitmap) {
                return bitmap.getRowBytes() * bitmap.getHeight();
            }
        };
    }
    @Override
    public Bitmap getBitmap(String url) {
        return mCache.get(url);
    }
    @Override
    public void putBitmap(String url, Bitmap bitmap) {
        mCache.put(url, bitmap);
    }
}
private void getImageByImageLoader() {
    ImageView iv= (ImageView) findViewById(R.id.iv);
    RequestQueue queue = Volley.newRequestQueue(getApplicationContext());
    String url = &quot;https://www.baidu.com/img/bdlogo.png&quot;;
    ImageLoader loader=new ImageLoader(queue,new BitmapCache());
    // 第一个参数指定用于显示图片的ImageView控件
    // 第二个参数指定加载图片的过程中显示的图片
    // 第三个参数指定加载图片失败的情况下显示的图片
    ImageLoader.ImageListener listener=ImageLoader.getImageListener(iv,R.mipmap.ic_launcher,R.mipmap.ic_launcher);
    // 调用ImageLoader的get()方法来加载图片
    // 第一个参数就是图片的URL地址
    // 第二个参数则是刚刚获取到的ImageListener对象
    // 如果想对图片的大小进行限制，也可以使用get()方法的重载，指定图片允许的最大宽度和高度，即通过第三第四个参数指定
    loader.get(url,listener);
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>最后，Volley提供了一种<strong>自定义ImageView</strong>来加载图片，其使用方法可概括为 :</p>
</blockquote>
<ul>
<li>创建一个RequestQueue对象</li>
<li>创建一个ImageLoader对象</li>
<li>在布局文件中添加一个NetworkImageView控件</li>
<li>在代码中获取该控件的实例 </li>
<li>设置要加载的图片地址</li>
</ul>
<blockquote>
<p>我们在布局中申明该控件</p>
</blockquote>
<pre><code>&lt;com.android.volley.toolbox.NetworkImageView
        android:id=&quot;@+id/network_image_view&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_centerInParent=&quot;true&quot;/&gt;
</code></pre><blockquote>
<p>在程序中实现加载</p>
</blockquote>
<pre><code>public void networkImageView(){
        RequestQueue queue = Volley.newRequestQueue(getApplicationContext());
        ImageLoader loader=new ImageLoader(queue,new BitmapCache() );
        NetworkImageView niv = (NetworkImageView) findViewById(R.id.network_image_view);
        niv.setDefaultImageResId(R.mipmap.ic_launcher);//设置加载中显示的图片
        niv.setErrorImageResId(R.mipmap.ic_launcher);//设置加载失败时显示的图片
        niv.setImageUrl(&quot;https://www.baidu.com/img/bdlogo.png&quot;,  loader);//设置目标图片的URL地址
}
</code></pre><blockquote>
<p><strong>自定义Request</strong></p>
<p>在实际应用中，往往需要将<strong>http请求与json</strong>进行集成，而Volley正恰恰支持这样的方式，不过需要我们自己<strong>自定义Request</strong>，这里我们使用google的Gson库进行集成。</p>
</blockquote>
<ul>
<li>继承Request类 </li>
<li><strong>重写parseNetworkResponse</strong>，实现json与实体类转换，由于实体类未定，所以<strong>采用泛型</strong></li>
</ul>
<blockquote>
<p>下文用到的json字符串如下:</p>
</blockquote>
<pre><code>{&quot;name&quot;:&quot;lizhangqu&quot;,&quot;age&quot;:16}

public class GsonRequest&lt;T&gt; extends Request&lt;T&gt; {
    private final Response.Listener&lt;T&gt; mListener;
    private Gson mGson;
    private Class&lt;T&gt; mClass;

    public GsonRequest(int method, String url, Class&lt;T&gt; clazz, Response.Listener&lt;T&gt; listener, Response.ErrorListener errorListener) {
        super(method, url, errorListener);
        mGson = new Gson();
        mClass = clazz;
        mListener = listener;
    }
    public GsonRequest(String url, Class&lt;T&gt; clazz, Response.Listener&lt;T&gt; listener, Response.ErrorListener errorListener) {
        this(Method.GET, url, clazz, listener, errorListener);
    }

    @Override
    protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response) {
        try {
            String jsonString = new String(response.data,
                    HttpHeaderParser.parseCharset(response.headers));
            return Response.success(mGson.fromJson(jsonString, mClass),
                    HttpHeaderParser.parseCacheHeaders(response));
        } catch (UnsupportedEncodingException e) {
            return Response.error(new ParseError(e));
        }
    }
    @Override
    protected void deliverResponse(T response) {
        mListener.onResponse(response);
    }
}
</code></pre><blockquote>
<p>编写测试实体类，两个字段一个name一个age</p>
</blockquote>
<pre><code>public class Person {
    private String name;
    private int age;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, age=&quot; + age +
                &apos;}&apos;;
    }
}
</code></pre><blockquote>
<p>调用方法和StringRequest是一样的。如下所示:</p>
</blockquote>
<pre><code>private void json(){
        RequestQueue queue = Volley.newRequestQueue(getApplicationContext());
        String url = &quot;http://121.41.119.107/test/index.php&quot;;
        GsonRequest&lt;Person&gt; request=new GsonRequest&lt;Person&gt;(url, Person.class, new Response.Listener&lt;Person&gt;() {
            @Override
            public void onResponse(Person response) {
                Log.d(&quot;TAG&quot;,response.toString());
            }
        }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
            }
        });
        queue.add(request);
}
</code></pre><p><a href="http://www.kwstu.com/ArticleView/kwstu_20144118313429" target="_blank" rel="external">基本的使用方法</a><br><a href="http://www.cnblogs.com/freexiaoyu/p/3955137.html" target="_blank" rel="external">直接返回Object的话，用Gson/FastJson与Volley的结合</a></p>
<h3 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h3><p><strong> <a href="https://github.com/square/okhttp" target="_blank" rel="external">Github</a></strong> &amp; <strong> <a href="http://square.github.io/okhttp/" target="_blank" rel="external">官网</a></strong> &amp; <strong><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0326/2643.html" target="_blank" rel="external">源码解析</a></strong></p>
<blockquote>
<p>OkHttp 是一个 Java 的 HTTP+SPDY 客户端开发包，同时也支持 Android。需要Android 2.3以上</p>
<p>OkHttp 是 Square 公司开源的针对<strong> Java 和 Android </strong>程序，封装的一个高性能<strong> http 请求库</strong>，所以它的职责<strong>跟 HttpUrlConnection 是一样的</strong>，支持 spdy、http 2.0、websocket ，支持同步、异步，而且 OkHttp 又封装了线程池，封装了数据转换，封装了参数使用、错误处理等，api 使用起来更加方便。可以把它理解成是一个<strong>封装之后的类似 HttpUrlConnection 的一个东西</strong>，但是你在使用的时候仍然需要自己再做一层封装，这样才能像使用一个框架一样更加顺手。</p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>OKHttp是<strong>Android版Http客户端</strong>。非常高效，支持SPDY、连接池、GZIP和 HTTP 缓存。</li>
<li>默认情况下，OKHttp会自动处理常见的网络问题，像二次连接、SSL的握手问题。</li>
<li>如果你的应用程序中集成了OKHttp，Retrofit默认会使用OKHttp处理其他网络层请求。</li>
<li>从Android4.4开始HttpURLConnection的底层实现采用的是OkHttp</li>
<li>这个onResponse执行的线程并不是UI线程</li>
<li>Interceptor 云端响应拦截器，设置缓存策略<ul>
<li>应用拦截器（ApplicationInterceptors）<blockquote>
<p>主要用于查看请求信息及返回信息，如链接地址、头信息、参数信息等</p>
</blockquote>
</li>
<li>网络拦截器（Network Interceptors）<blockquote>
<p>可以添加、删除或替换请求头信息，还可以改变的请求携带的实体。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong><a href="http://blog.csdn.net/copy_yuan/article/details/51524907" target="_blank" rel="external">缓存的使用方式</a></strong></p>
<pre><code>noCache ：不使用缓存，全部走网络
noStore ： 不使用缓存，也不存储缓存
onlyIfCached ： 只使用缓存
maxAge ：设置最大失效时间，失效则不使用
maxStale ：设置最大失效时间，失效则不使用
minFresh ：设置最小有效时间，失效则不使用
FORCE_NETWORK ： 强制走网络
FORCE_CACHE ：强制走缓存
</code></pre><blockquote>
<p>一般的get、post、基于http文件上传、文件下载、加载图片、支持请求回调、直接返回对象、对象集合、支持session的保持。<br>会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。</p>
</blockquote>
<p><strong>用法</strong></p>
<ul>
<li>新建一个<strong>OkHttpClient</strong>对象</li>
<li>通过Request.Builder对象新建一个<strong>Request</strong>对象</li>
<li>返回执行结果</li>
</ul>
<blockquote>
<p><strong>GET</strong></p>
</blockquote>
<pre><code>private String get(String url) {
        OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder()
                .url(url)
                .build();
        Response response = null;
        try {
            response = client.newCall(request).execute();
            return response.body().string();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
}
</code></pre><blockquote>
<p><strong>POST</strong></p>
<p>POST需要使用<strong>RequestBody</strong>对象，之后再构建Request对象时调用<strong>post</strong>函数将其传入即可</p>
</blockquote>
<pre><code>private String post(String url) {
        OkHttpClient client = new OkHttpClient();
        RequestBody formBody = new FormEncodingBuilder()
                .add(&quot;user&quot;, &quot;Jurassic Park&quot;)
                .add(&quot;pass&quot;, &quot;asasa&quot;)
                .add(&quot;time&quot;, &quot;12132&quot;)
                .build();
        Request request = new Request.Builder()
                .url(url)
                .post(formBody)
                .build();
        Response response = null;
        try {
            response = client.newCall(request).execute();
            return response.body().string();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
}
</code></pre><blockquote>
<p>此外，post的使用方法还<strong>支持文件等操作</strong>等</p>
<p><strong>对Gson的支持</strong></p>
<p>OkHttp还自带了对Gson的支持</p>
</blockquote>
<pre><code>private Person gson(String url){
        OkHttpClient client = new OkHttpClient();
        Gson gson = new Gson();
        Request request = new Request.Builder()
                .url(url)
                .build();
        Response response = null;
        try {
            response = client.newCall(request).execute();
            Person person = gson.fromJson(response.body().charStream(), Person.class);
            return person;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
}
</code></pre><blockquote>
<p><strong>异步操作</strong></p>
<p>以上的两个例子<strong>必须在子线程中完成</strong>，同时okHttp还提供了<strong>异步的方法</strong>调用，通过使用<strong>回调来进行异步调用</strong>，然后OkHttp的回调依然<strong>不在主线程</strong>中，因此该回调中不能操作UI</p>
</blockquote>
<pre><code>private void getAsync(String url) {
        OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder()
                .url(url)
                .build();
        Response response = null;
        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Request request, IOException e) {
            }
            @Override
            public void onResponse(Response response) throws IOException {
                String result = response.body().string();
                Toast.makeText(getApplicationContext(),result,
Toast.LENGTH_SHORT).show();
                //不能操作ui，回调依然在子线程
                Log.d(&quot;TAG&quot;, result);
            }
        });
}
</code></pre><blockquote>
<p>okHttp的使用还有很多内容，这里也不过多介绍，更多内容，参考<a href="http://square.github.io/okhttp/" target="_blank" rel="external">官方网址</a></p>
</blockquote>
<p><strong>大牛张鸿洋版(有实现整合Gson)</strong></p>
<p><a href="https://github.com/hongyangAndroid/okhttp-utils" target="_blank" rel="external">完整的封装地址</a> &amp; <a href="http://blog.csdn.net/lmj623565791/article/details/47911083" target="_blank" rel="external">使用手册</a></p>
<h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h3><p><strong> <a href="https://github.com/square/retrofit" target="_blank" rel="external">Github</a></strong> &amp; <strong> <a href="http://square.github.io/retrofit/" target="_blank" rel="external">官网</a></strong> &amp; <strong><a href="http://link.zhihu.com/?target=http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">源码解析</a></strong></p>
<blockquote>
<p> Retrofit 是 Square 公司出品的默认<strong>基于 OkHttp 封装</strong>的一套 RESTful 网络请求框架，RESTful 是目前流行的一套 api 设计的风格，并不是标准。Retrofit 的<strong>封装</strong>可以说是很强大，里面涉及到<strong>一堆的设计模式</strong>，你可以通过<strong>注解</strong>直接配置请求，你可以<strong>使用不同的 http 客户端</strong>，虽然默认是用 http ，可以使用不同 Json Converter 来序列化数据，同时提供对 RxJava 的支持，使用 Retrofit + OkHttp + RxJava + Dagger2 可以说是目前比较潮的一套框架，但是需要有<strong>比较高的门槛</strong>。</p>
<p>Retrofit 基于注解，提供JSON to POJO(Plain Ordinary Java Object简单Java对象)，POJO to JSON，网络请求(POST，GET,PUT，DELETE等)封装</p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>性能最好，处理最快</li>
<li>使用REST API时非常方便</li>
<li>传输层默认就使用OkHttp</li>
<li>支持NIO</li>
<li>拥有出色的API文档和社区支持</li>
<li>速度上比volley更快</li>
<li>如果你的应用程序中集成了OKHttp，Retrofit默认会使用OKHttp处理其他网络层请求</li>
<li>默认使用Gson</li>
</ul>
<p><strong>使用</strong></p>
<blockquote>
<p>Retrofit支持<strong>同步和异步</strong>两种方式，在使用时，需要将请求地址转换为接口，通过注解来指定请求方法，请求参数，请求头，返回值等信息。还是使用之前的person的那段json值，get请求到服务器后从数据库查询数据，返回值为查询到的数据，post请求向服务器提交一条数据，返回值为提交的数据。</p>
</blockquote>
<ul>
<li><p>首先完成请求所用的service，是一个interface，完全通过注解完成配置</p>
<p>  public interface PersonService {</p>
<pre><code>@Headers({
        &quot;Cache-Control: max-age=640000&quot;,
        &quot;User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko&quot;
})
//通过注解设置请求头
@GET(&quot;/{test}/rest.php&quot;)
//设置请求方法为get，相对路径为注解内内容，其中{test}会被@Path注解指定内容替换
Person getPerson(@Path(&quot;test&quot;) String dir,@Query(&quot;name&quot;) String name);
//@Query用于指定参数
@FormUrlEncoded
//urlencode
@POST(&quot;/test/rest1.php&quot;)
//post提交
Person updatePerson(@Field(&quot;name&quot;) String name,@Field(&quot;age&quot;) int age);
//@Field提交的域
@POST(&quot;/test/rest1.php&quot;)
void updatePerson(@Field(&quot;name&quot;) String name,@Field(&quot;age&quot;) int age, Callback&lt;Person&gt; callback);
//异步回调，不能指定返回值
</code></pre><p>  }</p>
</li>
<li><p>GET </p>
<blockquote>
<p>使用时，通过RestAdapter的实例获得一个接口的实例，其本质是动态代理，注意含有返回值的方法是同步的，不能UI线程中调用，应该在子线程中完成</p>
</blockquote>
<p>  RestAdapter restAdapter = new RestAdapter.Builder()</p>
<pre><code>.setEndpoint(&quot;http://121.41.119.107&quot;)
.build();
</code></pre><p>  PersonService personService=restAdapter.create(PersonService.class);<br>  Person person=personService.getPerson(“test”,”zhangsan”);<br>  Log.d(“TAG”,person.toString());</p>
</li>
<li><p>POST</p>
<blockquote>
<p>POST的调用同Get，获得adapter后获得一个代理对象，然后通过这个代理对象进行网络请求</p>
</blockquote>
<p>  Person person1=personService.updatePerson(“lizhangqu”, 12);<br>  Log.d(“TAG”,person1.toString());</p>
</li>
<li><p>异步请求</p>
<blockquote>
<p>如果要使用异步请求，需要将接口中的方法返回值修改会void，再加入回调参数Callback，就如PersonService中第三个方法一样，请求完成后会回调该callback对象的success或者fail方法。</p>
</blockquote>
<p>  RestAdapter restAdapter = new RestAdapter.Builder()</p>
<pre><code>.setEndpoint(&quot;http://121.41.119.107&quot;)
.build();
</code></pre><p>  PersonService personService=restAdapter.create(PersonService.class);<br>  personService.updatePerson(“lizhangqu”,23, new Callback<person>() {</person></p>
<pre><code>@Override
public void success(Person person, Response response) {
    Log.d(&quot;TAG&quot;, person.toString());
}
@Override
public void failure(RetrofitError error) {
}
</code></pre><p>  });</p>
</li>
</ul>
<blockquote>
<p>Retrofit的使用还有很多内容，下面提供<a href="http://square.github.io/retrofit/" target="_blank" rel="external">官方网址</a>(Retrofit已经更新到2.X版本，本文的使用方法为Retrofit1.x版本)</p>
</blockquote>
<h3 id="RoboSpice"><a href="#RoboSpice" class="headerlink" title="RoboSpice"></a>RoboSpice</h3><p><a href="http://blog.csdn.net/sbsujjbcy/article/details/45070711" target="_blank" rel="external">RoboSpice：android异步网络库简单用法</a></p>
<h3 id="NoHttp"><a href="#NoHttp" class="headerlink" title="NoHttp"></a>NoHttp</h3><p><a href="">参考</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>网络请求库多种多样，最终其本质思想是一致的，要学会融汇贯通，还是要<strong>fucking the source code</strong>。</p>
<p>Square开源组合，用Retrofit(目前已经是2.0+) + OkHttp基本上已经可以处理任何业务场景了，Square开源库质量还是值得信赖。Retrofit的特点是简化了<strong>网络请求流程</strong>，同时自己内部<strong>对OkHtttp客户端做了封装</strong>，同时2.x把之前1.x版本的部分<strong>不恰当职责都转移给OkHttp</strong>了(例如Log，目前用OkHttp的Interceptor来实现)，这样的好处是职责清晰，Retrofit做自己该做的事。而且Retrofit提供<strong>不同的Json Converter</strong>实现（也可以自定义），同时<strong>提供RxJava支持</strong>(返回Observable对象)，配合Jackson(或者<strong>Gson</strong>)和<strong>RxJava</strong>，再加上<strong>Dagger2</strong>，效率大大提高。 <a href="https://www.zhihu.com/question/36989864/answer/70000167?group_id=671569090913013760" target="_blank" rel="external">参见</a></p>
<p>Volley和android-async-http要用的话，也还是要做一下二次封装的。</p>
<p>推荐用最新的<strong>Android Flux</strong>来架构你的Android程序，Facebook提出的架构，文档比较全，数据流总是单向的飞。用过<strong>MVC，MVP</strong>，我还是是比较认同Flux的，而且之前公司用的架构模式跟Flux也比较像。<a href="http://link.zhihu.com/?target=http://www.jianshu.com/p/5aa9cbde299f" target="_blank" rel="external">AndroidFlux入门</a></p>
<p>volley, retrofit, android-async-http 帮你<strong>封装</strong>了具体的<strong>请求</strong>，<strong>线程切换</strong>以及<strong>数据转换</strong>。而OkHttp 是<strong>基于http协议封装的一套请求客户端</strong>，虽然它也<strong>可以开线程</strong>，但根本上它<strong>更偏向真正的请求</strong>，跟<strong>HttpClient, HttpUrlConnection的职责是一样的</strong>。所以不要混淆。</p>
<p>即使单纯使用OkHttp，还是会再包一层的，这样就<strong>等价于Volley</strong>之流的框架，只是封装的好与坏而已.</p>
<p>android-async-http已经比较老了，内部实现是<strong>基于HttpClient</strong>，想必你肯定知道6.0之后HttpClient是不是系统自带的了，不过它在最近的更新中将HttpClient的所有代码copy了一份进来，所以还能使用。</p>
<p>Volley是Google官方出的，Volley在设计的时候是将具体的<strong>请求客户端</strong>做了下<strong>封装</strong>：HurlStack，也就是说可以<strong>支持HttpUrlConnection, HttpClient, OkHttp</strong>，相当于模版模式吧，这样<strong>解耦</strong>还是非常方便的，可以<strong>随意切换</strong>，如果你之前使用过Volley，并习惯使用，那直接写个<strong>OkHttp扩展</strong>就行了。</p>
<p>Volley自己的定位是轻量级网络交互，适合大量的，小数据传输，如果你的项目比较大，那么目测还得把volley再次封装才会好用一些</p>
<p>Retrofit因为是Square出的，所以大家可能对它更崇拜些。<strong>Retrofit的跟Volley是一个套路</strong>，但<strong>解耦的更彻底</strong>: 比方说<strong>通过注解来配置请求参数</strong>，<strong>通过工厂来生成CallAdapter，Converter</strong>，你可以使用不同的<strong>请求适配器</strong>(CallAdapter), 比方说<strong>RxJava</strong>，Java8，Guava。你可以使用不同的<strong>反序列化工具</strong>(Converter)，比方说<strong> json</strong>, protobuff, xml, moshi等等。<br>超级解耦，里面涉及到超多<strong>设计模式</strong>，个人觉得是很<strong>经典的学习案例</strong>。虽然支持<strong>Java8， Guava</strong>你可能也不需要用到。xml，protobuff等数据格式你也可能不需要解析。但是，万一遇到鬼了呢？</p>
<p>至于性能上，完全取决于<strong>请求客户端</strong>，也就是<strong>OkHttp</strong>的性能，跟这些<strong>封装工具</strong>没太大关系。</p>
<p>至于RxJava，最好充分理解其原理之后再使用，别人云亦云，特别team人数多的情况下，总得有个完全精通的吧，万一掉坑里了呢!</p>
<p>OkHttp是android平台最好的网络库，其是高性能的http库，支持同步、异步，而且实现了spdy、http2、websocket协议，api很简洁易用，和Volley一样实现了http协议的缓存。Picasso就是利用OkHttp的<strong>缓存机制</strong>实现其文件缓存，实现的很优雅，很正确，反例就是UIL（universal image loader），自己做的文件缓存，而且不遵守http缓存机制。Retrofit与Picasso一样都是在OkHttp基础之上做的封装，项目中可以直接用了</p>
<p>Volley是一个简单的异步http库，仅此而已。缺点是<strong>不支持同步</strong>，这点会限制开发模式；<strong>不能post大数据</strong>，所以不适合用来上传文件</p>
<p>android-async-http与volley一样是异步网络库，但Volley是封装的HttpUrlConnection，它是封装的HttpClient，而android平台不推荐用HttpClient了，所以这个库已经不适合android平台了</p>
<p>android-async-http使用了nio的方式实现的。OkHttp没有提供nio selector的方式，不过<strong>nio更适合大量连接</strong>的情况，对于移动平台有点杀鸡用牛刀的味道</p>
<p>Picasso、UIL都不支持inbitmap，项目中有用到Picasso的富图片应用需要注意这点</p>
<p>如果是标准的RESTful API,那么用Retrofit会非常爽！网络交互部分代码量可以减少90%。同时支持Gson,契合度很高。另外，Retrofit和OkHttp是亲兄弟，建议一起用，OkHttp是底层库，能够支持一些非标准的HTTP方法，比如PATCH方法。</p>
<p>选<strong>最适合项目的</strong>，选<strong>大多数人选择的</strong>，<strong>选简单易用的</strong>。关于如何选择开源library，可以<a href="https://link.zhihu.com/?target=http://www.jianshu.com/p/f3227c7008d4" target="_blank" rel="external">参考</a>。</p>
</blockquote>
<p><strong>参考资料</strong><br><a href="http://www.jianshu.com/p/df988b5a97b7" target="_blank" rel="external">http://www.jianshu.com/p/df988b5a97b7</a><br><a href="http://www.cnblogs.com/hzhtracy/p/5652548.html" target="_blank" rel="external">http://www.cnblogs.com/hzhtracy/p/5652548.html</a><br><a href="http://blog.csdn.net/sbsujjbcy/article/details/45568053" target="_blank" rel="external">http://blog.csdn.net/sbsujjbcy/article/details/45568053</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/17482095" target="_blank" rel="external">Android Volley完全解析(一)，初识Volley的基本用法 </a><br><a href="http://blog.csdn.net/guolin_blog/article/details/17482165" target="_blank" rel="external">Android Volley完全解析(二)，使用Volley加载网络图片</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/17612763" target="_blank" rel="external">Android Volley完全解析(三)，定制自己的Request</a><br><a href="http://www.jianshu.com/p/8417c2695866" target="_blank" rel="external">http://www.jianshu.com/p/8417c2695866</a><br><a href="http://yeungeek.com/awesome-android-libraries/" target="_blank" rel="external">http://yeungeek.com/awesome-android-libraries/</a><br><a href="https://www.zhihu.com/question/35189851" target="_blank" rel="external">https://www.zhihu.com/question/35189851</a><br><a href="https://www.zhihu.com/question/33008511" target="_blank" rel="external">https://www.zhihu.com/question/33008511</a><br><a href="http://www.itdadao.com/articles/c15a580823p0.html" target="_blank" rel="external">http://www.itdadao.com/articles/c15a580823p0.html</a><br><a href="http://www.jianshu.com/p/050c6db5af5a" target="_blank" rel="external">http://www.jianshu.com/p/050c6db5af5a</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在实际开发中，频繁的接触&lt;strong&gt;网络请求&lt;/strong&gt;，而网络请求的方式很多，最常见的也就那么几个。本
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="开源库" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="网络请求" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
      <category term="OkHttp" scheme="http://yoursite.com/tags/OkHttp/"/>
    
      <category term="Retrofit" scheme="http://yoursite.com/tags/Retrofit/"/>
    
      <category term="Volley" scheme="http://yoursite.com/tags/Volley/"/>
    
  </entry>
  
  <entry>
    <title>Android中的ANR &amp;OOM&amp;FC</title>
    <link href="http://yoursite.com/2016/10/18/Android%E4%B8%AD%E7%9A%84ANR&amp;OOM&amp;FC/"/>
    <id>http://yoursite.com/2016/10/18/Android中的ANR&amp;OOM&amp;FC/</id>
    <published>2016-10-18T07:35:49.000Z</published>
    <updated>2016-10-18T07:36:29.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="ANR-Application-Not-Responding-程序无响应"><a href="#ANR-Application-Not-Responding-程序无响应" class="headerlink" title="ANR(Application Not Responding)程序无响应"></a>ANR(Application Not Responding)程序无响应</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>主线程(UI线程、Main线程)及Android的<strong><em>单线程模型原则</em></strong></li>
</ul>
<blockquote>
<p>当应用启动，系统会创建一个主线程，在这个主线程主要负责创建UI控件，更新UI控件，向UI组件分发事件，也是在这个主线程里，你的应用和Android的UI组件(android.widget and android.view)发生交互。</p>
<p>系统不会为每个组件单独创建线程，在同一个进程里的UI组件都会在UI线程里实例化，系统对每一个组件的调用都从UI线程分发出去。结果就是，响应系统回调的方法(比如响应用户动作的onKeyDown()和各种生命周期回调)永远都是在UI线程里运行。<br>　　<br>另外，Andoid UI组件并不是线程安全的，所以你不能从非UI线程来操纵UI组件。你必须把所有的UI操作放在UI线程里，所以Android的单线程模型有两条原则：</p>
</blockquote>
<ol>
<li>不要阻塞UI线程</li>
<li>不要在UI线程之外访问Android UI组件(主要是这两个包中的组件：android.widget和android.view)。</li>
</ol>
<blockquote>
<p>当App做一些比较耗时的工作的时候，除非你合理地实现，否则单线程模型的性能会很差。特别的是，如果所有的工作都在UI线程，做一些比较耗时的工作比如访问网络或者数据库查询，都会阻塞UI线程，违反单线程模型第一条原则，导致事件停止分发(包括绘制事件)。对于用户来说，应用看起来像是卡住了，更坏的情况是，如果UI线程blocked的时间太长（大约超过5秒），用户就会看到ANR（Application Not Responding）的对话框，如下图：</p>
</blockquote>
<p><img src="http://7jpolu.com1.z0.glb.clouddn.com/android_anr.png" alt=""></p>
<ul>
<li>子线程(Worker线程)</li>
</ul>
<blockquote>
<p>根据单线程模型的两条原则，首先，要保证应用的响应性，不能阻塞UI线程，所以当你的操作不是即时的那种，你应该把他们放进子线程中（也叫做background或者叫worker线程）。<br>　　<br>比如点击按钮后，下载一个图片然后在ImageView中展示：</p>
</blockquote>
<pre><code>public void onClick(View v) {
    new Thread(new Runnable() {
        public void run() {
            Bitmap b = loadImageFromNetwork(&quot;http://example.com/image.png&quot;);
            mImageView.setImageBitmap(b);
        }
    }).start();
}
</code></pre><blockquote>
<p>这段代码用新的线程来处理网络操作，但是它违反了第二条原则：从非UI线程访问UI组件会导致未定义和不能预料的行为。</p>
<p>为了解决这个问题，Android提供了一些方法，从其他线程访问UI线程：</p>
</blockquote>
<ul>
<li>Activity.runOnUiThread(Runnable)</li>
<li>View.post(Runnable)</li>
<li>View.postDelayed(Runnable, long)</li>
<li>Handler+Message机制</li>
<li>AsyncTask机制</li>
</ul>
<blockquote>
<p>比如，上面这段代码可以这么改：</p>
</blockquote>
<pre><code>public void onClick(View v) {
    new Thread(new Runnable() {
        public void run() {
            final Bitmap bitmap = loadImageFromNetwork(&quot;http://example.com/image.png&quot;);
            mImageView.post(new Runnable() {
                public void run() {
                    mImageView.setImageBitmap(bitmap);
                }
            });
        }
    }).start();
}
</code></pre><blockquote>
<p>这么改之后就是线程安全的了。但是，当操作变得复杂的时候，这种代码会变得非常复杂，为了<strong><em>处理非UI线程和UI线程之间更加复杂的交互</em></strong>，可以考虑在worker线程中使用一个Handler，来处理UI线程中传来的消息。也可以继承这个类AsyncTask 。</p>
</blockquote>
<ul>
<li>与UI线程通讯</li>
</ul>
<blockquote>
<p>只有在UI线程中的对象才能操作UI线程中的对象，为了将非UI线程中的数据传送到UI线程，可以使用一个 Handler运行在UI线程中。Handler是Android framework中管理线程的部分，一个Handler对象负责接收发送消息然后处理消息。<br>　　<br>你可以为一个新的线程创建一个Handler，也可以创建一个Handler然后将它和已有线程连接。如果你将一个Handler和你的UI线程连接，处理消息的代码就将会在UI线程中执行。可以在你创建线程池的类的构造方法中实例化Handler的对象，然后用全局变量存储这个对象。<br>　　<br>要和UI线程连接，实例化Handler的时候应该使用Handler(Looper) 这个构造方法。这个构造方法使用了一个 Looper 对象，这是Android系统中线程管理的framework的另一个部分。当你用一个特定的 Looper实例来创建一个 Handler时，这个 Handler就运行在这个 Looper的线程中。</p>
<p>在Handler中，要覆写handleMessage() 方法。Android系统会在Handler管理的相应线程收到新消息时调用这个方法。</p>
<p>一个特定线程的所有Handler对象都会收到同样的方法。（这是一个“一对多”的关系）。</p>
</blockquote>
<h3 id="ANR定义"><a href="#ANR定义" class="headerlink" title="ANR定义"></a>ANR定义</h3><blockquote>
<p>在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，也可以选择“强制关闭”。所以一个流畅的合理的应用程序中不能出现anr，而让用户每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样系统不会显示ANR给用户。默认情况下，在android中Activity的最长执行时间是5秒，BroadcastReceiver的最长执行时间则是10秒。</p>
</blockquote>
<h3 id="什么会引发ANR"><a href="#什么会引发ANR" class="headerlink" title="什么会引发ANR"></a>什么会引发ANR</h3><blockquote>
<p>在Android里，应用程序的响应性是由ActivityManager和WindowManager系统服务监视的 。当它监测到以下情况中的一个时，Android就会针对特定的应用程序显示ANR：</p>
</blockquote>
<ul>
<li>在5秒内没有响应输入的事件(例如，按键按下，屏幕触摸)</li>
<li>BroadcastReceiver在10秒内没有执行完毕</li>
<li>Service Timeout:服务在20s内未执行完成（小概率事件）</li>
<li>ContentProvider Timeout：内容提供者执行超时</li>
</ul>
<blockquote>
<p>造成以上两点的原因有很多，比如在主线程中做了非常耗时的操作，常见的耗时操作：</p>
</blockquote>
<ul>
<li>网络访问</li>
<li>数据库操作</li>
<li>I/O操作(从4.0之后网络IO不允许在主线程中)</li>
<li>SD读写操作</li>
<li>耗时的数据运算</li>
<li>多线程死锁</li>
<li>错误的操作，比如Thread.wait或者Thread.sleep等</li>
</ul>
<h3 id="如何避免ANR"><a href="#如何避免ANR" class="headerlink" title="如何避免ANR"></a>如何避免ANR</h3><ul>
<li><p>运行在主线程里的任何方法都尽可能少做事情。特别是，Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。（可以采用重新开启子线程的方式，然后使用Handler+Message的方式做一些操作，比如更新主线程中的ui等）</p>
</li>
<li><p>应用程序应该避免在BroadcastReceiver里做耗时的操作或计算。但不再是在子线程里做这些任务（因为 BroadcastReceiver的生命周期短），替代的是，如果响应Intent广播需要执行一个耗时的动作的话，应用程序应该启动一个 Service。(此处需要注意的是可以在广播接受者中启动Service，但是却不可以在Service中启动broadcasereciver），建议使用IntentService处理。</p>
</li>
<li><p>避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。如果你的应用程序在响应Intent广 播时需要向用户展示什么，你应该使用Notification Manager来实现。</p>
</li>
<li><p>高耗时的计算如改变位图尺寸, 应该在子线程里（或者以数据库操作为例，通过异步请求的方式）来完成。然而，不是说你的主线程阻塞在那里等待子线程的完成——也不是调用 Thread.wait()或是Thread.sleep()。替代的方法是，主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。以这种方式设计你的应用程序，将能保证你的主线程保持对输入的响应性并能避免由于5秒输入事件的超时引发的ANR对话框。</p>
</li>
<li><p>使用AsyncTask处理耗时IO操作</p>
</li>
<li><p>Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。</p>
</li>
<li><p>通常100到200毫秒就会让人察觉程序反应慢，为了更加提升响应，可以使用下面的几种经验解决方法：</p>
<ul>
<li>如果程序正在后台处理用户的输入，建议使用让用户得知进度，比如使用ProgressBar控件。</li>
<li>程序启动时可以选择加上欢迎界面，避免让用户察觉卡顿。</li>
<li>使用Systrace和TraceView找出影响响应的问题。</li>
</ul>
</li>
</ul>
<h3 id="如何分析ANR"><a href="#如何分析ANR" class="headerlink" title="如何分析ANR"></a>如何分析ANR</h3><blockquote>
<p>ANR发生时都会在log中输出错误信息，从log中可以获得ANR的类型，CPU的使用情况，CPU使用率过高有可能是CPU饥饿导致了ANR。CPU使用率过低说明主线程被block了，如果IOwait高是因为主线程进行I/O操作造成的。</p>
<p>如果开发机器上出现问题，我们也可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。我们从stacktrace中即可找到出问题的具体行数。本例中问题出现在MainActivity.java 27行，因为这里调用了Thread.sleep方法。</p>
</blockquote>
<pre><code>root@htc_m8tl:/ # cat /data/anr/traces.txt | more


----- pid 30307 at 2015-05-30 14:51:14 -----
Cmd line: com.example.androidyue.bitmapdemo

JNI: CheckJNI is off; workarounds are off; pins=0; globals=272

DALVIK THREADS:
(mutexes: tll=0 tsl=0 tscl=0 ghl=0)

&quot;main&quot; prio=5 tid=1 TIMED_WAIT
  | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x416eaf18 self=0x416d8650
  | sysTid=30307 nice=0 sched=0/0 cgrp=apps handle=1074565528
  | state=S schedstat=( 0 0 0 ) utm=5 stm=4 core=3
  at java.lang.VMThread.sleep(Native Method)
  at java.lang.Thread.sleep(Thread.java:1044)
  at java.lang.Thread.sleep(Thread.java:1026)
  at com.example.androidyue.bitmapdemo.MainActivity$1.run(MainActivity.java:27)
  at android.app.Activity.runOnUiThread(Activity.java:4794)
  at com.example.androidyue.bitmapdemo.MainActivity.onResume(MainActivity.java:33)
  at android.app.Instrumentation.callActivityOnResume(Instrumentation.java:1282)
  at android.app.Activity.performResume(Activity.java:5405)
</code></pre><p><strong>一个特例</strong></p>
<blockquote>
<p>BroadcastReceiver过了60秒居然没有ANR？</p>
</blockquote>
<pre><code>public class NetworkReceiver extends BroadcastReceiver{
    private static final String LOGTAG = &quot;NetworkReceiver&quot;;

    @Override
    public void onReceive(Context context, Intent intent) {
        Log.i(LOGTAG, &quot;onReceive intent=&quot; + intent);
        try {
            Thread.sleep(60000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Log.i(LOGTAG, &quot;onReceive end&quot;);
    }
}
</code></pre><blockquote>
<p>实际上已经发生了ANR，只是没有进行对话框弹出而已。这种ANR就是background ANR，即后台程序的ANR，我们可以通过过滤日志验证</p>
</blockquote>
<pre><code>adb logcat | grep &quot;NetworkReceiver|ActivityManager|WindowManager&quot;
I/NetworkReceiver( 4109): onReceive intent=Intent { act=android.net.conn.CONNECTIVITY_CHANGE flg=0x8000010 cmp=com.example.androidyue.bitmapdemo/.NetworkReceiver (has extras) }
I/ActivityManager(  462): No longer want com.android.exchange (pid 1054): empty #17
I/NetworkReceiver( 4109): onReceive end
W/BroadcastQueue(  462): Receiver during timeout: ResolveInfo{5342dde4 com.example.androidyue.bitmapdemo.NetworkReceiver p=0 o=0 m=0x108000}
E/ActivityManager(  462): ANR in com.example.androidyue.bitmapdemo
E/ActivityManager(  462): Reason: Broadcast of Intent { act=android.net.conn.CONNECTIVITY_CHANGE flg=0x8000010 cmp=com.example.androidyue.bitmapdemo/.NetworkReceiver (has extras) }
E/ActivityManager(  462): Load: 0.37 / 0.2 / 0.14
E/ActivityManager(  462): CPU usage from 26047ms to 0ms ago:
E/ActivityManager(  462):   0.4% 58/adbd: 0% user + 0.4% kernel / faults: 1501 minor
E/ActivityManager(  462):   0.3% 462/system_server: 0.1% user + 0.1% kernel
E/ActivityManager(  462):   0% 4109/com.example.androidyue.bitmapdemo: 0% user + 0% kernel / faults: 6 minor
E/ActivityManager(  462): 1.5% TOTAL: 0.5% user + 0.9% kernel + 0% softirq
E/ActivityManager(  462): CPU usage from 87ms to 589ms later:
E/ActivityManager(  462):   1.8% 58/adbd: 0% user + 1.8% kernel / faults: 30 minor
E/ActivityManager(  462):     1.8% 58/adbd: 0% user + 1.8% kernel
E/ActivityManager(  462): 4% TOTAL: 0% user + 4% kernel
W/ActivityManager(  462): Killing ProcessRecord{5326d418 4109:com.example.androidyue.bitmapdemo/u0a10063}: background ANR
I/ActivityManager(  462): Process com.example.androidyue.bitmapdemo (pid 4109) has died.
</code></pre><blockquote>
<p>除了日志，我们还可以根据前面提到的查看traces.txt文件。</p>
<p>我们可以在Android开发者选项—>高级—>显示所有”应用程序无响应“勾选即可对后台ANR也进行弹窗显示，方便查看了解程序运行情况</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>ANR异常也是在程序中自己经常遇到的问题，主要的解决办法自己最常用的就是不要在主线程中做耗时的操作，而应放在子线程中来实现，比如采用Handler+Message的方式，或者是有时候需要做一些和网络相互交互的耗时操作就采用Asyntask异步任务的方式（它的底层其实Handler+Mesage有所区别的是它是线程池）等，在主线程中更新UI。</p>
</blockquote>
<hr>
<h2 id="OOM-Out-Of-Memory-内存溢出"><a href="#OOM-Out-Of-Memory-内存溢出" class="headerlink" title="OOM(Out Of Memory)内存溢出"></a>OOM(Out Of Memory)内存溢出</h2><p><strong>OOM是Android中比较重要的一个知识点，会单独放到一篇博文<a href="https://sh2zqp.github.io/2016/10/10/Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%20%E2%80%94%20%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(3)/" target="_blank" rel="external">里面</a></strong></p>
<hr>
<h2 id="FC-Force-Close-强制关闭"><a href="#FC-Force-Close-强制关闭" class="headerlink" title="FC(Force Close)强制关闭"></a>FC(Force Close)强制关闭</h2><blockquote>
<p>程序或ROM出现了比较严重的错误，必须退出重启。用户过多原因大概有一下:</p>
</blockquote>
<ul>
<li><p>Error</p>
<ul>
<li>OOM                                          内存耗尽</li>
<li>StackOverFlowError                 堆栈溢出</li>
</ul>
</li>
<li><p>RuntimeException                             运行时错误</p>
</li>
</ul>
<blockquote>
<p>如下图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/ForceClose.png" alt=""></p>
<blockquote>
<p>常见的有比如空指针啦，类没有找到啦，资源没找到，就连Android API使用的顺序错误也可能导致（比如     setContentView()之前进行了findViewById()操作）</p>
</blockquote>
<p><strong>解决办法：日志</strong></p>
<blockquote>
<p>以上的问题大多是我们写代码时犯下的逻辑错误或者优化做的非常差，这是绝对绝对不允许出现的。至于解决办法就是DEBUG你懂得。常用的方法无非就是Log打印日志或者借助工具，其实能够熟练运用logcat，明白log各段的大致意思、擅于运用Filter就能够解决大多数问题了。</p>
</blockquote>
<p><strong>如何避免弹出ForceClose窗口,并重启App</strong></p>
<blockquote>
<p>可以实现Thread.UncaughtExceptionHandler接口的uncaughtException方法，此处定义一个MyExceptionHandler，代码如下: </p>
</blockquote>
<pre><code>public class MyExceptionHandler implements Thread.UncaughtExceptionHandler {
    private Activity activity;
    public MyExceptionHandler(Activity activity) {
        this.activity = activity;
    }
    @Override
    public void uncaughtException(Thread thread, Throwable ex) {
    Log.i(&quot;tag&quot;,  &quot;截获到forceclose，异常原因为：&quot; + &quot;\n&quot; +
                ex.toString()+&quot;  Thread:&quot; + thread.getId());
        Intent intent = new Intent(activity, MainActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP
                | Intent.FLAG_ACTIVITY_CLEAR_TASK
                | Intent.FLAG_ACTIVITY_NEW_TASK);
        PendingIntent pendingIntent = PendingIntent.getActivity(
                MyApplication.getInstance().getBaseContext(), 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
        // AlarmManager 是为了设置一个计时器来延迟两秒再执行 pendingIntent 的，也就是重启我们的Activity的任务
        AlarmManager mgr = (AlarmManager) MyApplication.getInstance().getBaseContext()
                .getSystemService(Context.ALARM_SERVICE);
        mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 1000, pendingIntent);

        // This will finish your activity manually
        activity.finish();

        // This will stop your application and take out from it.
        System.exit(2);
    }
}
</code></pre><blockquote>
<p>在uncaughtException方法中，第一个参数thread是线程，指的是发生异常的那个Thread，而不一定是uncaughtException注册的Thread，第二个参数ex是异常，在uncaughtException方法里将进程杀死，想要哪个线程可以处理未捕获异常，thread.setDefaultUncaughtExceptionHandler(this); 这句代码都要在那个线程中执行一次.</p>
<p>在进入RelaunchActivity之后，会产生FC事件，如下：</p>
</blockquote>
<pre><code>public class RelaunchActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_relaunch);
        // 设置处理异常的handler
        Thread.setDefaultUncaughtExceptionHandler(new MyExceptionHandler(this));
        Button forcecloseBtn = (Button) findViewById(R.id.forceclose_btn);
        forcecloseBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // 产生ForceClose的代码
                System.out.println(&quot;&quot; + 1/0);
            }
        }); 
    }
}
</code></pre><blockquote>
<p>如下所示：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/Fc-restart.gif" alt=""></p>
<blockquote>
<p>捕获的日志：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/FC-log.png" alt=""></p>
<p><a href="https://github.com/sh2zqp/ForceCloseSample" target="_blank" rel="external">源码</a></p>
<p><strong>参考资料</strong><br><a href="http://www.cnblogs.com/wonderful0714/p/4588705.html" target="_blank" rel="external">http://www.cnblogs.com/wonderful0714/p/4588705.html</a><br><a href="http://blog.sina.com.cn/s/blog_618199e60101kvbl.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_618199e60101kvbl.html</a><br><a href="http://www.cnblogs.com/mengdd/p/3418780.html" target="_blank" rel="external">http://www.cnblogs.com/mengdd/p/3418780.html</a><br><a href="http://droidyue.com/blog/2015/07/18/anr-in-android/index.html" target="_blank" rel="external">http://droidyue.com/blog/2015/07/18/anr-in-android/index.html</a><br><a href="http://www.jianshu.com/p/9db73a26a8bd" target="_blank" rel="external">http://www.jianshu.com/p/9db73a26a8bd</a><br><a href="http://gityuan.com/2016/07/02/android-anr/" target="_blank" rel="external">http://gityuan.com/2016/07/02/android-anr/</a><br><a href="http://blog.csdn.net/u012974916/article/details/24578927" target="_blank" rel="external">http://blog.csdn.net/u012974916/article/details/24578927</a><br><a href="http://blog.csdn.net/u010983881/article/details/51906920" target="_blank" rel="external">http://blog.csdn.net/u010983881/article/details/51906920</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;ANR-Application-Not-Responding-程序无响应&quot;&gt;&lt;a href=&quot;#ANR-Application-Not-Responding-程序无响应&quot; class=&quot;headerlink&quot; title=&quot;ANR(Application
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ANR" scheme="http://yoursite.com/tags/ANR/"/>
    
      <category term="FC" scheme="http://yoursite.com/tags/FC/"/>
    
      <category term="OOM" scheme="http://yoursite.com/tags/OOM/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议详解</title>
    <link href="http://yoursite.com/2016/10/12/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/10/12/HTTP协议详解/</id>
    <published>2016-10-12T04:12:30.000Z</published>
    <updated>2016-10-19T04:31:11.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<blockquote>
<p>当今web程序的开发技术百家争鸣，ASP.NET, PHP, JSP，Perl, AJAX等等。 无论Web技术在未来如何发展，理解Web程序之间<strong>通信的基本协议</strong>相当重要， 因为它让我们理解了Web应用程序的内部工作。本文将对HTTP协议进行详细的实例讲解。</p>
</blockquote>
<h3 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h3><blockquote>
<p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。</p>
<p>目前我们使用的是HTTP/1.1 版本。
　　</p>
<h3 id="Web服务器，浏览器，代理服务器"><a href="#Web服务器，浏览器，代理服务器" class="headerlink" title="Web服务器，浏览器，代理服务器"></a>Web服务器，浏览器，代理服务器</h3><p>当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？</p>
</blockquote>
<ul>
<li>浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址</li>
<li>解析出IP地址后，根据该IP地址和默认端口80与服务器建立TCP连接</li>
<li>浏览器发出HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器</li>
<li>服务器给出回应，把对应的HTML文件发送给浏览器</li>
<li>释放TCP连接</li>
<li>浏览器将该文本显示出来</li>
</ul>
<blockquote>
<p>实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页，过程如下图所示:</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http1.png" alt=""></p>
<blockquote>
<p>我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。过程如下图所示:</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http2.png" alt=""></p>
<blockquote>
<p>代理服务器就是网络信息的中转站，有什么功能呢？</p>
</blockquote>
<ul>
<li>提高访问速度， 大多数的代理服务器都有缓存功能</li>
<li>突破限制， 也就是翻墙了</li>
<li>隐藏身份</li>
</ul>
<h3 id="URL详解"><a href="#URL详解" class="headerlink" title="URL详解"></a>URL详解</h3><blockquote>
<p>URL(Uniform Resource Locator) 地址用于描述一个网络上的资源，  基本格式如下:</p>
</blockquote>
<pre><code>scheme://host[:port#]/path/.../[;url-params][?query-string][#anchor]
</code></pre><ul>
<li>scheme               指定低层使用的协议(例如：http, https, ftp)</li>
<li>host                     HTTP服务器的IP地址或者域名</li>
<li>port#                   HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 <a href="http://www.cnblogs.com:8080/" target="_blank" rel="external">http://www.cnblogs.com:8080/</a></li>
<li>path                     访问资源的路径</li>
<li>url-params</li>
<li>query-string        发送给http服务器的数据</li>
<li>anchor                 锚</li>
</ul>
<p><strong>URL 的一个例子</strong></p>
<pre><code>http://www.mywebsite.com/sj/test;id=8079?name=sviergn&amp;x=true#stuff
Schema: http
host: www.mywebsite.com
path: /sj/test
URL params: id=8079
Query String: name=sviergn&amp;x=true
Anchor: stuff
</code></pre><h3 id="HTTP协议是无状态的"><a href="#HTTP协议是无状态的" class="headerlink" title="HTTP协议是无状态的"></a>HTTP协议是无状态的</h3><blockquote>
<p>http协议是<strong>无状态的</strong>，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了<strong>Cookie机制来维护状态</strong>.
　　</p>
<h3 id="HTTP消息"><a href="#HTTP消息" class="headerlink" title="HTTP消息"></a>HTTP消息</h3></blockquote>
<h4 id="Request-消息"><a href="#Request-消息" class="headerlink" title="Request 消息"></a>Request 消息</h4><blockquote>
<p>先看<strong>Request 消息</strong>的结构，   Request 消息分为3部分，第一部分叫请求行， 第二部分叫HTTP头, 第三部分是请求实体（内容）. header和body之间有个空行， 结构如下图</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http3.png" alt=""></p>
<blockquote>
<p>第一行中的Method表示请求方法，比如”POST”，”GET”，  Path-to-resource表示请求的资源（请求网址）， Http/version-number 表示HTTP协议的版本号。</p>
<p>HTTP头包括三个部分：请求头（request header），普通头（general header），实体头（body header）</p>
<p>当使用的是”GET” 方法的时候， body是为空的，body只在POST请求方法中。<br>比如我们打开博客园首页的request 如下</p>
</blockquote>
<pre><code>GET http://www.cnblogs.com/ HTTP/1.1
Host: www.cnblogs.com
</code></pre><blockquote>
<p>我们用Fiddler 捕捉一个博客园登录的Request 然后分析下它的结构， 在Inspectors tab下以Raw的方式可以看到完整的Request的消息,如下图:</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http4.png" alt=""></p>
<h4 id="Response消息"><a href="#Response消息" class="headerlink" title="Response消息"></a>Response消息</h4><blockquote>
<p>我们再看<strong>Response消息</strong>的结构， 和Request消息的结构基本一样。 同样也分为三部分，第一部分叫request line（响应行）, 第二部分叫request header（HTTP头），第三部分是body（响应实体，返回内容）. header和body之间也有个空行，  结构如下图:</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http5.png" alt=""></p>
<blockquote>
<p>HTTP/version-number表示HTTP协议的版本号，  status-code（状态响应码） 和message（状态响应码描述） 请看下节<strong>状态代码</strong>的详细解释.</p>
<p>HTTP头也包括三个部分：响应头（response header），普通头（general header），实体头（body header）</p>
<p>响应实体就是HTTP所请求的信息，可以是一个HTML文件或一张图片。</p>
<p>我们用Fiddler 捕捉一个博客园首页的Response然后分析下它的结构， 在Inspectors tab下以Raw的方式可以看到完整的Response的消息,如下图:</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http6.png" alt=""></p>
<h4 id="HTTP头"><a href="#HTTP头" class="headerlink" title="HTTP头"></a>HTTP头</h4><blockquote>
<p>HTTP头并不是严格的要求，仅是一个标签，如果浏览器可以解析就会按照一些标准（如浏览器自身的标准，W3C的标准）去解析这个头，否则不识别的头就会被浏览器忽视，对服务器也同理。</p>
<p>综上，HTTP请求头包含4种，如下：</p>
</blockquote>
<ul>
<li>普通头（General Header）</li>
<li>请求头（Request Header）</li>
<li>响应头（Response Header）</li>
<li>实体头（Entity Header）</li>
</ul>
<h3 id="Get和Post方法的区别"><a href="#Get和Post方法的区别" class="headerlink" title="Get和Post方法的区别"></a>Get和Post方法的区别</h3><blockquote>
<p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是<strong>GET,POST,PUT,DELETE</strong>. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的<strong>查，改，增，删</strong>4个操作。 我们最常见的就是<strong>GET和POST</strong>了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p>
</blockquote>
<p><strong>GET和POST的区别</strong></p>
<ul>
<li>GET主要用于简单的获取页面信息，同时也可以包含一些特殊的请求信息（如提交用户名和密码之类等），提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456.  POST方法是把提交的数据放在HTTP包的Body中.</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制，不能超过1024个字节），而POST方法提交的数据没有限制.</li>
<li>GET方式需要使用<strong>Request.QueryString</strong>来取得变量的值，而POST方式通过<strong>Request.Form</strong>来获取变量的值。</li>
<li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</li>
</ul>
<blockquote>
<p>如下图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http16.png" alt="">
　　</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><blockquote>
<p>Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。<br>　　<br>状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response.<br>　　<br>HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别:</p>
</blockquote>
<ul>
<li>1XX  信息类：提示信息 - 表示请求已被成功接收，继续处理</li>
<li>2XX  响应成功类：成功 - 表示请求已被成功接收，理解，接受</li>
<li>3XX  重定向类：重定向 - 要完成请求必须进行更进一步的处理</li>
<li>4XX  客户端错误类：客户端错误 -  请求有语法错误或请求无法实现</li>
<li><p>5XX  服务器端错误类：服务器端错误 -   服务器未能实现合法的请求</p>
<pre><code>　　
</code></pre><p><strong>看看一些常见的状态码</strong></p>
</li>
<li><p>200 OK</p>
</li>
</ul>
<blockquote>
<p>最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端,如下图,打开博客园首页:</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http7.png" alt=""></p>
<ul>
<li>302 Found<pre><code>　　
</code></pre><blockquote>
<p>重定向，<strong>新的URL会在response中的Location</strong>中返回，浏览器将会使用新的URL<strong>发出新的Request</strong>。<br>　　<br>例如在IE中输入<a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a>. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一个Request.</p>
</blockquote>
</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http8.png" alt=""></p>
<ul>
<li>304 Not Modified<pre><code>　　
</code></pre><blockquote>
<p>代表上次的文档已经被缓存了， 还可以继续使用，例如打开博客园首页， 发现很多 Response 的status code 都是304</p>
</blockquote>
</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http9.png" alt=""></p>
<blockquote>
<p>提示：如果你不想使用本地缓存可以强制刷新页面
　　</p>
<ul>
<li>400 Bad Request  客户端请求与语法错误，不能被服务器所理解</li>
<li>403 Forbidden 服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found 请求资源不存在（输错了URL）, 比如在IE中输入一个错误的URL， <a href="http://www.cnblogs.com/tesdf.aspx" target="_blank" rel="external">http://www.cnblogs.com/tesdf.aspx</a></li>
</ul>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http10.png" alt=""></p>
<ul>
<li>500 Internal Server Error 服务器发生了不可预期的错误</li>
<li>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
<h3 id="HTTP-Request-header-请求头"><a href="#HTTP-Request-header-请求头" class="headerlink" title="HTTP Request header(请求头)"></a>HTTP Request header(请求头)</h3><p>　　</p>
<blockquote>
<p>使用Fiddler 能很方便的查看Request header, 点击Inspectors tab -> Request tab -> headers  如下图所示.</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http11.png" alt=""></p>
<blockquote>
<p>header 有很多，比较难以记忆，我们也按照Fiddler那样把header <strong>进行分类</strong>，这样比较清晰也容易记忆。
　　</p>
<ul>
<li>Cache 头域</li>
</ul>
</blockquote>
<pre><code>- If-Modified-Since
              　
    &gt; 作用： 把浏览器端**缓存页面的最后修改时间**发送到服务器去，服务器会把这个时间与服务器上**实际文件的最后修改时间**进行**对比**。如果时间一致，那么返回**304**，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。
</code></pre><p>　　<br>    If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT,实例如下图:</p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http12.png" alt=""></p>
<ul>
<li><p>If-None-Match</p>
<pre><code>　　
</code></pre><blockquote>
<p>作用: <strong>If-None-Match和ETag</strong>一起工作，工作原理是<strong>在HTTP Response中添加ETag信息</strong>。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(<strong>ETag的值</strong>)。如果服务器验证资源的<strong>ETag没有改变</strong>（该资源没有更新），将返回一个<strong>304</strong>状态告诉客户端使用本地缓存文件。否则将返回200状态和<strong>新的资源和Etag</strong>.  使用这样的机制将提高网站的性能.</p>
</blockquote>
<p>  If-None-Match: “03f2b33c0bfcc1:0”,实例如下图:</p>
</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http13.png" alt=""></p>
<ul>
<li><p>Pragma</p>
<pre><code>　　
</code></pre><blockquote>
<p>作用： 防止页面被缓存， 在<strong>HTTP/1.1</strong>版本中，它和Cache-Control: no-cache作用一模一样.<br>　　<br>Pargma只有一个用法，如下：</p>
</blockquote>
<p>  Pragma: no-cache
　　</p>
<blockquote>
<p>注意: 在<strong>HTTP/1.0</strong>版本中，只实现了Pragma: no-cache, 没有实现Cache-Control
　　</p>
</blockquote>
</li>
<li><p>Cache-Control</p>
<pre><code>　　
</code></pre><blockquote>
<p>作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的<strong>缓存机制</strong>。各个指令含义如下:</p>
</blockquote>
</li>
<li><p>Cache-Control:Public   可以被任何缓存所缓存</p>
<ul>
<li>Cache-Control:Private  内容只缓存到私有缓存中<ul>
<li>Cache-Control:no-cache  所有内容都不会被缓存<pre><code>        　　
</code></pre><blockquote>
<p>还有其他的一些用法,请大家参考其他的资料.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Client 头域</p>
<ul>
<li><p>Accept</p>
<pre><code>        　　
</code></pre><blockquote>
<p>作用： 浏览器端可以接受的媒体类型</p>
</blockquote>
<p>Accept: text/html  </p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>代表浏览器可以接受服务器回发的类型为 text/html  也就是我们常说的html文档,如果服务器无法返回text/html类型的数据，服务器应该返回一个<strong>406</strong>错误(non acceptable)</p>
<p>通配符 * 代表任意类型</p>
<p>Accept: */*  </p>
<p>代表浏览器可以处理<strong>所有类型</strong>，(一般浏览器发给服务器都是发这个).
　　</p>
<ul>
<li>Accept-Encoding：<pre><code>　　
</code></pre>作用： 浏览器申明自己接收的<strong>编码方法</strong>，通常指定<strong>压缩方法</strong>，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）;<br>　　<br>  Accept-Encoding: gzip, deflate
　　</li>
<li>Accept-Language<pre><code>　　
</code></pre>作用： 浏览器申明自己接收的语言。<br>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；<br>　　<br>  Accept-Language: en-us
　　</li>
<li>User-Agent<pre><code>　　
</code></pre>作用：告诉HTTP服务器， 客户端使用的<strong>操作系统和浏览器的名称和版本</strong>.<br>　　<br>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。<br>　　<br>  User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)
　　</li>
<li>Accept-Charset<pre><code>　　
</code></pre>作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）；</li>
</ul>
</blockquote>
<ul>
<li><p>Cookie/Login 头域</p>
<pre><code>　　
</code></pre><ul>
<li><strong>Cookie</strong>:
   　　<blockquote>
<p>作用： <strong>最重要的header</strong>, 将cookie的值发送给HTTP 服务器　　</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Entity头域</p>
<pre><code>　　
</code></pre><ul>
<li><p>Content-Length</p>
<pre><code>　　
</code></pre><blockquote>
<p>作用：发送给HTTP服务器数据的长度。</p>
</blockquote>
<p>Content-Length: 38
　　</p>
</li>
</ul>
</li>
<li><p>Content-Type</p>
<blockquote>
<p>作用：</p>
</blockquote>
<p>  Content-Type: application/x-www-form-urlencoded
  　　</p>
</li>
<li><p>Miscellaneous 头域</p>
<pre><code>　　
</code></pre><ul>
<li><p>Referer:</p>
<pre><code>　　
</code></pre><blockquote>
<p>作用： 提供了Request的<strong>上下文信息的服务器</strong>，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</p>
</blockquote>
<p>Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT" target="_blank" rel="external">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></p>
</li>
</ul>
</li>
<li><p>Transport 头域</p>
<pre><code>　　
</code></pre><ul>
<li><p>Connection</p>
<blockquote>
<p>Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接<br>　　<br>例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。
　　</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Host（发送请求时，该报头域是必需的）</p>
<pre><code>　　
</code></pre><blockquote>
<p>作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的<br>　　<br>例如: 我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html" target="_blank" rel="external">http://www.guet.edu.cn/index.html</a><br>浏览器发送的请求消息中，就会包含Host请求报头域，如下：</p>
</blockquote>
<p>  Host：<a href="http://www.guet.edu.cn" target="_blank" rel="external">http://www.guet.edu.cn</a>
　　</p>
<blockquote>
<p>此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号</p>
</blockquote>
</li>
</ul>
<h3 id="HTTP-Response-header-响应头"><a href="#HTTP-Response-header-响应头" class="headerlink" title="HTTP Response header(响应头)"></a>HTTP Response header(响应头)</h3><blockquote>
<p>同样使用Fiddler 查看Response header, 点击Inspectors tab ->Response tab-> headers  如下图所示</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http14.png" alt=""></p>
<blockquote>
<p>我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。
　　</p>
<ul>
<li>Cache头域<pre><code>　　
</code></pre><ul>
<li>Date<pre><code>　　
</code></pre>作用:  生成消息的具体时间和日期</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code>Date: Sat, 11 Feb 2012 11:35:14 GMT 
</code></pre><p>　　</p>
<ul>
<li><p>Expires</p>
<pre><code>　　
</code></pre><blockquote>
<p>作用: 浏览器会在指定过期时间内使用本地缓存</p>
</blockquote>
<p>  Expires: Tue, 08 Feb 2022 11:35:14 GMT
　　</p>
</li>
<li>Vary<pre><code>　　
</code></pre><blockquote>
<p>作用：<br>　　<br>  Vary: Accept-Encoding
　　</p>
</blockquote>
</li>
<li><p>Cookie/Login 头域</p>
<pre><code>　　
</code></pre><ul>
<li><p>P3P</p>
<pre><code>　　
</code></pre><blockquote>
<p>作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题</p>
</blockquote>
<p>P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR
　　</p>
</li>
</ul>
</li>
<li><p><strong>Set-Cookie</strong></p>
<pre><code>　　
</code></pre><blockquote>
<p>作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie.</p>
</blockquote>
<p>  Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com</p>
</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/http15.png" alt=""></p>
<ul>
<li><p>Entity头域</p>
<pre><code>　　
</code></pre><ul>
<li><p>ETag</p>
<pre><code>　　
</code></pre><blockquote>
<p>作用:  和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例）</p>
</blockquote>
<p>ETag: “03f2b33c0bfcc1:0”
　　</p>
</li>
</ul>
</li>
<li><p>Last-Modified:</p>
<pre><code>　　
</code></pre><blockquote>
<p>作用： 用于指示资源的<strong>最后修改日期和时间</strong>。（实例请看上节的If-Modified-Since的实例）</p>
</blockquote>
<p>  Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT
　　</p>
</li>
<li><p>Content-Type</p>
<pre><code>　　
</code></pre><blockquote>
<p>作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集,</p>
</blockquote>
<p>  Content-Type: text/html; charset=utf-8<br>  Content-Type: text/html; charset=GB2312<br>  Content-Type: image/jpeg
　　</p>
</li>
<li><p>Content-Length</p>
<blockquote>
<p>指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p>
</blockquote>
<p>  Content-Length: 19847
  　　</p>
</li>
<li><p>Content-Encoding</p>
<pre><code>　　
</code></pre><blockquote>
<p>WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。</p>
</blockquote>
<p>  Content-Encoding：gzip
　　</p>
</li>
<li><p>Content-Language</p>
<pre><code>　　
</code></pre><blockquote>
<p>作用： WEB服务器告诉浏览器自己响应的对象的语言者</p>
</blockquote>
<p>  Content-Language:da
　　</p>
</li>
<li><p>Miscellaneous 头域</p>
<pre><code>　　
</code></pre><ul>
<li><p>Server:</p>
<blockquote>
<p>作用：指明HTTP服务器的软件信息<br>　　<br>Server: Microsoft-IIS/7.5
　　</p>
</blockquote>
</li>
</ul>
</li>
<li><p>X-AspNet-Version:</p>
<pre><code>　　
</code></pre><blockquote>
<p>作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本</p>
</blockquote>
<p>  X-AspNet-Version: 4.0.30319
　　</p>
</li>
<li>X-Powered-By:<pre><code>　　
</code></pre><blockquote>
<p>作用：表示网站是用什么技术开发的</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>  X-Powered-By: ASP.NET
　　</p>
<ul>
<li>Transport头域<pre><code>　　
</code></pre><ul>
<li>Connection<br>　　<br>Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</li>
</ul>
</li>
</ul>
<p>Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。
　　</p>
<ul>
<li>Location头域<pre><code>　　
</code></pre><ul>
<li>Location<br>　　<br>作用： 用于重定向一个新的位置， 包含新的URL地址，实例请看304状态实例
　　<h3 id="HTTP协议是无状态的和Connection-keep-alive的区别"><a href="#HTTP协议是无状态的和Connection-keep-alive的区别" class="headerlink" title="HTTP协议是无状态的和Connection: keep-alive的区别"></a>HTTP协议是无状态的和Connection: keep-alive的区别</h3>　　<br>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。<br>　　<br>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。<br>　　<br>从<strong>HTTP/1.1</strong>起，默认都开启了<strong>Keep-Alive</strong>，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。<br>　　<br>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ul>
<li>HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议，它是一个安全通信通道，基于HTTP开发，用于客户端与服务器之间进行信息交换。它使用了安全套接字层（SSL）进行信息交换，是HTTP的安全版本。</li>
<li>HTTPS协议需要到CA去申请证书，一般免费证书很少，需要缴费。</li>
<li>HTTP是超文本传输协议，是一个明文传输协议，而HTTPS则具有安全性的SSL加密传输协议，需要身份认证。</li>
<li>HTTP和HTTPS使用完全不同的连接方式，用的端口也不一样，HTTP是80，HTTPS是443。</li>
<li>HTTP协议连接简单，无状态，需要使用Cookie进行状态的保存。</li>
</ul>
<p><strong>参考资料</strong><br><a href="http://kb.cnblogs.com/page/130970/" target="_blank" rel="external">http://kb.cnblogs.com/page/130970/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;当今web程序的开发技术百家争鸣，ASP.NET, PHP, JSP，Perl, AJAX等等。 无论Web技术在未来如何发展，理解Web程序之间&lt;strong&gt;通信的基本协议&lt;/strong&gt;相当重要， 因为它让我们理解了Web应用程序
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Android消息处理机制 — 全面解析(3)</title>
    <link href="http://yoursite.com/2016/10/10/Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%20%E2%80%94%20%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(3)/"/>
    <id>http://yoursite.com/2016/10/10/Android消息处理机制 — 全面解析(3)/</id>
    <published>2016-10-10T06:06:06.000Z</published>
    <updated>2016-10-10T06:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="入门使用篇"><a href="#入门使用篇" class="headerlink" title="入门使用篇"></a>入门使用篇</h2><h3 id="错误范例"><a href="#错误范例" class="headerlink" title="错误范例"></a>错误范例</h3><p><strong>引例 — 下载一张图片</strong></p>
<blockquote>
<p>网络下载是一个耗时操作，不知道什么时候才能完成，所以需要开启一个子线程去进行网络的请求操作，等到图片下载完毕后，需要在UI界面上显示出来，由于UI控件不是线程安全的，所以，需要从子线程再转到UI线程(主线程)去更新UI界面。</p>
<p>错误的做法：</p>
</blockquote>
<pre><code>public class MainActivity extends Activity implements Button.OnClickListener {
    private TextView statusTextView = null;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        statusTextView = (TextView)findViewById(R.id.statusTextView);
        Button btnDownload = (Button)findViewById(R.id.btnDownload);
        btnDownload.setOnClickListener(this);
    }
    @Override
    public void onClick(View v) {
        DownloadThread downloadThread = new DownloadThread();
        downloadThread.start();
    }
    class DownloadThread extends Thread {
        @Override
        public void run() {
            try{
                System.out.println(&quot;开始下载文件&quot;);
                //此处让线程DownloadThread休眠5秒中，模拟文件的耗时过程
                Thread.sleep(5000);
                System.out.println(&quot;文件下载完成&quot;);
                //文件下载完成后更新UI
                MainActivity.this.statusTextView.setText(&quot;文件下载完成&quot;);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
}
</code></pre><blockquote>
<p>单击”下载“启动一个新的线程去执行实际的下载操作，执行完毕后更新UI界面。但在实际运行到代码</p>
</blockquote>
<pre><code>MainActivity.this.statusTextView.setText(“文件下载完成”)
</code></pre><blockquote>
<p>会报错如下，系统崩溃退出： </p>
</blockquote>
<pre><code>android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 
</code></pre><blockquote>
<p>意思是只有创建View的原始线程(主线程)才能更新View。出现这样错误的原因是Android中的View不是线程安全的，在Android应用启动时，会自动创建一个线程，即程序的主线程，主线程负责UI的展示、UI事件消息的派发处理等等，因此主线程也叫做UI线程，statusTextView是在UI线程中创建的，当我们在DownloadThread线程中去更新UI线程中创建的statusTextView时自然会报上面的错误。Android的UI控件是非线程安全的，其实很多平台的UI控件都是非线程安全的，比如C#的.Net Framework中的UI控件也是非线程安全的，所以不仅仅在Android平台中存在从一个新线程中去更新UI线程中创建的UI控件的问题。不同的平台提供了不同的解决方案以实现跨线程跟新UI控件，Android为了解决这种问题引入了<strong><em>Handler机制</em></strong>。</p>
</blockquote>
<h3 id="Handler解决问题"><a href="#Handler解决问题" class="headerlink" title="Handler解决问题"></a>Handler解决问题</h3><blockquote>
<p>Handler是Android中引入的<strong><em>一种让开发者参与处理线程中消息循环的机制</em></strong>。每个Hanlder都关联了一个线程，每个线程内部都维护了一个消息队列MessageQueue，这样Handler实际上也就关联了一个消息队列。可以通过Handler将<strong><em>Message和Runnable对象</em></strong>发送到该Handler所关联线程的MessageQueue（消息队列）中，然后该消息队列一直在循环拿出一个Message，对其进行处理，处理完之后拿出下一个Message，继续进行处理，周而复始。当创建一个Handler的时候，该Handler就绑定了当前创建Hanlder的线程。从这时起，该Hanlder就可以发送Message和Runnable对象到该Handler对应的消息队列中，当从MessageQueue取出某个Message时，会让Handler对其进行处理。</p>
<p>Handler可以用来在<strong><em>多线程间进行通信</em></strong>，在另一个线程中去更新UI线程中的UI控件只是Handler使用中的一种<strong><em>典型案例</em></strong>，除此之外，Handler可以做很多其他的事情。每个Handler都绑定了一个线程，假设存在两个线程ThreadA和ThreadB，并且HandlerA绑定了 ThreadA，在ThreadB中的代码执行到某处时，出于某些原因，我们需要让ThreadA执行某些代码，此时我们就可以使用Handler，我们可以在ThreadB中向HandlerA中加入某些信息以告知ThreadA中该做某些处理了。</p>
<p>由此可以看出，Handler是Thread的代言人，是多线程之间通信的桥梁，通过Handler，我们可以在一个线程中控制另一个线程去做某事。</p>
<p>Handler提供了两种方式解决本文一开始遇到的问题（在一个新线程中更新主线程中的UI控件），一种是通过post方法，一种是调用sendMessage方法。</p>
</blockquote>
<ul>
<li><p><strong>post</strong></p>
<p>  public class MainActivity extends Activity implements Button.OnClickListener {</p>
<pre><code>private TextView statusTextView = null;

//uiHandler在主线程中创建，所以自动绑定主线程
private Handler uiHandler = new Handler();

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    statusTextView = (TextView)findViewById(R.id.statusTextView);
    Button btnDownload = (Button)findViewById(R.id.btnDownload);
    btnDownload.setOnClickListener(this);
    System.out.println(&quot;Main thread id &quot; + Thread.currentThread().getId());
}

@Override
public void onClick(View v) {
    DownloadThread downloadThread = new DownloadThread();
    downloadThread.start();
}

class DownloadThread extends Thread{
    @Override
    public void run() {
        try{
            System.out.println(&quot;DownloadThread id &quot; + Thread.currentThread().getId());
            System.out.println(&quot;开始下载文件&quot;);
            //此处让线程DownloadThread休眠5秒中，模拟文件的耗时过程
            Thread.sleep(5000);
            System.out.println(&quot;文件下载完成&quot;);
            //文件下载完成后更新UI
            Runnable runnable = new Runnable() {
                @Override
                public void run() {
                    System.out.println(&quot;Runnable thread id &quot; + Thread.currentThread().getId());
                    MainActivity.this.statusTextView.setText(&quot;文件下载完成&quot;);
                }
            };
            uiHandler.post(runnable);
        } catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>我们在Activity中创建了一个Handler成员变量uiHandler，Handler有个特点，在执行new Handler()的时候，默认情况下Handler会绑定当前代码执行的线程，我们在主线程中实例化了uiHandler，所以uiHandler就自动绑定了主线程，即UI线程。当我们在DownloadThread中执行完耗时代码后，我们将一个<strong><em>Runnable对象</em></strong>通过<strong><em>post方法</em></strong>传入到了Handler中，Handler会在合适的时候让<strong><em>主线程执行Runnable中的代码</em></strong>，这样Runnable就在主线程中执行了，从而正确更新了主线程中的UI。以下是输出结果： </p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20150727232302171" alt=""></p>
<blockquote>
<p>通过输出结果可以看出，Runnable中的代码所执行的线程ID与DownloadThread的线程ID不同，而与主线程的线程ID相同，因此我们也由此看出在执行了<strong><em>Handler.post(Runnable)</em></strong>这句代码之后，运行Runnable代码的线程与Handler所绑定的线程是一致的，而与执行Handler.post(Runnable)这句代码的线程（DownloadThread）无关。</p>
</blockquote>
<ul>
<li><p><strong>sendMessage</strong></p>
<p>  public class MainActivity extends Activity implements Button.OnClickListener {</p>
<pre><code>private TextView statusTextView = null;

//uiHandler在主线程中创建，所以自动绑定主线程
private Handler uiHandler = new Handler(){
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what){
            case 1:
                System.out.println(&quot;handleMessage thread id &quot; + Thread.currentThread().getId());
                System.out.println(&quot;msg.arg1:&quot; + msg.arg1);
                System.out.println(&quot;msg.arg2:&quot; + msg.arg2);
                MainActivity.this.statusTextView.setText(&quot;文件下载完成&quot;);
                break;
        }
    }
};

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    statusTextView = (TextView)findViewById(R.id.statusTextView);
    Button btnDownload = (Button)findViewById(R.id.btnDownload);
    btnDownload.setOnClickListener(this);
    System.out.println(&quot;Main thread id &quot; + Thread.currentThread().getId());
}

@Override
public void onClick(View v) {
    DownloadThread downloadThread = new DownloadThread();
    downloadThread.start();
}

class DownloadThread extends Thread{
    @Override
    public void run() {
        try{
            System.out.println(&quot;DownloadThread id &quot; + Thread.currentThread().getId());
            System.out.println(&quot;开始下载文件&quot;);
            //此处让线程DownloadThread休眠5秒中，模拟文件的耗时过程
            Thread.sleep(5000);
            System.out.println(&quot;文件下载完成&quot;);
            //文件下载完成后更新UI
            Message msg = new Message();
            //虽然Message的构造函数式public的，我们也可以通过以下两种方式通过循环对象获取Message
            //msg = Message.obtain(uiHandler);
            //msg = uiHandler.obtainMessage();

            //what是我们自定义的一个Message的识别码，以便于在Handler的handleMessage方法中根据what识别
            //出不同的Message，以便我们做出不同的处理操作
            msg.what = 1;

            //我们可以通过arg1和arg2给Message传入简单的数据
            msg.arg1 = 123;
            msg.arg2 = 321;
            //我们也可以通过给obj赋值Object类型传递向Message传入任意数据
            //msg.obj = null;
            //我们还可以通过setData方法和getData方法向Message中写入和读取Bundle类型的数据
            //msg.setData(null);
            //Bundle data = msg.getData();

            //将该Message发送给对应的Handler
            uiHandler.sendMessage(msg);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>通过Message与Handler进行通信的步骤是： </p>
</blockquote>
<ul>
<li>重写Handler的handleMessage方法，根据Message的what值进行不同的处理操作 </li>
<li>创建Message对象 , 虽然Message的构造函数式public的,我们还可以通过Message.obtain()或Handler.obtainMessage()来获得一个Message对象（Handler.obtainMessage()内部其实调用了Message.obtain()）。 </li>
<li>设置Message的what值 , Message.what是我们自定义的一个Message的识别码，以便于在Handler的handleMessage方法中根据what识别出不同的Message，以便我们做出不同的处理操作。 </li>
<li>设置Message的所携带的数据，简单数据可以通过两个int类型的field arg1和arg2来赋值，并可以在handleMessage中读取。 </li>
<li>如果Message需要携带复杂的数据，那么可以设置Message的obj字段，obj是Object类型，可以赋予任意类型的数据。或者可以通过调用Message的setData方法赋值Bundle类型的数据，可以通过getData方法获取该Bundle数据。 </li>
<li>我们通过Handler.sendMessage(Message)方法将Message传入Handler中让其在handleMessage中对其进行处理。 </li>
</ul>
<blockquote>
<p>需要说明的是，如果在handleMessage中 不需要判断Message类型，那么就无须设置Message的what值；而且让Message携带数据也不是必须的，只有在需要的时候才需要让其携带数据；如果确实需要让Message携带数据，应该尽量使用arg1或arg2或两者，能用arg1和arg2解决的话就不要用obj，因为用arg1和arg2更高效。 </p>
</blockquote>
<p><strong>程序的运行结果如下</strong></p>
<p><img src="http://img.blog.csdn.net/20150729000800538" alt=""></p>
<blockquote>
<p>由上我们可以看出，执行handleMessage的线程与创建Handler的线程是同一线程，在本示例中都是主线程。执行handleMessage的线程与执行uiHandler.sendMessage(msg)的线程没有关系。</p>
</blockquote>
<hr>
<p><strong>本文主要是对Handler和消息循环的实现原理进行源码分析</strong></p>
<h2 id="源码解析篇"><a href="#源码解析篇" class="headerlink" title="源码解析篇"></a>源码解析篇</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>Handler是Android中引入的一种让开发者参与处理线程中消息循环的机制。我们在使用Handler的时候与Message打交道最多，Message是Hanlder机制向开发人员暴露出来的相关类，可以通过Message类完成大部分操作Handler的功能。但作为程序员，我不能只知道怎么用Handler，还要知道其内部如何实现的。Handler的内部实现主要涉及到如下几个类: Thread、MessageQueue和Looper。这几类之间的关系可以用如下的图来简单说明：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20150801010109197" alt=""></p>
<blockquote>
<p>Thread是最基础的，Looper和MessageQueue都构建在Thread之上，Handler又构建在Looper和MessageQueue之上，我们通过Handler间接地与下面这几个相对底层一点的类打交道。</p>
</blockquote>
<h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><blockquote>
<p>最基础最底层的是Thread，每个线程内部都维护了一个消息队列MessageQueue。MessageQueue是存放消息的队列。那队列中存储的消息是什么呢？假设我们在UI界面上单击了某个按钮，而此时程序又恰好收到了某个广播事件，那我们如何处理这两件事呢？ 因为一个线程在某一时刻只能处理一件事情，不能同时处理多件事情，所以我们不能同时处理按钮的单击事件和广播事件，我们只能挨个对其进行处理，只要挨个处理就要有处理的先后顺序。 为此Android把UI界面上单击按钮的事件封装成了一个Message，将其放入到MessageQueue里面去，即将单击按钮事件的Message入栈到消息队列中，然后再将广播事件的封装成以Message，也将其入栈到消息队列中。也就是说一个Message对象表示的是线程需要处理的一件事情，消息队列就是一堆需要处理的Message的池。线程Thread会依次取出消息队列中的消息，依次对其进行处理。MessageQueue中有两个比较重要的方法，一个是<strong><em>enqueueMessage</em></strong>方法，一个是<strong><em>next</em></strong>方法。enqueueMessage方法用于将一个Message放入到消息队列MessageQueue中，next方法是从消息队列MessageQueue中阻塞式地取出一个Message。在Android中，消息队列负责管理着顶级程序对象（Activity、BroadcastReceiver等）以及由其创建的所有窗口。需要注意的是，消息队列不是Android平台特有的，其他的平台框架也会用到消息队列，比如微软的MFC框架等。</p>
</blockquote>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><blockquote>
<p>消息队列MessageQueue只是存储Message的地方，真正让消息队列循环起来的是Looper，这就好比消息队列MessageQueue是个水车，那么Looper就是让水车转动起来的河水，如果没有河水，那么水车就是个静止的摆设，没有任何用处，Looper让MessageQueue动了起来，有了活力。</p>
<p>Looper是用来使线程中的消息循环起来的。默认情况下当我们创建一个新的线程的时候，这个线程里面是没有消息队列MessageQueue的。为了能够让线程能够绑定一个消息队列，我们需要借助于Looper：首先我们要调用Looper的prepare方法，然后调用Looper的Loop方法。典型的代码如下所示：</p>
</blockquote>
<pre><code>class LooperThread extends Thread {
      public Handler mHandler;

      public void run() {
          Looper.prepare();

          mHandler = new Handler() {
              public void handleMessage(Message msg) {
                  // process incoming messages here
              }
          };

          Looper.loop();
      }
  }
</code></pre><blockquote>
<p>需要注意的是Looper.prepare()和Looper.loop()都是在新线程的run方法内调用的，这两个方法都是静态方法。我们通过查看Looper的源码可以发现，Looper的构造函数是private的，也就是在该类的外部不能用new Looper()的形式得到一个Looper对象。根据我们上面的描述，我们知道<strong><em>线程Thread和Looper是一对一绑定的</em></strong>，也就是一个线程中最多只有一个Looper对象，这也就能解释Looper的构造函数为什么是private的了，我们只能通过工厂方法Looper.myLooper()这个静态方法获取当前线程所绑定的Looper。</p>
<p>Looper通过如下代码保存了对当前线程的引用：</p>
</blockquote>
<pre><code>static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();
</code></pre><blockquote>
<p>在Looper对象中通过sThreadLocal就可以找到其绑定的线程。ThreadLocal中有个set方法和get方法，可以通过set方法向ThreadLocal中存入一个对象，然后可以通过get方法取出存入的对象。ThreadLocal在new的时候使用了泛型，从上面的代码中我们可以看到此处的泛型类型是Looper，也就是我们通过ThreadLocal的set和get方法只能写入和读取Looper对象类型，如果我们调用其ThreadLocal的set方法传入一个Looper，将该Looper绑定给了该线程，相应的get就能获得该线程所绑定的Looper对象。</p>
<p>我们再来看一下Looper.prepare()，该方法是让Looper做好准备，只有Looper准备好了之后才能调用Looper.loop()方法，Looper.prepare()的代码如下:</p>
</blockquote>
<pre><code>private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper(quitAllowed));
}
</code></pre><blockquote>
<p>上面的代码首先通过sThreadLocal.get()拿到线程sThreadLocal所绑定的Looper对象，由于初始情况下sThreadLocal并没有绑定Looper，所以第一次调用prepare方法时，sThreadLocal.get()返回null，不会抛出异常。重点是下面的代码sThreadLocal.set(new Looper(quitAllowed))，首先通过私有的构造函数创建了一个Looper对象的实例，然后通过sThreadLocal的set方法将该Looper绑定到sThreadLocal中。 </p>
<p>这样就完成了线程sThreadLocal与Looper的<strong><em>双向绑定</em></strong>： </p>
</blockquote>
<ul>
<li>在Looper内通过sThreadLocal可以获取Looper所绑定的线程</li>
<li>线程sThreadLocal通过sThreadLocal.get()方法可以获取该线程所绑定的Looper对象</li>
</ul>
<blockquote>
<p>上面的代码执行了Looper的构造函数，我们看一下其代码：</p>
</blockquote>
<pre><code>private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
}
</code></pre><blockquote>
<p>我们可以看到在其构造函数中<strong><em>实例化一个消息队列MessageQueue</em></strong>，并将其赋值给其成员字段<strong><em>mQueue</em></strong>,这样<strong><em>Looper也就与MessageQueue通过成员字段mQueue进行了关联</em></strong>。</p>
<p>在执行完了Looper.prepare()之后，我们就可以在外部通过调用Looper.myLooper()获取当前线程绑定的Looper对象。 </p>
<p>myLooper的代码如下所示：</p>
</blockquote>
<pre><code>public static Looper myLooper() {
        return sThreadLocal.get();
}
</code></pre><blockquote>
<p>需要注意的是，在一个线程中，只能调用一次Looper.prepare()，因为在第一次调用了Looper.prepare()之后，当前线程就已经绑定了Looper，在该线程内第二次调用Looper.prepare()方法的时候，sThreadLocal.get()会返回第一次调用prepare的时候绑定的Looper，不是null，这样就会走的下面的代码</p>
</blockquote>
<pre><code>throw new RuntimeException(“Only one Looper may be created per thread”)，
</code></pre><blockquote>
<p>从而抛出异常，告诉开发者一个线程只能绑定一个Looper对象。</p>
<p>在调用了Looper.prepare()方法之后，当前线程和Looper就进行了双向的绑定，这时候我们就可以调用<strong><em>Looper.loop()</em></strong>方法让消息队列循环起来了。<br>需要注意的是<strong><em>Looper.loop()应该在该Looper所绑定的线程中执行</em></strong>。</p>
<p>Looper.loop()的代码如下:</p>
</blockquote>
<pre><code>public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
        }
        //注意下面这行
        final MessageQueue queue = me.mQueue;

        // Make sure the identity of this thread is that of the local process,
        // and keep track of what that identity token actually is.
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();

        //注意下面这行
        for (;;) {
            //注意下面这行
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

            // This must be in a local variable, in case a UI event sets the logger
            Printer logging = me.mLogging;
            if (logging != null) {
                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                        msg.callback + &quot;: &quot; + msg.what);
            }

            //注意下面这行
            msg.target.dispatchMessage(msg);

            if (logging != null) {
                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
            }

            // Make sure that during the course of dispatching the
            // identity of the thread wasn&apos;t corrupted.
            final long newIdent = Binder.clearCallingIdentity();
            if (ident != newIdent) {
                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;
                        + Long.toHexString(ident) + &quot; to 0x&quot;
                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                        + msg.target.getClass().getName() + &quot; &quot;
                        + msg.callback + &quot; what=&quot; + msg.what);
            }

            msg.recycleUnchecked();
        }
}
</code></pre><blockquote>
<p>上面有几行代码是关键代码: </p>
</blockquote>
<pre><code>final Looper me = myLooper(); 
final MessageQueue queue = me.mQueue; 
</code></pre><blockquote>
<p>变量me是通过静态方法myLooper()获得的当前线程所绑定的Looper，me.mQueue是当前线程所关联的消息队列。 </p>
</blockquote>
<pre><code>for (;;) 
</code></pre><blockquote>
<p>我们发现for循环没有设置循环终止的条件，所以这个for循环是个死循环。 </p>
</blockquote>
<pre><code>Message msg = queue.next(); // might block 
</code></pre><blockquote>
<p>我们通过消息队列MessageQueue的next方法从消息队列中取出一条消息，如果此时消息队列中有Message，那么next方法会立即返回该Message，如果此时消息队列中没有Message，那么next方法就会<strong><em>阻塞式</em></strong>地等待获取Message。 </p>
</blockquote>
<pre><code>msg.target.dispatchMessage(msg); 
</code></pre><blockquote>
<p><strong><em>msg的target属性是Handler</em></strong>，该代码的意思是让Message所关联的Handler通过dispatchMessage方法让Handler处理该Message，关于Handler的dispatchMessage方法将会在下面详细介绍。</p>
</blockquote>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><blockquote>
<p>Handler是暴露给开发者最顶层的一个类，其构建在Thread、Looper与MessageQueue之上。 </p>
</blockquote>
<p><strong>Handler具有多个构造函数，如下所示： </strong></p>
<pre><code>//第1个
public Handler() {
        this(null, false);
}
//第2个
public Handler(Callback callback) {
        this(callback, false);
}
//第3个 
public Handler(boolean async) {
         this(null, async);
}
//第4个 
public Handler(Callback callback, boolean async) {
        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
}
//第5个
public Handler(Looper looper) {
        this(looper, null, false);
}
//第6个  
public Handler(Looper looper, Callback callback) {
        this(looper, callback, false);
}
//第7个 
public Handler(Looper looper, Callback callback, boolean async) {
        mLooper = looper;
        mQueue = looper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
}
</code></pre><blockquote>
<p>第1-3个构造函数都没有传递Looper，这三个构造函数最终会调用第4个构造函数，在构造函数内调用Looper.myLooper()获取当前线程绑定的Looper对象，然后将该Looper对象保存到名为mLooper的成员字段中。</p>
<p>第5个和第6个构造函数传递了Looper对象，最终会去调用第7个构造函数，这两个构造函数会直接将传入的Looper保存到名为mLooper的成员字段中。 </p>
<p>第4个和第7个构造函数都还有一个Callback对象，Callback是Handler中的内部接口，需要实现其内部的handleMessage方法，Callback代码如下:</p>
</blockquote>
<pre><code>public interface Callback {
        public boolean handleMessage(Message msg);
}
</code></pre><blockquote>
<p>Handler.Callback是用来处理Message的一种手段，如果没有传递该参数，那么就应该重写Handler的handleMessage方法，也就是说为了使得Handler能够处理Message，我们有两种办法： </p>
</blockquote>
<ul>
<li>向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法 </li>
<li>无需向Handler的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法 </li>
</ul>
<blockquote>
<p>在Java中，如果我们想使用多线程，有两种办法： </p>
</blockquote>
<ul>
<li>向Thread的构造函数传入一个<strong><em>Runnable对象</em></strong>，并<strong><em>实现Runnable的run方法 </em></strong></li>
<li>无需向Thread的构造函数传入Runnable对象，但是要重写Thread本身的run方法 </li>
</ul>
<blockquote>
<p>所以只要用过多线程Thread，应该就对Hanlder这种需要实现handleMessage的两种方式了然于心了。</p>
</blockquote>
<ul>
<li><strong> sendMessage系列</strong></li>
</ul>
<blockquote>
<p>我们知道通过sendMessageXXX系列方法可以向消息队列中添加消息，我们通过源码可以看出这些方法的调用顺序，<br>sendMessage调用了sendMessageDelayed，sendMessageDelayed又调用了sendMessageAtTime。<br>Handler中还有一系列的sendEmptyMessageXXX方法，而这些sendEmptyMessageXXX方法在其内部又分别调用了其对应的sendMessageXXX方法。</p>
</blockquote>
<p><strong>源码如下</strong></p>
<pre><code>public final boolean sendMessage(Message msg) {
        return sendMessageDelayed(msg, 0);
}
public final boolean sendMessageDelayed(Message msg, long delayMillis) {
        if (delayMillis &lt; 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}
public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);
}

public final boolean sendEmptyMessage(int what) {
        return sendEmptyMessageDelayed(what, 0);
}
public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {
        Message msg = Message.obtain();
        msg.what = what;
        return sendMessageDelayed(msg, delayMillis);
}
public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) {
        Message msg = Message.obtain();
        msg.what = what;
        return sendMessageAtTime(msg, uptimeMillis);
}
</code></pre><blockquote>
<p>由此可见所有的sendMessageXXX方法和sendEmptyMessageXXX最终都调用了<strong><em>sendMessageAtTime</em></strong>方法</p>
<p>关系如下图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/Handler-sendMsg.png" alt=""></p>
<ul>
<li><strong>post系列</strong></li>
</ul>
<blockquote>
<p>再来看看postXXX方法，会发现postXXX方法在其内部又调用了对应的sendMessageXXX方法，源码如下：</p>
</blockquote>
<pre><code>public final boolean post(Runnable r) {
       return  sendMessageDelayed(getPostMessage(r), 0);
}
public final boolean postAtTime(Runnable r, long uptimeMillis) {
        return sendMessageAtTime(getPostMessage(r), uptimeMillis);
}
public final boolean postAtTime(Runnable r, Object token, long uptimeMillis) {
        return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);
}
public final boolean postDelayed(Runnable r, long delayMillis) {
        return sendMessageDelayed(getPostMessage(r), delayMillis);
}
</code></pre><blockquote>
<p>可以看到内部调用了getPostMessage方法，该方法传入一个Runnable对象，得到一个Message对象，getPostMessage的源码如下:</p>
</blockquote>
<pre><code>private static Message getPostMessage(Runnable r) {
        Message m = Message.obtain();
        m.callback = r;
        return m;
}
private static Message getPostMessage(Runnable r, Object token) {
        Message m = Message.obtain();
        m.obj = token;
        m.callback = r;
        return m;
}
</code></pre><blockquote>
<p>通过上面的代码我们可以看到在getPostMessage方法中，我们创建了一个Message对象，并将传入的Runnable对象赋值给Message的<strong><em>callback成员</em></strong>字段，然后返回该Message，然后在post方法中该携带有Runnable信息的Message传入到sendMessageDelayed方法中。由此我们可以看到所有的postXXX方法内部都需要借助<strong><em>sendMessageXXX方法</em></strong>来实现，所以postXXX与sendMessageXXX并不是对立关系，而是postXXX依赖sendMessageXXX，所以postXXX方法可以通过sendMessageXXX方法向消息队列中传入消息，只不过通过<strong><em>postXXX方法向消息队列中传入的消息都携带有Runnable对象（Message.callback）</em></strong>。</p>
<p>通过以下调用关系图我们可以看的更清楚些: </p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/Handler-post&amp;send.png" alt=""></p>
<blockquote>
<p>通过分别分析sendEmptyMessageXXX、postXXX方法与sendMessageXXX方法之间的关系，我们可以看到在Handler中所有可以直接或间接向消息队列发送Message的方法最终都调用了<strong><em>sendMessageAtTime</em></strong>方法，源码如下：</p>
</blockquote>
<pre><code>public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        //注意下面这行代码
        return enqueueMessage(queue, msg, uptimeMillis);
}
</code></pre><blockquote>
<p>该方法内部调用了enqueueMessage方法，该方法的源码如下：</p>
</blockquote>
<pre><code>private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        //注意下面这行代码
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        //注意下面这行代码
        return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre><p><strong>在该方法中有两件事需要注意： </strong></p>
<ul>
<li>msg.target = this</li>
</ul>
<blockquote>
<p>该代码将Message的target绑定为当前的Handler （Handler把Message发送出去的同时，又把自己作为Message的一个成员变量）</p>
</blockquote>
<ul>
<li>queue.enqueueMessage</li>
</ul>
<blockquote>
<p>变量queue表示的是Handler所绑定的消息队列MessageQueue，通过调用queue.enqueueMessage(msg, uptimeMillis)我们将Message放入到消息队列中。</p>
</blockquote>
<p>所以我们通过下图可以看到完整的方法调用顺序： </p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/Handler-Message.png" alt=""></p>
<blockquote>
<p>前面在分析Looper.loop()的源码时发现，Looper一直在不断的从消息队列中通过MessageQueue的next方法获取Message，然后通过代码msg.target.dispatchMessage(msg)让该msg所绑定的Handler（Message.target）执行dispatchMessage方法以实现对Message的处理。 </p>
<p>Handler的dispatchMessage的源码如下：</p>
</blockquote>
<pre><code>public void dispatchMessage(Message msg) {
        //注意下面这行代码
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
             //注意下面这行代码
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
             //注意下面这行代码
            handleMessage(msg);
        }
}
</code></pre><ul>
<li><strong>msg.callback</strong></li>
</ul>
<blockquote>
<p>首先会判断msg.callback存不存在，<strong><em>msg.callback是Runnable类型</em></strong>，如果msg.callback存在，那么说明该Message是通过执行Handler的postXXX系列方法将Message放入到消息队列中的，这种情况下会执行handleCallback(msg), handleCallback源码如下：</p>
</blockquote>
<pre><code>private static void handleCallback(Message message) {
        message.callback.run();
}
</code></pre><blockquote>
<p>这样我们我们就清楚地看到我们执行了msg.callback的run方法，也就是执行了postXXX所传递的Runnable对象的run方法。</p>
</blockquote>
<ul>
<li><strong>Handler.Callback</strong></li>
</ul>
<blockquote>
<p>如果我们不是通过postXXX系列方法将Message放入到消息队列中的，那么msg.callback就是null，代码继续往下执行，接着我们会<strong><em>判断Handler的成员字段mCallback存不存在</em></strong>。mCallback是Handler.Callback类型的，我们在上面提到过，在Handler的构造函数中我们可以传递Handler.Callback类型的对象，该对象需要实现handleMessage方法，如果我们在构造函数中传递了该<strong><em>Callback对象</em></strong>，那么我们就会让Callback的handleMessage方法来处理Message。</p>
</blockquote>
<ul>
<li><strong>Handler自身实现的handleMessage方法</strong></li>
</ul>
<blockquote>
<p>如果我们在构造函数中没有传入Callback类型的对象，那么mCallback就为null,那么我们会调用Handler自身的hanldeMessage方法，该方法默认是个空方法，我们需要自己是重写实现该方法。</p>
</blockquote>
<p><strong>综述</strong></p>
<blockquote>
<p>Handler提供了三种途径处理Message，而且处理有前后优先级之分：首先尝试让postXXX中传递的Runnable执行，其次尝试让Handler构造函数中传入的Callback的handleMessage方法处理，最后才是让Handler自身的handleMessage方法处理Message。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>我们在本文讨论了Thread、MessageQueue、Looper以及Hanlder的之间的关系，我们可以通过如下一张传送带的图来更形象的理解他们之间的关系</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20150801014511416" alt=""></p>
<blockquote>
<p>在现实生活的生产生活中，存在着各种各样的传送带，传送带上面洒满了各种货物，传送带在发动机滚轮的带动下一直在向前滚动，不断有新的货物放置在传送带的一端，货物在传送带的带动下送到另一端进行收集处理。</p>
<p>我们可以把传送带上的货物看做是一个个的Message，而承载这些货物的传送带就是装载Message的消息队列MessageQueue。传送带是靠发送机滚轮带动起来转动的，我们可以把发送机滚轮看做是Looper，而发动机的转动是需要电源的，我们可以把电源看做是线程Thread，所有的消息循环的一切操作都是基于某个线程的。一切准备就绪，我们只需要按下电源开关发动机就会转动起来，这个开关就是Looper的loop方法，当我们按下开关的时候，我们就相当于执行了Looper的loop方法，此时Looper就会驱动着消息队列循环起来。</p>
<p>那Hanlder在传送带模型中相当于什么呢？我们可以将Handler看做是放入货物以及取走货物的管道：货物从一端顺着管道划入传送带，货物又从另一端顺着管道划出传送带。我们在传送带的一端放入货物的操作就相当于我们调用了Handler的sendMessageXXX、sendEmptyMessageXXX或postXXX方法，这就把Message对象放入到了消息队列MessageQueue中了。当货物从传送带的另一端顺着管道划出时，我们就相当于调用了Hanlder的dispatchMessage方法，在该方法中我们完成对Message的处理。</p>
</blockquote>
<p><strong>参考资料</strong><br>孙群<br><a href="http://blog.csdn.net/iispring/article/details/47115879" target="_blank" rel="external">http://blog.csdn.net/iispring/article/details/47115879</a><br><a href="http://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="external">http://blog.csdn.net/iispring/article/details/47180325</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;入门使用篇&quot;&gt;&lt;a href=&quot;#入门使用篇&quot; class=&quot;headerlink&quot; title=&quot;入门使用篇&quot;&gt;&lt;/a&gt;入门使用篇&lt;/h2&gt;&lt;h3 id=&quot;错误范例&quot;&gt;&lt;a href=&quot;#错误范例&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Handler" scheme="http://yoursite.com/tags/Handler/"/>
    
      <category term="消息处理机制" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Android消息处理机制 — 原理分析(2)</title>
    <link href="http://yoursite.com/2016/10/04/Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%20%E2%80%94%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90(2)/"/>
    <id>http://yoursite.com/2016/10/04/Android消息处理机制 — 原理分析(2)/</id>
    <published>2016-10-04T07:11:40.000Z</published>
    <updated>2016-10-10T06:03:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>Android消息机制</strong></p>
<ul>
<li>Handler是Android消息机制的上层接口，开发者只需要和Handler交互即可；</li>
<li>Handler作用就是将一个任务切换到某个指定的线程中去执行；</li>
<li>更新UI就是Handler的一个特殊使用场景（子线程执行耗时任务，通过Handler切换到主线程更新UI），但其功能远不于此；</li>
<li>Handler的运行机制是Android消息机制的主要内容；</li>
<li>Handler的运行需要底层的MessageQueue和Looper的支撑；</li>
<li>MessageQueue是消息队列，其内部存储了一组消息（Message），以队列的形式对外提供插入和删除工作，虽说称它为消息队列，但其内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表；</li>
<li>Looper（循环）是消息循环者，MessageQueue只是一个消息的存储单元，它不能去处理消息，Looper填补了这个功能；</li>
<li>Looper以无限循环的方式去查看消息队列中是否有新消息，如果有就去处理，否则就一直等待着；</li>
<li>Looper中有一个特殊的概念ThreadLocal，它不是线程，作用是可以在每个线程中存储数据。Handler创建的时候会采用当前线程的Looper来构造消息循环系统，此时就是通过ThreadLocal来获得当前线程的Looper；</li>
<li>ThreadLocal可以在不同的线程中互不干扰地存储并提供数据，通过ThreadLocal可以轻松地获得每个线程的Looper；</li>
<li>线程默认是没有Looper的，如果需要使用Handler就必须为线程创建Looper。在主线程就是ActivityThread，其被创建时就会初始化Looper，这就是主线程中默认可以使用Handler的原因。</li>
</ul>
<h3 id="消息机制分析"><a href="#消息机制分析" class="headerlink" title="消息机制分析"></a>消息机制分析</h3><blockquote>
<p>前面一节已经对Android的消息机制做了一个概述，大致分析了Handler的工作过程，本节将从实现原理的角度，再次深入分析Android的消息机制。</p>
</blockquote>
<h4 id="ThreadLocal的工作原理"><a href="#ThreadLocal的工作原理" class="headerlink" title="ThreadLocal的工作原理"></a>ThreadLocal的工作原理</h4><blockquote>
<p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<p>ThreadLocal使用的场景并不多，但在某些特殊场景下，使用ThreadLocal可以轻松实现一些看似复杂的功能，这一点在Android源码中有所体现，如：Looper，ActivityThread以及AMS中都用到了ThreadLocal。</p>
<p>具体到ThreadLocal使用场景，不好统一来讲，一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。</p>
<p>对于Handler来说，它需要获取到当前线程的Looper，很显然Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松实现Looper在线程中的获取。如果不采用ThreadLocal，那么系统就必须提供一个全局的哈希表供Handler查找指定线程的Looper，这样一来就必须提供一个类似于LooperManager的类了，但是系统并没有这么做而是选择了ThreadLocal，这也体现了ThreadLocal的好处。</p>
<p>ThreadLocal另一个使用场景就是复杂逻辑下的对象传递，比如监听器的传递，有时候一个线程中的任务过于复杂，这可能表现为函数的调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢？其实采用ThreadLocal 可以让监听器作为线程内的全局对象而存在，在线程内部只要通过get方法就可以获取到监听器。如果不采用ThreadLocal，那么我们能想到的两种方法：</p>
</blockquote>
<ul>
<li>将监听器通过参数的形式在函数调用栈中进行传递。但当函数调用栈很深时，通过函数参数来传递监听器对象是不可接受的。</li>
<li>将监听器作为静态变量供线程访问，但其不具有可扩充性，10个线程同时并发执行，就需要10个静态的监听器对象，而采用ThreadLocal，每个监听器对象都在自己的线程内部存储，不会存在这个问题。</li>
</ul>
<p><strong>举个例子</strong></p>
<blockquote>
<p>首先定义一个ThreadLocal对象，这里选择Boolean类型，如下：</p>
</blockquote>
<pre><code>private ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = new ThreadLocal&lt;Boolean&gt;();
</code></pre><blockquote>
<p>然后分别在主线程，子线程1和子线程2中设置和访问它的值，如下：</p>
</blockquote>
<pre><code>mBooleanThreadLocal.set(true);
Log.d(&quot;Science&quot;, &quot;[Thread#main] mBooleanThreadLocal = : &quot; + mBooleanThreadLocal.get());

new Thread(&quot;Thread#1&quot;) {
    @Override
         public void run() {
                mBooleanThreadLocal.set(false);
                Log.d(&quot;Science&quot;, &quot;[Thread#1] mBooleanThreadLocal = : &quot; + mBooleanThreadLocal.get());
          }
}.start();

new Thread(&quot;Thread#2&quot;) {
        @Override
        public void run() {
                Log.d(&quot;Science&quot;, &quot;[Thread#2] mBooleanThreadLocal = : &quot; + mBooleanThreadLocal.get());
        }
}.start();
</code></pre><blockquote>
<p>主线程中设置mBooleanThreadLocal的值为true<br>线程1中设置mBooleanThreadLocal的值为false<br>线程2中不设置mBooleanThreadLocal值<br>然后分别在3个线程中通过get方法获取mBooleanThreadLocal的值</p>
<p>运行结果如下：</p>
</blockquote>
<pre><code>D/Science: [Thread#main] mBooleanThreadLocal = : true
D/Science: [Thread#1] mBooleanThreadLocal = : false
D/Science: [Thread#2] mBooleanThreadLocal = : null
</code></pre><blockquote>
<p>分析日志，可以看到，在不同的线程中访问的是同一个ThreadLocal对象，但是他们通过ThreadLocal获取到的值却不一样，这就是ThreadLocal的奇妙之处。</p>
<p>ThreadLocal之所以有这么奇妙的效果，是因为不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值。很显然，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同的线程中维护一套数据的副本并且彼此互不干扰。</p>
</blockquote>
<p><strong>下面看看ThreadLocal的内部具体实现</strong></p>
<blockquote>
<p>ThreadLocal是一个范型类，它的声明如下：</p>
</blockquote>
<pre><code>public class ThreadLocal&lt;T&gt;;
</code></pre><blockquote>
<p>从上面ThreadLocal的工作流程可以知道，要搞明白ThreadLocal，必须弄明白其内部的get和set方法</p>
</blockquote>
<ul>
<li><p>set方法</p>
<pre><code>/\*\*
   * Sets the value of this variable for the current thread. If set to
   * {@code null}, the value will be set to null and the underlying entry will
   * still be present.
   *
   * @param value the new value of the variable for the caller thread.
   */
  public void set(T value) {
      Thread currentThread = Thread.currentThread();
      Values values = values(currentThread);
      if (values == null) {
          values = initializeValues(currentThread);
      }
      values.put(this, value);
  }
</code></pre></li>
</ul>
<blockquote>
<p>首先，通过values方法来获取当前线程中的ThreadLocal数据Values。获取过程如下：在Thread类的内部有一个成员专门用于存储线程的ThreadLocal数据（ThreadLocal.Values  localValues），因此获取当前线程的ThreadLocal数据就很简单。如果localValues为null，就需要对其进行初始化，初始化后再将ThreadLocal的值进行存储。</p>
<p>下面看下ThreadLocal的值到底是如何在localValues中进行存储的，在localValues内部有一个数组：private Object[] table，ThreadLocal的值就存在这个table数组中。</p>
<p>下面看下localValues是如何使用put方法将ThreadLocal的值存储到table数组中的，如下：</p>
</blockquote>
<pre><code>/**
 * Sets entry for given ThreadLocal to given value, creating an
 * entry if necessary.
 */
 void put(ThreadLocal&lt;?&gt; key, Object value) {
       cleanUp();

       // Keep track of first tombstone. That&apos;s where we want to go back
       // and add an entry if necessary.
       int firstTombstone = -1;

       for (int index = key.hash &amp; mask;; index = next(index)) {
             Object k = table[index];

             if (k == key.reference) {
                    // Replace existing entry.
                    table[index + 1] = value;
                    return;
             }

             if (k == null) {
                    if (firstTombstone == -1) {
                        // Fill in null slot.
                        table[index] = key.reference;
                        table[index + 1] = value;
                        size++;
                        return;
                    }

                    // Go back and replace first tombstone.
                    table[firstTombstone] = key.reference;
                    table[firstTombstone + 1] = value;
                    tombstones--;
                    size++;
                    return;
             }

             // Remember first tombstone.
             if (firstTombstone == -1 &amp;&amp; k == TOMBSTONE) {
                    firstTombstone = index;
             }
        }
}
</code></pre><blockquote>
<p>上面的代码实现了数据的存储，这个不分析具体算法，但我们可以得出一个存储规则：</p>
</blockquote>
<p><strong>ThreadLocal的值在table数组中的存储位置总是为ThreadLocal的reference字段所标识的对象的下一个位置</strong></p>
<blockquote>
<p>比如ThreadLocal的reference对象table数组中的索引为index，那么ThreadLocal的值在table数组中的索引就是index+1。最终，ThreadLocal的值将会被存储在table数组中：table[index+1] = value.</p>
</blockquote>
<ul>
<li><p>get方法</p>
<pre><code>/\*\*
   * Returns the value of this variable for the current thread. If an entry
   * doesn&apos;t yet exist for this variable on this thread, this method will
   * create an entry, populating the value with the result of
   * {@link #initialValue()}.
   *
   * @return the current value of the variable for the calling thread.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public T get() {
      // Optimized for the fast path.
      Thread currentThread = Thread.currentThread();
      Values values = values(currentThread);
      if (values != null) {
          Object[] table = values.table;
          int index = hash &amp; values.mask;
          if (this.reference == table[index]) {
              return (T) table[index + 1];
          }
      } else {
          values = initializeValues(currentThread);
      }

      return (T) values.getAfterMiss(this);
  }
</code></pre></li>
</ul>
<blockquote>
<p>同样是先取出当前线程的localValues对象，如果为null就返回初始值，初始值由ThreadLocal的initialValue方法描述，默认情况下为null，也可重写此方法。</p>
</blockquote>
<pre><code>/**
   * Provides the initial value of this variable for the current thread.
   * The default implementation returns {@code null}.
   *
   * @return the initial value of the variable.
   */
  protected T initialValue() {
      return null;
  }
</code></pre><blockquote>
<p>如果localValues对象不为null，那就取出它的table数组并找到ThreadLocal的reference对象在table数组中的位置，然后table数组中取下一个位置的数据就是ThreadLocal的值。</p>
<p>总结：从set和get方法可以看出，它们所操作的对象都是当前线程的localValues对象的table数组，因此在不同线程中访问同一个ThreadLocal的set和get方法，它们对ThreadLocal所做的读写操作都仅限于各自线程的内部，这就是为什么ThreadLocal可以在多个线程中互不干扰的存储和修改数据，理解ThreadLocal的实现方式有助于理解Looper的工作原理。</p>
</blockquote>
<h4 id="消息队列的工作原理"><a href="#消息队列的工作原理" class="headerlink" title="消息队列的工作原理"></a>消息队列的工作原理</h4><blockquote>
<p>MessageQueue （维护一个消息列表）主要包含两个操作：</p>
</blockquote>
<ul>
<li>插入</li>
</ul>
<blockquote>
<p>enqueueMessage：向MessageQueue中插入一条消息，底层实现就是单链表的插入操作。</p>
</blockquote>
<ul>
<li>读取(会伴随删除操作)</li>
</ul>
<blockquote>
<p>next：是一个无限循环的方法，如果MessageQueue中没有消息，该方法就会一直阻塞在这里；当有新消息到来时，就从MessageQueue中取出消息并将其从MessageQueue中删除。</p>
</blockquote>
<p><strong>MessageQueue内部实现不是队列，而是单链表（在插入和删除上有优势）</strong></p>
<h4 id="Looper的工作原理"><a href="#Looper的工作原理" class="headerlink" title="Looper的工作原理"></a>Looper的工作原理</h4><blockquote>
<p>Looper在Android的消息机制中扮演着消息循环的角色，它会不停的从MessageQueue中查看是否有新消息，有的话就立即处理，否则也会一直阻塞在那里。</p>
<p>首先，其在构造方法中创建一个MessageQueue，然后，将当前线程的对象保存起来，如下：</p>
</blockquote>
<pre><code>private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
}
</code></pre><blockquote>
<p>Handler的工作需要Looper，没有Looper的线程就会报错，那如何为一个线程创建Looper呢？</p>
<p>Looper.prepare() 为当前线程创建一个Looper，Looper.loop()来开启消息循环，如下：</p>
</blockquote>
<pre><code>new Thread(&quot;Thread#2&quot;) {
        @Override
        public void run() {
            Looper.prepare();
            Handler handler = new Handler();
            Looper.loop();
        }
}.start();
</code></pre><blockquote>
<p>Looper除了prepare方法外，还提供了prepareMainLooper方法，其主要作用是给主线程也就是ActivityThread创建Looper时使用的，本质上也是通过prepare方法来实现的。主线程的Looper比较特殊，Looper提供了一个get MainLooper方法，其可以在任何地方获取主线程的Looper。</p>
<p>Looper也是可以退出的，Looper提供quit和quitSafely来退出一个Looper，二者区别是：quit会直接退出Looper，而quitSafely只是设定一个退出标识，然后等到MessageQueue中已有的消息处理完毕后才安全退出。</p>
<p>Looper退出后，通过Handler发送的消息会失败，这个时候Handler的send方法会返回false。</p>
<p>在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待状态，而如果退出Looper以后，这个线程就会立刻终止，所以建议不需要的时候终止Looper。</p>
<p>Looper一个重要的方法是loop，只有调用了loop后，消息循环系统才会真正地起作用。loop方法是一个死循环，唯一跳出循环的方式就是MessageQueue的next方法返回了null。</p>
<p>当Looper的quit方法被调用时，Looper就会调用MessageQueue的quit或quitSafely方法来通知MessageQueue退出，当MessageQueue被标记为退出状态时，它的next方法就会返回null。也就是说Looper必须退出，否则loop方法就会无限循环下去。loop方法会调用MessageQueue的next方法来获取新消息，而next是一个阻塞操作，当没有消息时，next方法会一直阻塞在那里，也就导致loop方法一直阻塞在那里。如果MessageQueue的next方法返回了新消息，Looper就会处理这条消息：msg.target.dispatchMessage(msg), 这里的msg.target是发送这条消息的Handler对象，这样Handler发送的消息最终又交给它的dispatchMessage方法来处理了。但这里不同的是，Handler的dispatchMessage方法是在创建Handler时所使用的Looper中执行的，这样就成功的将代码逻辑切换到指定的线程中去执行了。</p>
</blockquote>
<h4 id="Handler的工作原理"><a href="#Handler的工作原理" class="headerlink" title="Handler的工作原理"></a>Handler的工作原理</h4><p><strong>Handler的工作主要包括：</strong></p>
<ul>
<li>消息的发送</li>
<li>消息的接收</li>
</ul>
<blockquote>
<p>通过post的一系列方法以及send的一系列方法来实现，post的一系列方法最终是通过send的一系列方法来实现的。</p>
</blockquote>
<pre><code>public final boolean sendMessage(Message msg) {
        return sendMessageDelayed(msg, 0);
}
public final boolean sendMessage(Message msg, long delayMillis) {
        if (delayMillis &lt; 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg,SystemClock.uptimeMillis() + delayMillis);
}
public final boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeExeception e = new RuntimeExeception(this + &quot; sendMessageAtTime() called with no mQueue&quot;)
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis)
}
private final boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre><blockquote>
<p>Handler发送消息的过程仅仅是向MessageQueue中插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由Looper交由Handler处理，即Handler的dispatchMessage方法会被调用，这时Handler就进入了处理消息的阶段。</p>
<p>dispatchMessage的实现如下所示：</p>
</blockquote>
<pre><code>public void dispatchMessage(Message message) {
        if (msg.callback != null) {
            handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}
</code></pre><blockquote>
<p>Handler处理消息的过程：</p>
</blockquote>
<ol>
<li><p>首先，检查Message的callback是否为空，不为null就通过handleCallback来处理消息。Message的callback是一个Runnable对象，实际上就是Handler的post方法所传递的Runnable参数。handleCallback的逻辑如下：</p>
<p> private static void handleCallback(Message msg) {</p>
<pre><code>msg.callback.run();
</code></pre><p> }</p>
</li>
<li><p>然后检查mCallback是否为null，不为null就调用mCallback的handleMessage方法处理消息。Callback是个接口，定义如下：</p>
<p> /**</p>
<ul>
<li>Callback interface you can use when instantiating a Handler to avoid having   to implement your own subclass of Handler.<br>* </li>
<li>@param msg A {@link android.os.Message Message} object</li>
<li>@return True if no further handling is desired<br>*/<br>public interface Callback {<br>  public boolean handleMessage(Message msg);<br>}</li>
</ul>
</li>
</ol>
<blockquote>
<p>通过Callback可以采用如下方式来创建Handler对象：Handler handler = new Handler(callback).</p>
<p>Callback存在的意义就是用来创建一个Handler的实例但并不需要派生Handler的子类。在日常开发中，创建Handler最常见的方式就是派生一个Handler的子类并重写其handleMessage方法来处理具体的消息，而Callback给我们提供了另外一种使用Handler的方式，当我们不想派生子类时，就可以通过Callback来实现。</p>
</blockquote>
<ol>
<li>最后，调用Handler的handleMessage方法来处理消息</li>
</ol>
<p><strong>Handler处理消息的过程可以用一个流程图来表示</strong>*<br><img src="http://o9zgq2ik9.bkt.clouddn.com/Handler%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt=""></p>
<blockquote>
<p>Handler还有一个特殊的构造方法，那就是通过一个特定的Looper来构造Handler，它的实现如下，通过此构造方法可以实现一些特殊的功能。</p>
</blockquote>
<pre><code>public Handler(Looper looper) {
        this(looper,null,false);
}
</code></pre><blockquote>
<p>Handler默认的构造方法为public Handler()，它会去调用下面的构造方法，很明显如果当前线程没有Looper的话，就会抛出“Can’t create handler inside thread that has not called Looper.prepare()” 这个异常，这也解释了在没有Looper的子线程中创建Handler会引发程序异常。</p>
</blockquote>
<pre><code>/**
   * Use the {@link Looper} for the current thread with the specified callback interface
   * and set whether the handler should be asynchronous.
   *
   * Handlers are synchronous by default unless this constructor is used to make
   * one that is strictly asynchronous.
   *
   * Asynchronous messages represent interrupts or events that do not require global ordering
   * with respect to synchronous messages.  Asynchronous messages are not subject to
   * the synchronization barriers introduced by {@link MessageQueue#enqueueSyncBarrier(long)}.
   *
   * @param callback The callback interface in which to handle messages, or null.
   * @param async If true, the handler calls {@link Message#setAsynchronous(boolean)} for
   * each {@link Message} that is sent to it or {@link Runnable} that is posted to it.
   *
   * @hide
   */
  public Handler(Callback callback, boolean async) {
      if (FIND_POTENTIAL_LEAKS) {
          final Class&lt;? extends Handler&gt; klass = getClass();
          if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                  (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
              Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                  klass.getCanonicalName());
          }
      }

      mLooper = Looper.myLooper();
      if (mLooper == null) {
          throw new RuntimeException(
              &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);
      }
      mQueue = mLooper.mQueue;
      mCallback = callback;
      mAsynchronous = async;
  }
</code></pre><h3 id="主线程的消息循环"><a href="#主线程的消息循环" class="headerlink" title="主线程的消息循环"></a>主线程的消息循环</h3><blockquote>
<p>Android的主线程就是ActivityThread，主线程的入口方法为main，在main方法中系统会通过Looper.prepareMainLooper()方法来创建主线程的Looper以及MessageQueue，并通过Looper.loop()来开启主线程的消息循环，过程如下：</p>
</blockquote>
<pre><code>public static void main(String[] args) {
        ...
        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);

    Looper.prepareMainLooper();

    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    AsyncTask.init();

    if (false) {
        Looper.myLooper().setMessageLogging(new LogPrinter(Log,DEBUG, &quot;ActivityThread&quot;))
    }
    Looper.loop();

    throw new RuntimeExeception(&quot;Main thread loop unexpectedly exited&quot;);
}
</code></pre><blockquote>
<p>主线程的消息循环开始后，ActivityThread需要一个Handler和MessageQueue进行交互，这个Handler就是ActivityThread.H，它内部定义了一组消息类型，主要包括了四大组件的启动和停止等过程，如下：</p>
</blockquote>
<pre><code>private class H extends Handler {
        public static final int LAUNCH_ACTIVITY = 100;
        public static final int PAUSE_ACTIVITY = 101;
        public static final int PAUSE_ACTIVITY_FINSHING = 102;
        public static final int STOP_ACTIVITY_SHOW = 103;
    public static final int STOP_ACTIVITY_HIDE = 104;
    public static final int SHOW_WINDOW = 105;
    public static final int HIDE_WINDOW = 106;
    public static final int RESUME_ACTIVITY = 107;
    public static final int SEND_RESULT = 108;
    public static final int DESTROY_ACTIVITY = 109;
    public static final int BIND_APPLICATION = 110;
    public static final int EXIT_APPLICATION = 111;
    public static final int NEW_INTENT = 112;
    public static final int RECEIVER = 113;
    public static final int CREATE_SERVICE = 114;
    public static final int SERVICE_ARGS = 115;
    public static final int STOP_SERVICE = 116;

    ......
}
</code></pre><blockquote>
<p>ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。</p>
</blockquote>
<p><strong>参考资料</strong><br>《Android开发艺术探索》 —  任玉刚</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Android消息机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Handler是Android消息机制的上层接口，开发者
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Handler" scheme="http://yoursite.com/tags/Handler/"/>
    
      <category term="消息处理机制" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java中的ThreadLocal</title>
    <link href="http://yoursite.com/2016/10/04/Java%E4%B8%AD%E7%9A%84ThreadLocal/"/>
    <id>http://yoursite.com/2016/10/04/Java中的ThreadLocal/</id>
    <published>2016-10-04T02:17:24.000Z</published>
    <updated>2016-10-10T06:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>JDK 1.2开始提供Java.lang.ThreadLocal类，为解决多线程并发访问问题提供了一种新思路，使用这个工具类可以很简洁地编写出优美的多线程程序。<br>　　<br>用ThreadLocal维护变量，可以为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的变量副本，而不会影响其它线程所对应的变量副本。</p>
<p>从线程的角度看，目标变量就像是线程的本地变量，这也是类名中“Local”所要表达的意思。所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。</p>
</blockquote>
<p><strong>ThreadLocal的接口方法</strong></p>
<blockquote>
<p>ThreadLocal类接口很简单，只有4个方法：</p>
</blockquote>
<p>• void set(Object value) 设置当前线程的线程局部变量的值。<br>• public Object get() 该方法返回当前线程所对应的线程局部变量。<br>• public void remove() 将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。<br>• protected Object initialValue() 返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</p>
<blockquote>
<p>值得一提的是，在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal\<t\>。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。</t\></p>
<p>ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。</p>
</blockquote>
<p><strong>一个例子</strong></p>
<pre><code>public class TestNum {  
    // ①通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值  
    private static ThreadLocal&lt;Integer&gt; seqNum = new ThreadLocal&lt;Integer&gt;() {  
        public Integer initialValue() {  
            return 0;  
        }  
    };  
    // ②获取下一个序列值  
    public int getNextNum() {  
        seqNum.set(seqNum.get() + 1);  
        return seqNum.get();  
    }  
    public static void main(String[] args) {  
        TestNum sn = new TestNum();  
        // ③ 3个线程共享sn，各自产生序列号  
        TestClient t1 = new TestClient(sn);  
        TestClient t2 = new TestClient(sn);  
        TestClient t3 = new TestClient(sn);  
        t1.start();  
        t2.start();  
        t3.start();  
    }  
    private static class TestClient extends Thread {  
        private TestNum sn;  
        public TestClient(TestNum sn) {  
            this.sn = sn;  
        }  
        public void run() {  
            for (int i = 0; i &lt; 3; i++) {  
                // ④每个线程打出3个序列值  
                System.out.println(&quot;thread[&quot; + Thread.currentThread().getName() + &quot;] --&gt; sn[&quot;  
                         + sn.getNextNum() + &quot;]&quot;);  
            }  
        }  
    }  
} 
</code></pre><blockquote>
<p>通常我们通过匿名内部类的方式定义ThreadLocal的子类，提供初始的变量值，如例子中①处所示。TestClient线程产生一组序列号，在③处，我们生成3个TestClient，它们共享同一个TestNum实例。运行以上代码，在控制台上输出以下的结果：</p>
</blockquote>
<pre><code>thread[Thread-0] --&gt; sn[1]
thread[Thread-1] --&gt; sn[1]
thread[Thread-2] --&gt; sn[1]
thread[Thread-1] --&gt; sn[2]
thread[Thread-0] --&gt; sn[2]
thread[Thread-1] --&gt; sn[3]
thread[Thread-2] --&gt; sn[2]
thread[Thread-0] --&gt; sn[3]
thread[Thread-2] --&gt; sn[3]
</code></pre><blockquote>
<p>考察输出的结果信息，我们发现每个线程所产生的序号虽然都共享同一个TestNum实例，但它们并没有发生相互干扰的情况，而是各自产生独立的序列号，这是因为我们通过ThreadLocal为每一个线程提供了单独的副本。</p>
</blockquote>
<h3 id="Vs线程同步机制"><a href="#Vs线程同步机制" class="headerlink" title="Vs线程同步机制"></a>Vs线程同步机制</h3><blockquote>
<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</p>
</blockquote>
<ul>
<li>线程同步机制</li>
</ul>
<blockquote>
<p>线程同步机制是通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用线程同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</p>
</blockquote>
<ul>
<li>ThreadLocal机制</li>
</ul>
<blockquote>
<p>ThreadLocal为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。每一个线程都拥有自己的变量副本，所以就没必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<p>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但从JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用，上面的例子就使用了JDK 5.0新的ThreadLocal\<t\>版本。</t\></p>
</blockquote>
<ul>
<li>两者比较</li>
</ul>
<blockquote>
<p>概括起来说，对于多线程资源共享的问题，线程同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
</blockquote>
<h3 id="ThreadLocal具体实现"><a href="#ThreadLocal具体实现" class="headerlink" title="ThreadLocal具体实现"></a>ThreadLocal具体实现</h3><blockquote>
<p>ThreadLocal类到底是如何实现这种“为每个线程提供不同的变量拷贝”的呢？先来看一下ThreadLocal的set()方法:</p>
</blockquote>
<pre><code>/** 
    * Sets the current thread&apos;s copy of this thread-local variable 
    * to the specified value.  Most subclasses will have no need to 
    * override this method, relying solely on the {@link #initialValue} 
    * method to set the values of thread-locals. 
    * 
    * @param value the value to be stored in the current thread&apos;s copy of 
    *        this thread-local. 
    */  
   public void set(T value) {  
       Thread t = Thread.currentThread();  
       ThreadLocalMap map = getMap(t);  
       if (map != null)  
           map.set(this, value);  
       else  
           createMap(t, value);  
   } 
</code></pre><blockquote>
<p>首先，通过getMap(Thread t)方法获取一个和当前线程相关的ThreadLocalMap；然后，将变量的值设置到这个ThreadLocalMap对象中，当然如果获取到的ThreadLocalMap对象为空，就通过createMap方法创建。</p>
<p>线程隔离的秘密就在于ThreadLocalMap类，ThreadLocalMap是ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取（对比Map对象来理解），每个线程中都有一个独立的ThreadLocalMap副本，它所存储的值，只能被当前线程读取和修改。ThreadLocal类通过操作每一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程中的隔离。因为每个线程的变量都是自己特有的，完全不会有并发错误。还有一点就是，ThreadLocalMap存储的键值对中的键是this对象指向的ThreadLocal对象，而值就是你所设置的对象了。</p>
<p>为了加深理解，我们接着看上面代码中出现的getMap和createMap方法的实现：</p>
</blockquote>
<pre><code>/** 
 * Get the map associated with a ThreadLocal. Overridden in 
 * InheritableThreadLocal. 
 * 
 * @param  t the current thread 
 * @return the map 
 */  
ThreadLocalMap getMap(Thread t) {  
    return t.threadLocals;  
}  

/** 
 * Create the map associated with a ThreadLocal. Overridden in 
 * InheritableThreadLocal. 
 * 
 * @param t the current thread 
 * @param firstValue value for the initial entry of the map 
 * @param map the map to store. 
 */  
void createMap(Thread t, T firstValue) {  
    t.threadLocals = new ThreadLocalMap(this, firstValue);  
}  
</code></pre><blockquote>
<p>接下来再看一下ThreadLocal类中的get()方法:</p>
</blockquote>
<pre><code>/** 
 * Returns the value in the current thread&apos;s copy of this 
 * thread-local variable.  If the variable has no value for the 
 * current thread, it is first initialized to the value returned 
 * by an invocation of the {@link #initialValue} method. 
 * 
 * @return the current thread&apos;s value of this thread-local 
 */  
public T get() {  
    Thread t = Thread.currentThread();  
    ThreadLocalMap map = getMap(t);  
    if (map != null) {  
        ThreadLocalMap.Entry e = map.getEntry(this);  
        if (e != null)  
            return (T)e.value;  
    }  
    return setInitialValue();  
}  
</code></pre><blockquote>
<p>再来看setInitialValue()方法：</p>
</blockquote>
<pre><code>/** 
    * Variant of set() to establish initialValue. Used instead 
    * of set() in case user has overridden the set() method. 
    * 
    * @return the initial value 
    */  
   private T setInitialValue() {  
       T value = initialValue();  
       Thread t = Thread.currentThread();  
       ThreadLocalMap map = getMap(t);  
       if (map != null)  
           map.set(this, value);  
       else  
           createMap(t, value);  
       return value;  
   }  
</code></pre><blockquote>
<p>获取和当前线程绑定的值时，ThreadLocalMap对象是以this指向的ThreadLocal对象为键进行查找的，这当然和前面set()方法的代码是相呼应的。</p>
<p>进一步地，我们可以创建不同的ThreadLocal实例来实现多个变量在不同线程间的访问隔离，为什么可以这么做？因为不同的ThreadLocal对象作为不同键，当然也可以在线程的ThreadLocalMap对象中设置不同的值了。通过ThreadLocal对象，在多线程中共享一个值和多个值的区别，就像你在一个HashMap对象中存储一个键值对和多个键值对一样，仅此而已。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p>
</blockquote>
<p><strong>一个是锁机制进行时间换空间，一个是存储拷贝进行空间换时间。</strong></p>
<p><strong>参考资料</strong><br><a href="http://blog.csdn.net/lufeng20/article/details/24314381" target="_blank" rel="external">博文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;JDK 1.2开始提供Java.lang.ThreadLocal类，为解决多线程并发访问问题提供了一种新思路，使用
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android事件分发机制</title>
    <link href="http://yoursite.com/2016/10/01/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/10/01/Android事件分发机制/</id>
    <published>2016-10-01T01:54:33.000Z</published>
    <updated>2016-10-10T06:08:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ViewGroup是一组View的集合，它包含很多的子View和子ViewGroup，是Android中所有布局的父类或间接父类，像LinearLayout、RelativeLayout等都是继承自ViewGroup的。但ViewGroup实际上也是一个View，只不过比起View，它多了可以包含子View和定义布局参数的功能。这里按照View和ViewGroup两种情况去分析，其中，View特指不是容器的组件，而ViewGroup则是一个容器，里面可以包含前者的非容器View和ViewGroup。</strong></p>
<ul>
<li>View 的事件分发</li>
<li>ViewGroup 的事件分发</li>
<li>总结</li>
</ul>
<hr>
<h2 id="View-的事件分发"><a href="#View-的事件分发" class="headerlink" title="View 的事件分发"></a>View 的事件分发</h2><blockquote>
<p>定义一个Activity，其布局中只有一个按钮，并给按钮注册一个点击事件，如下：</p>
</blockquote>
<pre><code>button.setOnClickListener(new OnClickListener() {  
    @Override  
    public void onClick(View v) {  
        Log.d(&quot;TAG&quot;, &quot;onClick execute&quot;);  
    }  
});
</code></pre><blockquote>
<p>按钮被点击，onClick方法执行。然后再给按钮再添加一个touch事件，如下：</p>
</blockquote>
<pre><code>button.setOnTouchListener(new OnTouchListener() {  
    @Override  
    public boolean onTouch(View v, MotionEvent event) {  
        Log.d(&quot;TAG&quot;, &quot;onTouch execute, action &quot; + event.getAction());  
        return false;  
    }  
});  
</code></pre><blockquote>
<p>onTouch方法能够执行的逻辑要更复杂一些，如判断手指按下、抬起、移动等事件。</p>
</blockquote>
<p><strong>问题来了，哪一个会先执行呢？</strong></p>
<blockquote>
<p>运行程序点击按钮，打印结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130614230234671" alt=""></p>
<blockquote>
<p>结果证明：onTouch是优先于onClick执行，并且onTouch执行了两次，一次是ACTION_DOWN，一次是ACTION_UP(你还可能会有多次ACTION_MOVE的执行，如果你手抖了一下)。</p>
<p>因此事件传递的顺序是先经过onTouch，再传递到onClick。</p>
</blockquote>
<p><strong>为什么会这样？</strong></p>
<blockquote>
<p>查看onTouch方法，发现其有返回值的，上面返回的是false。</p>
</blockquote>
<p><strong>如果返回true呢？</strong></p>
<blockquote>
<p>再次运行，结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130614231001468" alt=""></p>
<blockquote>
<p>onClick方法不再执行了！为什么会这样呢？</p>
<p>可以暂时理解成onTouch方法返回true就认为这个事件被onTouch消费掉了，因而不会再继续向下传递。</p>
<p>当然，我们不会仅仅满足于此，让我们深层次的去看看出现上述现象的原理到底是什么？</p>
<p>首先，你触摸到了任何控件，那一定会调用该控件的dispatchTouchEvent方法。当点击按钮的时，就会去调用Button的dispatchTouchEvent方法，可Button里没有这个方法，那就去它父类TextView里找，发现TextView也没有，继续在TextView的父类View里找，Bingo，终于找到了。</p>
<p>然后，重点来了，看一下View中dispatchTouchEvent方法的源码吧！</p>
</blockquote>
<pre><code>public boolean dispatchTouchEvent(MotionEvent event) {  
    if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  
            mOnTouchListener.onTouch(this, event)) {  
        return true;  
    }  
    return onTouchEvent(event);  
}  
</code></pre><blockquote>
<p>简洁，只有几行代码！先是一个判断，如果mOnTouchListener != null，(mViewFlags &amp; ENABLED_MASK) == ENABLED和mOnTouchListener.onTouch(this, event)这三个条件都为真，就返回true，否则就去执行onTouchEvent(event)方法并返回。_</p>
<p>第一个条件，mOnTouchListener变量是在哪赋值的呢？寻找之后在View里发现了如下方法：</p>
</blockquote>
<pre><code>public void setOnTouchListener(OnTouchListener l) {  
    mOnTouchListener = l;  
}  
</code></pre><blockquote>
<p>Bingo！mOnTouchListener是在这里赋值的，也就是说，只要给控件注册了touch事件，mOnTouchListener就一定被赋值了，也就不为null了。</p>
<p>第二个条件，(mViewFlags &amp; ENABLED_MASK) == ENABLED，判断当前点击的控件是否是enable的，按钮默认都是enable的，因此这个条件恒定为true。_</p>
<p>第三个条件，mOnTouchListener.onTouch(this, event)，关键点，回调控件注册touch事件时的onTouch方法。如果在onTouch方法里返回true，这三个条件全部成立，从而整个方法直接返回true。如果在onTouch方法里返回false，就会再去执行onTouchEvent(event)方法。</p>
<p>结合前面的例子综合分析一下，先在dispatchTouchEvent中最先执行的是onTouch方法，因此onTouch要先于onClick执行，也印证了刚刚的打印结果。而如果在onTouch方法里返回了true，就会让dispatchTouchEvent方法直接返回true，不会再继续往下执行。而打印结果也证实了如果onTouch返回true，其onTouchEvent(event)方法也就不再执行了， onClick也就不会再执行了(后面我们知道，onClick方法就是在onTouchEvent(event)方法里执行的)。</p>
<p>根据以上分析，从原理上解释了前面例子的运行结果。那我们就来看下onTouchEvent的源码，看看onClick方法是不是真的在里面，如下所示：</p>
</blockquote>
<pre><code>1.  public boolean onTouchEvent(MotionEvent event) {  
2.      final int viewFlags = mViewFlags;  
3.      if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {  
4.          // A disabled view that is clickable still consumes the touch  
5.          // events, it just doesn&apos;t respond to them.  
6.          return (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  
7.                  (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));  
8.      }  
9.      if (mTouchDelegate != null) {  
10.         if (mTouchDelegate.onTouchEvent(event)) {  
11.             return true;  
12.         }  
13.     }  
14.     if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  
15.             (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {  
16.         switch (event.getAction()) {  
17.             case MotionEvent.ACTION_UP:  
18.                 boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0;  
19.                 if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) {  
20.                     // take focus if we don&apos;t have it already and we should in  
21.                     // touch mode.  
22.                     boolean focusTaken = false;  
23.                     if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {  
24.                         focusTaken = requestFocus();  
25.                     }  
26.                     if (!mHasPerformedLongPress) {  
27.                         // This is a tap, so remove the longpress check  
28.                         removeLongPressCallback();  
29.                         // Only perform take click actions if we were in the pressed state  
30.                         if (!focusTaken) {  
31.                             // Use a Runnable and post this rather than calling  
32.                             // performClick directly. This lets other visual state  
33.                             // of the view update before click actions start.  
34.                             if (mPerformClick == null) {  
35.                                 mPerformClick = new PerformClick();  
36.                             }  
37.                             if (!post(mPerformClick)) {  
38.                                 performClick();  
39.                             }  
40.                         }  
41.                     }  
42.                     if (mUnsetPressedState == null) {  
43.                         mUnsetPressedState = new UnsetPressedState();  
44.                     }  
45.                     if (prepressed) {  
46.                         mPrivateFlags |= PRESSED;  
47.                         refreshDrawableState();  
48.                         postDelayed(mUnsetPressedState,  
49.                                 ViewConfiguration.getPressedStateDuration());  
50.                     } else if (!post(mUnsetPressedState)) {  
51.                         // If the post failed, unpress right now  
52.                         mUnsetPressedState.run();  
53.                     }  
54.                     removeTapCallback();  
55.                 }  
56.                 break;  
57.             case MotionEvent.ACTION_DOWN:  
58.                 if (mPendingCheckForTap == null) {  
59.                     mPendingCheckForTap = new CheckForTap();  
60.                 }  
61.                 mPrivateFlags |= PREPRESSED;  
62.                 mHasPerformedLongPress = false;  
63.                 postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  
64.                 break;  
65.             case MotionEvent.ACTION_CANCEL:  
66.                 mPrivateFlags &amp;= ~PRESSED;  
67.                 refreshDrawableState();  
68.                 removeTapCallback();  
69.                 break;  
70.             case MotionEvent.ACTION_MOVE:  
71.                 final int x = (int) event.getX();  
72.                 final int y = (int) event.getY();  
73.                 // Be lenient about moving outside of buttons  
74.                 int slop = mTouchSlop;  
75.                 if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) ||  
76.                         (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) {  
77.                     // Outside button  
78.                     removeTapCallback();  
79.                     if ((mPrivateFlags &amp; PRESSED) != 0) {  
80.                         // Remove any future long press/tap checks  
81.                         removeLongPressCallback();  
82.                         // Need to switch from pressed to not pressed  
83.                         mPrivateFlags &amp;= ~PRESSED;  
84.                         refreshDrawableState();  
85.                     }  
86.                 }  
87.                 break;  
88.         }  
89.         return true;  
90.     }  
91.     return false;  
92. } 
</code></pre><p><strong>比较长，挑重点看</strong></p>
<blockquote>
<p>在第14行我们可以看出，如果该控件是可以点击的就会进入到第16行的switch判断中去，而如果当前的事件是抬起手指，则会进入到MotionEvent.ACTION_UP这个case当中。在经过种种判断之后，会执行到第38行的performClick()方法，那就看看这个方法：_</p>
</blockquote>
<pre><code>public boolean performClick() {  
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  
    if (mOnClickListener != null) {  
        playSoundEffect(SoundEffectConstants.CLICK);  
        mOnClickListener.onClick(this);  
        return true;  
    }  
    return false;  
} 
</code></pre><p><strong>舒服多了</strong></p>
<blockquote>
<p>看到mOnClickListener.onClick(this)，我们就更开心了，只要mOnClickListener不是null，就会去调用它，那mOnClickListener又是在哪里赋值的呢？看下面：</p>
</blockquote>
<pre><code>public void setOnClickListener(OnClickListener l) {  
    if (!isClickable()) {  
        setClickable(true);  
    }  
    mOnClickListener = l;  
}  
</code></pre><blockquote>
<p>一切都清楚了！当调用setOnClickListener方法来给控件注册一个点击事件时，就会给mOnClickListener赋值。然后每当控件被点击时，都会在performClick()方法里回调被点击控件的onClick方法。</p>
<p>整个事件分发的流程似乎就这样要结束了，不，还有一个要重点说明的是touch事件的层级传递。如果给一个控件注册了touch事件，每次点击它的时候都会触发一系列的ACTION_DOWN，ACTION_MOVE，ACTION_UP等事件，简称为事件流，请注意，如果你在执行ACTION_DOWN的时候返回了false，那么这个事件流就会被中断执行。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个action事件返回true，才会触发后一个action 事件。</p>
</blockquote>
<p><strong>这不是自相矛盾吗？</strong></p>
<blockquote>
<p>前面的例子中，明明在onTouch事件里面返回了false，ACTION_DOWN和ACTION_UP不是都得到执行了吗？其实你只是被假象所迷惑了，仔细分析一下代码，就会知道在前面的例子当中，我们到底返回的是什么。首先在onTouch事件里返回了false，就一定会进入到onTouchEvent方法中，然后我们来看一下onTouchEvent方法的细节。_由于点击了按钮且按钮是可点击的_，就会进入到第14行这个if判断的内部，然后你会发现，不管当前的action是什么，最终都一定会走到第89行，返回一个true。</p>
</blockquote>
<p><strong>是不是有一种被欺骗的感觉？</strong></p>
<blockquote>
<p>明明在onTouch事件里返回了false，系统还是在onTouchEvent方法中帮你返回了true。就因为这个原因，才使得前面的例子中ACTION_UP可以得到执行。_</p>
<p>我们可以换一个控件，将按钮替换成ImageView，然后给它也注册一个touch事件，并返回false。如下所示：</p>
</blockquote>
<pre><code>imageView.setOnTouchListener(new OnTouchListener() {  
    @Override  
    public boolean onTouch(View v, MotionEvent event) {  
        Log.d(&quot;TAG&quot;, &quot;onTouch execute, action &quot; + event.getAction());  
        return false;  
    }  
});  
</code></pre><blockquote>
<p>运行程序，点击ImageView，结果如下</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130617193504328" alt=""></p>
<blockquote>
<p>在ACTION_DOWN执行完后，后面的一系列action事件都不会得到执行了。这又是为什么呢？因为ImageView和按钮不同，它是默认不可点击的，因此在onTouchEvent的第14行判断时无法进入到if的内部，直接跳到第91行返回了false，也就导致后面其它的action都无法执行了。View的事件分发，就到这里。</p>
</blockquote>
<hr>
<h2 id="ViewGroup的事件分发"><a href="#ViewGroup的事件分发" class="headerlink" title="ViewGroup的事件分发"></a>ViewGroup的事件分发</h2><blockquote>
<p>首先，自定义一个布局为MyLayout，继承自LinearLayout，如下：</p>
</blockquote>
<pre><code>public class MyLayout extends LinearLayout {  
    public MyLayout(Context context, AttributeSet attrs) {  
        super(context, attrs);  
    }  
}  
</code></pre><blockquote>
<p>然后，打开布局文件activity_main.xml，在其中加入自定义的布局MyLayout，如下：</p>
</blockquote>
<pre><code>&lt;com.example.viewgrouptouchevent.MyLayout 
        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:id=&quot;@+id/my_layout&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    android:orientation=&quot;vertical&quot; &gt;  
    &lt;Button  
        android:id=&quot;@+id/button1&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Button1&quot; /&gt;  
    &lt;Button  
        android:id=&quot;@+id/button2&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Button2&quot; /&gt;  
&lt;/com.example.viewgrouptouchevent.MyLayout&gt;  
</code></pre><blockquote>
<p>在MyLayout中添加了两个按钮，最后在MainActivity中为这两个按钮和MyLayout注册监听事件：</p>
</blockquote>
<pre><code>myLayout.setOnTouchListener(new OnTouchListener() {  
    @Override  
    public boolean onTouch(View v, MotionEvent event) {  
        Log.d(&quot;TAG&quot;, &quot;myLayout on touch&quot;);  
        return false;  
    }  
});  
button1.setOnClickListener(new OnClickListener() {  
    @Override  
    public void onClick(View v) {  
        Log.d(&quot;TAG&quot;, &quot;You clicked button1&quot;);  
    }  
});  
button2.setOnClickListener(new OnClickListener() {  
    @Override  
    public void onClick(View v) {  
        Log.d(&quot;TAG&quot;, &quot;You clicked button2&quot;);  
    }  
});  
</code></pre><blockquote>
<p>运行项目，分别点击一下Button1、Button2和空白区域，打印结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130629144048875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<blockquote>
<p>当点击按钮的时，MyLayout注册的onTouch方法并不会执行，只有点击空白区域的时候才会执行该方法。可以先暂时理解成Button的onClick方法将事件消费掉了，因此事件不会再继续向下传递。</p>
<p>Android中的touch事件是先传递到View，再传递到ViewGroup的？</p>
</blockquote>
<p><strong>结论下的太早，做个实验</strong></p>
<blockquote>
<p>ViewGroup中有一个onInterceptTouchEvent方法，我们来看一下这个方法的源码：</p>
</blockquote>
<pre><code>public boolean onInterceptTouchEvent(MotionEvent ev) {  
    return false;  
} 
</code></pre><p><strong>还是这么短(注释已略去)</strong></p>
<blockquote>
<p>只有一行代码，返回一个false！既然是布尔型的返回，那么只有两种可能，我们在MyLayout中重写这个方法，然后分布返回一个true和false试试，代码如下所示：</p>
</blockquote>
<pre><code>public class MyLayout extends LinearLayout {  
    public MyLayout(Context context, AttributeSet attrs) {  
        super(context, attrs);  
    }  
    @Override  
    public boolean onInterceptTouchEvent(MotionEvent ev) {  
        return true;  
    }  
}  
</code></pre><blockquote>
<p>运行项目，分别Button1、Button2和空白区域，打印结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130629145544984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<blockquote>
<p>奇怪了，不管点哪里，永远都只会触发MyLayout的touch事件了，按钮的点击事件完全被屏蔽掉了！</p>
</blockquote>
<p><strong>这是为什么？</strong></p>
<blockquote>
<p>如果Android中的touch事件是先传递到View，再传递到ViewGroup的，那么MyLayout又怎么可能屏蔽掉Button的点击事件呢？</p>
<p>看来只有通过源码，才能搞清Android中ViewGroup的事件分发机制，解决心中疑惑，不过结论一定是：<strong>Android中touch事件的传递，绝对是先传递到ViewGroup，再传递到View的。</strong></p>
<p>在上一小节中，我们说过只要你触摸了任何控件，就一定会调用该控件的dispatchTouchEvent方法。这个说法没错，只不过还不完整而已。实际是，当你点击了某个控件，首先会去调用该控件所在布局的dispatchTouchEvent方法，然后在布局的dispatchTouchEvent方法中找到被点击的相应控件，再去调用该控件的dispatchTouchEvent方法。如果我们点击了MyLayout中的按钮，会先去调用MyLayout的dispatchTouchEvent方法，可是你会发现MyLayout中并没有这个方法，那就去到它的父类LinearLayout中找，发现也没有这个方法，那就继续再找LinearLayout的父类ViewGroup，终于在ViewGroup中看到了这个方法，按钮的dispatchTouchEvent方法就是在这里调用的。</p>
<p>ViewGroup中的dispatchTouchEvent方法的源码如下：</p>
</blockquote>
<pre><code>1.  public boolean dispatchTouchEvent(MotionEvent ev) {  
2.      final int action = ev.getAction();  
3.      final float xf = ev.getX();  
4.      final float yf = ev.getY();  
5.      final float scrolledXFloat = xf + mScrollX;  
6.      final float scrolledYFloat = yf + mScrollY;  
7.      final Rect frame = mTempRect;  
8.      boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;  
9.      if (action == MotionEvent.ACTION_DOWN) {  
10.         if (mMotionTarget != null) {  
11.             mMotionTarget = null;  
12.         }  
13.         if (disallowIntercept || !onInterceptTouchEvent(ev)) {  
14.             ev.setAction(MotionEvent.ACTION_DOWN);  
15.             final int scrolledXInt = (int) scrolledXFloat;  
16.             final int scrolledYInt = (int) scrolledYFloat;  
17.             final View[] children = mChildren;  
18.             final int count = mChildrenCount;  
19.             for (int i = count - 1; i &gt;= 0; i--) {  
20.                 final View child = children[i];  
21.                 if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE  
22.                         || child.getAnimation() != null) {  
23.                     child.getHitRect(frame);  
24.                     if (frame.contains(scrolledXInt, scrolledYInt)) {  
25.                         final float xc = scrolledXFloat - child.mLeft;  
26.                         final float yc = scrolledYFloat - child.mTop;  
27.                         ev.setLocation(xc, yc);  
28.                         child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
29.                         if (child.dispatchTouchEvent(ev))  {  
30.                             mMotionTarget = child;  
31.                             return true;  
32.                         }  
33.                     }  
34.                 }  
35.             }  
36.         }  
37.     }  
38.     boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  
39.             (action == MotionEvent.ACTION_CANCEL);  
40.     if (isUpOrCancel) {  
41.         mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;  
42.     }  
43.     final View target = mMotionTarget;  
44.     if (target == null) {  
45.         ev.setLocation(xf, yf);  
46.         if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) {  
47.             ev.setAction(MotionEvent.ACTION_CANCEL);  
48.             mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
49.         }  
50.         return super.dispatchTouchEvent(ev);  
51.     }  
52.     if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) {  
53.         final float xc = scrolledXFloat - (float) target.mLeft;  
54.         final float yc = scrolledYFloat - (float) target.mTop;  
55.         mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
56.         ev.setAction(MotionEvent.ACTION_CANCEL);  
57.         ev.setLocation(xc, yc);  
58.         if (!target.dispatchTouchEvent(ev)) {  
59.         }  
60.         mMotionTarget = null;  
61.         return true;  
62.     }  
63.     if (isUpOrCancel) {  
64.         mMotionTarget = null;  
65.     }  
66.     final float xc = scrolledXFloat - (float) target.mLeft;  
67.     final float yc = scrolledYFloat - (float) target.mTop;  
68.     ev.setLocation(xc, yc);  
69.     if ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) {  
70.         ev.setAction(MotionEvent.ACTION_CANCEL);  
71.         target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
72.         mMotionTarget = null;  
73.     }  
74.     return target.dispatchTouchEvent(ev);  
75. }  
</code></pre><p><strong>挑重点看</strong></p>
<blockquote>
<p>首先，在第13行处有一个条件判断，如果disallowIntercept和!onInterceptTouchEvent(ev)两者有一个为true，就会进入到这个条件判断中。disallowIntercept是指是否禁用掉事件拦截的功能，默认是false，也可以通过调用requestDisallowInterceptTouchEvent方法对这个值进行修改。那么当第一个值为false的时候就会完全依赖第二个值来决定是否可以进入到条件判断的内部，第二个值是什么呢？竟然就是对onInterceptTouchEvent方法的返回值取反！也就是说如果我们在onInterceptTouchEvent方法中返回false，就会让第二个值为true，从而进入到条件判断的内部，如果我们在onInterceptTouchEvent方法中返回true，就会让第二个值为false，从而跳出了这个条件判断。</p>
<p>由于我们在MyLayout中重写了onInterceptTouchEvent方法，让这个方法返回true，导致所有按钮的点击事件都被屏蔽了，那我们就完全有理由相信，按钮点击事件的处理就是在第13行条件判断的内部进行的！那重点看下条件判断的内部是怎么实现的。在第19行通过一个for循环，遍历了当前ViewGroup下的所有子View，然后在第24行判断当前遍历的View是不是正在点击的View，如果是的话就会进入到该条件判断的内部，然后在第29行调用了该View的dispatchTouchEvent，之后就是上节讲的View的事件分发了。</p>
<p>然后需要注意，调用子View的dispatchTouchEvent后是有返回值的。我们已经知道，如果一个控件是可点击的，那么点击该控件时，dispatchTouchEvent的返回值必定是true。因此会导致第29行的条件判断成立，于是在第31行给ViewGroup的dispatchTouchEvent方法直接返回了true。这样就导致后面的代码无法执行到了，也是印证了我们前面的Demo打印的结果，如果按钮的点击事件得到执行，就会把MyLayout的touch事件拦截掉。</p>
<p>如果我们点击的不是按钮，而是空白区域呢？这种情况就一定不会在第31行返回true了，而是会继续执行后面的代码。那我们继续往后看，在第44行，如果target等于null，就会进入到该条件判断内部，这里一般情况下target都会是null，因此会在第50行调用super.dispatchTouchEvent(ev)。这句代码会调用到哪里呢？当然是View中的dispatchTouchEvent方法了，因为ViewGroup的父类就是View。之后的处理逻辑又和前面所说的是一样的了，也因此MyLayout中注册的onTouch方法会得到执行。之后的代码在一般情况下是走不到的了，我们也就不再继续往下分析。</p>
<p>ViewGroup事件分发过程的流程图如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130629200236578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<blockquote>
<p>现在整个ViewGroup的事件分发流程的分析也就到此结束了，我们最后再来简单梳理一下吧。</p>
</blockquote>
<ol>
<li>Android事件分发是先传递到ViewGroup，再由ViewGroup传递到View的。</li>
<li>在ViewGroup中可以通过onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。</li>
<li>子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>onTouch和onTouchEvent区别，如何使用？</li>
</ol>
<blockquote>
<p>这两个方法都是在View的dispatchTouchEvent中调用的，onTouch先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一，mOnTouchListener的值不能为空，第二，当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。</p>
</blockquote>
<ol>
<li>为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？</li>
</ol>
<blockquote>
<blockquote>
<p>滑动菜单的功能是通过给ListView注册了一个touch事件来实现的。如果你在onTouch方法里处理完了滑动逻辑后返回true，那么ListView本身的滚动事件就被屏蔽了，自然也就无法滑动，因此解决办法就是在onTouch方法里返回false。</p>
</blockquote>
</blockquote>
<ol>
<li>为什么图片轮播器里的图片使用Button而不用ImageView？</li>
</ol>
<blockquote>
<p>因为Button是可点击的，而ImageView是不可点击的。如果想要使用ImageView，可以有两种改法。第一，在ImageView的onTouch方法里返回true，这样可以保证ACTION_DOWN之后的其它action都能得到执行，才能实现图片滚动的效果。第二，在布局文件里面给ImageView增加一个android:clickable=”true”的属性，这样ImageView变成可点击的之后，即使在onTouch里返回了false，ACTION_DOWN之后的其它action也是可以得到执行的。</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h3><p><a href="http://blog.csdn.net/sinyu890807/article/details/9097463" target="_blank" rel="external">http://blog.csdn.net/sinyu890807/article/details/9097463</a><br><a href="http://blog.csdn.net/sinyu890807/article/details/9153747" target="_blank" rel="external">http://blog.csdn.net/sinyu890807/article/details/9153747</a><br>《Android开发艺术探索》—— <a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="external">任玉刚</a><br>《Android群英传》——<a href="http://blog.csdn.net/eclipsexys" target="_blank" rel="external"> 徐宜生</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;ViewGroup是一组View的集合，它包含很多的子View和子ViewGroup，是Android中所有布局的父类或间接父类，像LinearLayout、RelativeLayout等都是继承自ViewGroup的。但ViewGroup实际上也是一个Vi
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="事件分发" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Android消息处理机制 — 实用易懂(1)</title>
    <link href="http://yoursite.com/2016/08/05/Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%20%E2%80%94%20%E5%AE%9E%E7%94%A8%E6%98%93%E6%87%82(1)/"/>
    <id>http://yoursite.com/2016/08/05/Android消息处理机制 — 实用易懂(1)/</id>
    <published>2016-08-05T09:40:41.000Z</published>
    <updated>2016-10-10T06:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="四个核心类"><a href="#四个核心类" class="headerlink" title="四个核心类"></a>四个核心类</h3><ul>
<li>Looper </li>
<li>Handler </li>
<li>Message </li>
<li>MessageQueue(MQ被封装到Looper里面了，我们不会直接与MQ打交道)</li>
</ul>
<h3 id="核心类详解"><a href="#核心类详解" class="headerlink" title="核心类详解"></a>核心类详解</h3><h4 id="线程控制者Looper"><a href="#线程控制者Looper" class="headerlink" title="线程控制者Looper"></a>线程控制者Looper</h4><blockquote>
<p>Looper的字面意思是“循环者”，它被设计用来使一个普通线程变成Looper线程。所谓Looper线程就是循环工作的线程。在程序开发中（尤其是GUI开发中），我们经常会需要一个线程不断循环，一旦有新任务则执行，执行完继续等待下一个任务，这就是Looper线程。使用Looper类创建Looper线程很简单：</p>
</blockquote>
<pre><code>public class LooperThread extends Thread {
    @Override
    public void run() {
        // 将当前线程初始化为Looper线程
        Looper.prepare();

        // ...其他处理，如实例化handler

        // 开始循环处理消息队列
        Looper.loop();
    }
}
</code></pre><blockquote>
<p>通过上面两行核心代码，你的线程就升级为Looper线程了！！！是不是很神奇？让我们放慢镜头，看看这两行代码各自做了什么。</p>
</blockquote>
<ul>
<li>Looper.prepare()</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/Looper.prepare().png" alt=""></p>
<blockquote>
<p>通过上图可以看到，现在你的线程中有一个Looper对象，它的内部维护了一个消息队列MQ。注意，一个Thread只能有一个Looper对象，为什么呢？咱们来看源码。</p>
</blockquote>
<pre><code>public class Looper {
    // 每个线程中的Looper对象其实是一个ThreadLocal，即线程本地存储(TLS)对象
    private static final ThreadLocal sThreadLocal = new ThreadLocal();
    // Looper内的消息队列
    final MessageQueue mQueue;
    // 当前线程
    Thread mThread;
    // 。。。其他属性

    // 每个Looper对象中有它的消息队列，和它所属的线程
    private Looper() {
        mQueue = new MessageQueue();
        mRun = true;
        mThread = Thread.currentThread();
    }

    // 我们调用该方法会在调用线程的TLS中创建Looper对象
    public static final void prepare() {
        if (sThreadLocal.get() != null) {
            // 试图在有Looper的线程中再次创建Looper将抛出异常
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper());
    }
    // 其他方法
}
</code></pre><blockquote>
<p>通过源码，prepare()背后的工作方式一目了然，其核心就是将looper对象定义为ThreadLocal。</p>
</blockquote>
<ul>
<li>Looper.loop()<br><img src="http://o9zgq2ik9.bkt.clouddn.com/Looper.loop().png" alt=""></li>
</ul>
<blockquote>
<p>调用loop方法后，Looper线程就开始真正工作了，它不断从自己的MQ中取出队头的消息(也叫任务)执行。其源码分析如下：</p>
</blockquote>
<pre><code>public static final void loop() {
        Looper me = myLooper();  //得到当前线程Looper
        MessageQueue queue = me.mQueue;  //得到当前looper的MQ

        // 这两行没看懂= = 不过不影响理解
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();
        // 开始循环
        while (true) {
            Message msg = queue.next(); // 取出message
            if (msg != null) {
                if (msg.target == null) {
                    // message没有target为结束信号，退出循环
                    return;
                }
                // 日志。。。
                if (me.mLogging!= null) me.mLogging.println(
                        &quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot;
                        + msg.callback + &quot;: &quot; + msg.what
                        );
                // 非常重要！将真正的处理工作交给message的target，即后面要讲的handler
                msg.target.dispatchMessage(msg);
                // 还是日志。。。
                if (me.mLogging!= null) me.mLogging.println(
                        &quot;&lt;&lt;&lt;&lt;&lt; Finished to    &quot; + msg.target + &quot; &quot;
                        + msg.callback);

                // 下面没看懂，同样不影响理解
                final long newIdent = Binder.clearCallingIdentity();
                if (ident != newIdent) {
                    Log.wtf(&quot;Looper&quot;, &quot;Thread identity changed from 0x&quot;
                            + Long.toHexString(ident) + &quot; to 0x&quot;
                            + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                            + msg.target.getClass().getName() + &quot; &quot;
                            + msg.callback + &quot; what=&quot; + msg.what);
                }
                // 回收message资源
                msg.recycle();
            }
        }
    }
</code></pre><blockquote>
<p>除了prepare()和loop()方法，Looper类还提供了一些有用的方法，比如Looper.myLooper()得到当前线程looper对象：</p>
</blockquote>
<pre><code>public static final Looper myLooper() {
    // 在任意线程调用Looper.myLooper()返回的都是那个线程的looper
    return (Looper)sThreadLocal.get();
}
</code></pre><blockquote>
<p>getThread()得到looper对象所属线程：</p>
</blockquote>
<pre><code>public Thread getThread() {
    return mThread;
}
</code></pre><blockquote>
<p>quit()方法结束looper循环：</p>
</blockquote>
<pre><code>public void quit() {
    // 创建一个空的message，它的target为NULL，表示结束循环消息
    Message msg = Message.obtain();
    // 发出消息
    mQueue.enqueueMessage(msg, 0);
}
</code></pre><blockquote>
<p>到此为止，你应该对Looper有了基本的了解，总结几点：</p>
</blockquote>
<ul>
<li>每个线程有且最多只能有一个Looper对象，它是一个ThreadLocal</li>
<li>Looper内部有一个消息队列，loop()方法调用后线程开始不断从队列中取出消息执行</li>
<li>Looper使一个线程变成Looper线程。</li>
</ul>
<blockquote>
<p>那么，我们如何往MQ上添加消息呢？下面有请Handler！</p>
</blockquote>
<h4 id="异步处理者Handler"><a href="#异步处理者Handler" class="headerlink" title="异步处理者Handler"></a>异步处理者Handler</h4><blockquote>
<p>什么是Handler？Handler扮演了往MQ上添加消息和处理消息的角色（只处理由自己发出的消息），即通知MQ它要执行一个任务(sendMessage)，并在loop到自己的时候执行该任务(handleMessage)，整个过程是异步的。Handler创建时会关联一个looper，默认的构造方法将关联当前线程的looper，不过这也是可以set的。默认的构造方法：</p>
</blockquote>
<pre><code>public class Handler {
    final MessageQueue mQueue;  // 关联的MQ
    final Looper mLooper;  // 关联的looper
    final Callback mCallback; 
    // 其他属性

    public Handler() {
        // 没看懂，直接略过，，，
        if (FIND_POTENTIAL_LEAKS) {
            final Class&lt;? extends Handler&gt; klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                    klass.getCanonicalName());
            }
        }
        // 默认将关联当前线程的looper
        mLooper = Looper.myLooper();
        // looper不能为空，即该默认的构造方法只能在looper线程中使用
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);
        }
        // 重要！！！直接把关联looper的MQ作为自己的MQ，因此它的消息将发送到关联looper的MQ上
        mQueue = mLooper.mQueue;
        mCallback = null;
    }

    // 其他方法
}
</code></pre><blockquote>
<p>下面我们就可以为之前的LooperThread类加入Handler：</p>
</blockquote>
<pre><code>public class LooperThread extends Thread {
    private Handler handler1;
    private Handler handler2;

    @Override
    public void run() {
        // 将当前线程初始化为Looper线程
        Looper.prepare();

        // 实例化两个handler
        handler1 = new Handler();
        handler2 = new Handler();

        // 开始循环处理消息队列
        Looper.loop();
    }
}
</code></pre><blockquote>
<p>加入handler后的效果如下图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/%E5%8A%A0%E5%85%A5handler%E5%90%8E%E7%9A%84%E6%95%88%E6%9E%9C.png" alt=""></p>
<blockquote>
<p>可以看到，一个线程可以有多个Handler，但是只能有一个Looper！</p>
</blockquote>
<h5 id="Handler发送消息"><a href="#Handler发送消息" class="headerlink" title="Handler发送消息"></a>Handler发送消息</h5><blockquote>
<p>有了handler之后，我们就可以使用 post(Runnable), postAtTime(Runnable, long), postDelayed(Runnable, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long)和sendMessageDelayed(Message, long)这些方法向MQ上发送消息了。光看这些API你可能会觉得handler能发两种消息，一种是Runnable对象，一种是message对象，这是直观的理解，但其实post发出的Runnable对象最后都被封装成message对象了，见源码：</p>
</blockquote>
<pre><code>// 此方法用于向关联的MQ上发送Runnable对象，它的run方法将在handler关联的looper线程中执行
    public final boolean post(Runnable r)
    {
       // 注意getPostMessage(r)将runnable封装成message
       return  sendMessageDelayed(getPostMessage(r), 0);
    }

    private final Message getPostMessage(Runnable r) {
        Message m = Message.obtain();  //得到空的message
        m.callback = r;  //将runnable设为message的callback，
        return m;
    }

    public boolean sendMessageAtTime(Message msg, long uptimeMillis)
    {
        boolean sent = false;
        MessageQueue queue = mQueue;
        if (queue != null) {
            msg.target = this;  // message的target必须设为该handler！
            sent = queue.enqueueMessage(msg, uptimeMillis);
        }
        else {
            RuntimeException e = new RuntimeException(
                this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
        }
        return sent;
    }
</code></pre><blockquote>
<p>其他方法就不罗列了，总之通过handler发出的message有如下特点：</p>
</blockquote>
<ul>
<li><p>message.target为该handler对象，这确保了looper执行到该message时能找到处理它的handler，即loop()方法中的关键代码<br>  msg.target.dispatchMessage(msg);</p>
</li>
<li><p>post发出的message，其callback为Runnable对象</p>
</li>
</ul>
<h5 id="Handler处理消息"><a href="#Handler处理消息" class="headerlink" title="Handler处理消息"></a>Handler处理消息</h5><blockquote>
<p>说完了消息的发送，再来看下handler如何处理消息。消息的处理是通过核心方法dispatchMessage(Message msg)与钩子方法handleMessage(Message msg)完成的，见源码</p>
</blockquote>
<pre><code>// 处理消息，该方法由looper调用
    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            // 如果message设置了callback，即runnable消息，处理callback！
            handleCallback(msg);
        } else {
            // 如果handler本身设置了callback，则执行callback
            if (mCallback != null) {
                 /* 这种方法允许让activity等来实现Handler.Callback接口，避免了自己编写handler重写handleMessage方法。见http://alex-yang-xiansoftware-com.iteye.com/blog/850865 */
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            // 如果message没有callback，则调用handler的钩子方法handleMessage
            handleMessage(msg);
        }
    }

    // 处理runnable消息
    private final void handleCallback(Message message) {
        message.callback.run();  //直接调用run方法！
    }
    // 由子类实现的钩子方法
    public void handleMessage(Message msg) {
    }
</code></pre><blockquote>
<p>可以看到，除了handleMessage(Message msg)和Runnable对象的run方法由开发者实现外（实现具体逻辑），handler的内部工作机制对开发者是透明的。这正是handler API设计的精妙之处！</p>
</blockquote>
<h5 id="Handler的用处"><a href="#Handler的用处" class="headerlink" title="Handler的用处"></a>Handler的用处</h5><blockquote>
<p>我在小标题中将handler描述为“异步处理大师”，这归功于Handler拥有下面两个重要的特点：</p>
</blockquote>
<ul>
<li>handler可以在任意线程发送消息，这些消息会被添加到关联的MQ上。</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/%E4%BB%BB%E6%84%8F%E7%BA%BF%E7%A8%8B%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.png" alt=""></p>
<ul>
<li>handler是在它关联的looper线程中处理消息的</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/%E5%85%B3%E8%81%94%E7%9A%84looper%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF.png" alt=""></p>
<blockquote>
<p>这就解决了android最经典的不能在其他非主线程中更新UI的问题。<em>android的主线程也是一个looper线程</em>(looper在android中运用很广)，我们在其中创建的handler默认将关联主线程MQ。因此，利用handler的一个solution就是在activity中创建handler并将其引用传递给worker thread，worker thread执行完任务后使用handler发送消息通知activity更新UI。(过程如图)</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/%E6%9B%B4%E6%96%B0UI.png" alt=""></p>
<blockquote>
<p>下面给出sample代码，仅供参考：</p>
</blockquote>
<pre><code>public class TestDriverActivity extends Activity {
    private TextView textview;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        textview = (TextView) findViewById(R.id.textview);
        // 创建并启动工作线程
        Thread workerThread = new Thread(new SampleTask(new MyHandler()));
        workerThread.start();
    }

    public void appendText(String msg) {
        textview.setText(textview.getText() + &quot;\n&quot; + msg);
    }

    class MyHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            String result = msg.getData().getString(&quot;message&quot;);
            // 更新UI
            appendText(result);
        }
    }
}

public class SampleTask implements Runnable {
    private static final String TAG = SampleTask.class.getSimpleName();
    Handler handler;

    public SampleTask(Handler handler) {
        super();
        this.handler = handler;
    }
    @Override
    public void run() {
        try {  // 模拟执行某项任务，下载等
            Thread.sleep(5000);
            // 任务完成后通知activity更新UI
            Message msg = prepareMessage(&quot;task completed!&quot;);
            // message将被添加到主线程的MQ中
            handler.sendMessage(msg);
        } catch (InterruptedException e) {
            Log.d(TAG, &quot;interrupted!&quot;);
        }

    }

    private Message prepareMessage(String str) {
        Message result = handler.obtainMessage();
        Bundle data = new Bundle();
        data.putString(&quot;message&quot;, str);
        result.setData(data);
        return result;
    }
}
</code></pre><blockquote>
<p>当然，handler能做的远远不仅如此，由于它能post Runnable对象，它还能与Looper配合实现经典的Pipeline Thread(流水线线程)模式</p>
</blockquote>
<h4 id="封装任务Message"><a href="#封装任务Message" class="headerlink" title="封装任务Message"></a>封装任务Message</h4><blockquote>
<p>在整个消息处理机制中，message又叫task，封装了任务携带的信息和处理该任务的handler。message的用法比较简单，这里不做总结了。但是有这么几点需要注意（待补充）：</p>
<ul>
<li>尽管Message有public的默认构造方法，但是你应该通过Message.obtain()来从消息池中获得空消息对象，以节省资源。</li>
<li>如果你的message只需要携带简单的int信息，请优先使用Message.arg1和Message.arg2来传递信息，这比用Bundle更省内存</li>
<li>擅用message.what来标识信息，以便用不同方式处理message。</li>
</ul>
</blockquote>
<p><strong>参考资料</strong><br><a href="http://www.cnblogs.com/codingmyworld/archive/2011/09/12/2174255.html" target="_blank" rel="external">博文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;四个核心类&quot;&gt;&lt;a href=&quot;#四个核心类&quot; class=&quot;headerlink&quot; title=&quot;四个核心类&quot;&gt;&lt;/a&gt;四个核心类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Looper &lt;/li&gt;
&lt;li&gt;Handler &lt;/li&gt;
&lt;li&gt;Message &lt;/li&gt;
&lt;li
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Handler" scheme="http://yoursite.com/tags/Handler/"/>
    
      <category term="消息处理机制" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android的线程和线程池</title>
    <link href="http://yoursite.com/2016/07/01/Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2016/07/01/Android的线程和线程池/</id>
    <published>2016-07-01T02:36:34.000Z</published>
    <updated>2016-10-10T06:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>线程：在操作系统（OS）中，线程是OS调度的最小单元，同时又是一种受限的系统资源，不可能无限制的产生，并且其创建和销毁都会有一定的开销。当OS中存在大量的线程时，OS会通过时间片轮询的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数目小于等于CPU的核心数，一般是不可能的。</p>
<p>线程池：在一个进程中频繁地创建和销毁线程不是一种高效的做法，正确地做法是使用线程池。线程池中会缓存一定数目的线程，然后通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。Android中的线程池来源于Java，主要是通过Executor来派生特定类型的线程池，不同类型的线程池又具有不同的特性。</p>
<p>按用途来划分，线程有两种：</p>
</blockquote>
<ul>
<li>主线程：处理和界面有关的事情</li>
<li>子线程：执行耗时的一些操作</li>
</ul>
<blockquote>
<p>由于Android的特性，如果在主线程中执行耗时操作，系统会无法及时地响应，并抛出ANR（应用程序无响应），因此，耗时操作必须要放在子线程中执行。</p>
<p>除了传统的Java中的Thread类表示线程外，在Android中，系统提供了自己特有的可以扮演线程角色的类，如AsyncTask，IntentService，HandlerThread（一种特殊的线程）等，需要注意的是这些类本质上仍是创痛的线程，AsyncTask底层用到了Java中的线程池，而IntentService和HandlerThread的底层则直接使用了Thread线程类。</p>
</blockquote>
<ul>
<li>AsyncTask封装了线程池和Handler，主要是方便开发者在子线程中更新UI。</li>
<li>HandlerThread是一个具有消息循环的线程，在它的内部可以使用Handler。</li>
<li>IntentService是一个服务，系统对其进行了封装，使其可以方便地执行后台任务，IntentService内部采用HandlerThread来执行任务，任务执行完毕后，其会自动退出。从任务执行的角度来看，IntentService的作用很像一个后台线程，但是IntentService是一种服务，它是不容易被系统杀死的，从而尽量保证任务的执行，而如果是一个后台线程的话，由于这个时候进程中没有活动的四大组件，那么这个进程的优先级就会非常低，会很容易被系统杀死，这是IntentService的优点。</li>
</ul>
<h3 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h3><blockquote>
<p>Android沿用Java的线程模型。</p>
</blockquote>
<h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><blockquote>
<p>主线程(UI线程)是指进程所拥有的线程，在Java中默认情况下一个进程只有一个线程，这个线程就是主线层。主线程的主要任务是处理于界面的交互相关的逻辑，在Android中就是运行四大组件以及处理和它们的交互，因为用户随时会和界面发生交互，因此主线程在任何时候都必须具有较高的响应速度，否则就会造成界面卡顿，用户体验不好。</p>
</blockquote>
<h4 id="子线程"><a href="#子线程" class="headerlink" title="子线程"></a>子线程</h4><blockquote>
<p>为了保持较高的响应速度，在主线程中就不应该执行耗时任务，这个时候子线程的作用就体现出来了。子线程又被称为工作线程，除了主线程外，其他的都是子线程。子线程就是要执行耗时任务，如网络请求，I/O操作等。Android3.0以后的系统都要求网络访问必须在子线程中进行，否则就会访问失败并抛出NetworkOnMainThreadException异常，这么做主要是避免主线程被耗时任务阻塞，造成ANR。</p>
</blockquote>
<h3 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h3><blockquote>
<p>除去传统的Thread， Android中的线程形态有AsyncTask，IntentService，HandlerThread三种，它们的底层实现也是线程，只是它们具有特殊的表现形式，同时在使用上也各有优缺点。</p>
</blockquote>
<h4 id="AsyncTask及其原理"><a href="#AsyncTask及其原理" class="headerlink" title="AsyncTask及其原理"></a>AsyncTask及其原理</h4><blockquote>
<p>为了简化子线程中访问UI的过程，系统提供了AsyncTask。不同版本API的AsyncTask具有不同的表现，尤其是在多任务并发执行上。</p>
<p>AsyncTask是一种轻量级的异步任务类，可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程中更新UI。从实现上说，AsyncTask封装了Thread和Handler，并通过AsyncTask可以更加方便的执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合执行特别耗时的后台任务，对于特别耗时的任务，建议使用线程池。</p>
<p>AsyncTask是一个抽象范型类，使用时要通过子类继承，其提供了Params，Progress，Result三个范型参数，其中Params表示参数的类型，Progress表示后台任务执行进度的类型，Result表示后台任务的返回结果类型，如果AsyncTask确实不需要传递任何参数，这三个范型参数可以使用Void来代替。AysncTask的类声明如下：</p>
</blockquote>
<pre><code>public abstract class AsyncTask&lt;Params, Progress, Result&gt;
</code></pre><blockquote>
<p>AsyncTask提供了4个核心方法，具体解释如下：</p>
</blockquote>
<ol>
<li>onProExecute(), 在主线程中执行，在异步任务执行之前，此方法会被调用，一般用于一些准备工作。</li>
<li>doInBackground(Params … params), 在线程池中执行，用于执行异步任务，params参数表示异步任务的输入参数。在此方法中可以通过调用publishProgress()方法来更新任务的进度， publishProgress()方法会触发onProgressUpdate()方法的调用。另外此方法需要返回计算结果给onPostExecute()方法。</li>
<li>onProgressUpdate(Progress … values), 在主线程中执行，当后台任务的执行进度发生改变时，此方法通过publishProgress()方法被调用。</li>
<li>onPostExecute(Result result), 在主线程中执行，当后台异步任务执行完毕之后，此方法会被调用，其中，result参数时后台异步任务的返回值，即doInBackground方法的返回值。</li>
</ol>
<blockquote>
<p>4个方法的执行顺序是：onPreExecute, doInBackground, onPostExecute. onProgressUpdate方法看情况执行，如果publishProgress方法在doInBackground方法中被调用，其执行顺序就在onPostExecute之前，否则，其不执行。除了上述4个方法外，AsyncTask也提供onCancelled()方法，当异步任务被取消时，onCancelled()方法会在主线程中被调用执行，这个时候onPostExecute方法就不会再被调用。</p>
</blockquote>
<p><strong>典型案例</strong></p>
<pre><code>private class DownLoadAsyncTask extends AsyncTask&lt;URL, Integer, Long&gt; {
    protected Long doInBackground(URL ... urls) {
        int count = urls.length;
        long totalsize = 0;
        for(int i = 0; i &lt; count; i++) {
            totalsize += Downloader.down(urls[i]);
            publishProgress((int) ((i / (float) count * 100));
            // Escape early if cancel() is called
            if(isCancelled()) {
                break;
            }
        }
        return totalsize;
    }
    protected void onProgressUpdate(Integer ... progress) {
        setProgressPercent(progress[0]);
    }
    protected void onPostExecute(Long result) {
        showDialog(&quot;Downloaded&quot; + result + &quot;bytes&quot;);
    }
}
</code></pre><blockquote>
<p>上面实现了一个具体的AsyncTask类，主要功能时模拟文件下载的过程，输入参数类型为URL，后台任务进程参数为Integer，后台任务的返回结果为Long类型。注意一点：括号中的 … 表示参数个数不定，它代表一种数组型的参数，在这点上Java和C是一致的。</p>
<p>具体的AsyncTask类定义完成后，当要执行下载任务时，通过下面方式完成：</p>
</blockquote>
<pre><code>AsyncTask task = new DownloadAsyncTask();
task.execute(url1,url2,url3);
</code></pre><p><strong>AsyncTask在具体的使用过程中的一些条件限制：</strong></p>
<ol>
<li>AsyncTask的类必须在主线程中加载，这意味着第一次访问AsyncTask必须发生在主线程，当然这个过程在Android4.1及以上的版本中已经被系统自动完成。在5.0的源码中，可以看到在ActivityThread的main方法中会调用AsyncTask的init方法，这就满足了这个限制条件。至于为什么必须满足这个条件，在下面小节的原理分析中会给予解答。<ol>
<li>AsyncTask实现类的对象必须在主线程中创建。</li>
<li>AsyncTask实现类的execute()方法也必须在主线程中被调用。</li>
<li>不要在程序中手动直接调用onPreExecute(), doInBackground(), onPostExecute(), onProgressUpdate()这四个方法。</li>
<li>一个AsyncTask实现类对象只能执行一次，即只能调用一次execute()方法，否则会报异常。</li>
<li>Android1.6之前，AsyncTask是串行执行任务的，1.6的时候开始采用线程池处理并行任务，但是从3.0开始，为了避免AsyncTask所带来的并发错误，其又再一次采用一个线程来串行执行任务。尽管如此，3.0以后的版本中，我们仍然可以通过AsyncTask的executeOnExecuter方法来并行执行任务。</li>
</ol>
</li>
</ol>
<h4 id="AsyncTask的工作原理"><a href="#AsyncTask的工作原理" class="headerlink" title="AsyncTask的工作原理"></a>AsyncTask的工作原理</h4><blockquote>
<p>待完成</p>
</blockquote>
<h4 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h4><blockquote>
<p>HandlerThread继承了Thread，是一种可以使用Handler的Thread，它的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了。</p>
<p>HandlerThread的run方法如下所示：</p>
</blockquote>
<pre><code>public void run() {
    mTid = Process.myTid();
    Looper.prepare();
    synchrinized(this) {
        mLooper = Looper.myLooper();
        notifyAll();
    }
    Process.setThreadPriority(mPriority);
    onLooperPrepared();
    Looper.loop();
    mTid = -1;
}
</code></pre><blockquote>
<p>从HandlerThread的实现来看，它和普通的Thread有显著的不同，普通的Thread主要用于在run方法中执行一个耗时任务，而HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式来通知HandlerThread执行一个具体的任务。HandlerThread类是一个很有用的类，它在Android中的一个具体应用场景就是IntentService，将在下节介绍。由于HandlerThread的run方法是一个无限循环，因此当明确不需要再使用的时候，可以通过它的quit或者quitSafely方法来终止线程的执行，好的编程习惯。</p>
</blockquote>
<h4 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h4><blockquote>
<p>Todo</p>
</blockquote>
<h3 id="Android中的线程池"><a href="#Android中的线程池" class="headerlink" title="Android中的线程池"></a>Android中的线程池</h3><p><strong>线程池的优点</strong></p>
<ol>
<li>重用线程池中的线程，避免因为创建线程和销毁线程带来不必要的内存开销。</li>
<li>能有效控制线程池中的最大并发数，避免大量的线程之间因互相抢占资源而导致的阻塞现象。</li>
<li>能够对线程池进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ol>
<blockquote>
<p>Android中线程池的概念来自Java中的Executer，Executer是一个接口，真正的线程池实现为ThreadPoolExecuter，其提供了一系列的参数来配置线程池，通过不同的参数可以查创建不同的线程池。从线程池的功能特性上来说，Android的线程池有4类，并且可以通过Executers所提供的工厂方法来得到。</p>
</blockquote>
<h4 id="ThreadPoolExecuter"><a href="#ThreadPoolExecuter" class="headerlink" title="ThreadPoolExecuter"></a>ThreadPoolExecuter</h4><blockquote>
<p>ThreadPoolExecuter是线程池的真正实现，它的构造方法提供了一系列参数来配置线程池。下面是其一个比较常用的构造方法，构造方法中的参数会直接影响线程池的功能特性。</p>
</blockquote>
<pre><code>public ThreadPoolExecutor(
        int corePoolSize, 
        int maximumPoolSize, 
        long keepAliveTime, 
        TimeUnit unit, 
        BlockingQueue&lt;Runnable&gt; workQueue, 
        ThreadFactory threadFactory
)
</code></pre><blockquote>
<p>下面会介绍各个参数的具体用法</p>
</blockquote>
<ul>
<li>corePoolSize</li>
</ul>
<blockquote>
<p>线程池的核心线程数目，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔由keepAliveTime所指定，当等待时间超过keepAliveTime所指定的时长后，核心线程就会被终止。</p>
</blockquote>
<ul>
<li>maximumPoolSize</li>
</ul>
<blockquote>
<p>线程池所能容纳的最大线程数，当活动线程数达到这个数值后，后续的新任务将会被阻塞。</p>
</blockquote>
<ul>
<li>keepAliveTime</li>
</ul>
<blockquote>
<p>非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。当ThreadPoolExecutor的allowCoreThreadTimeOut这个属性设置为true时，keepAliveTime同样会作用于核心线程。</p>
</blockquote>
<ul>
<li>unit</li>
</ul>
<blockquote>
<p>用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的TimeUnit.MILLISECONDS(毫秒), TimeUnit.SECONDS(秒), TimeUnit.MINUTES(分钟)等。</p>
</blockquote>
<ul>
<li>workQueue</li>
</ul>
<blockquote>
<p>线程池中的任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中。</p>
</blockquote>
<ul>
<li>threadFactory</li>
</ul>
<blockquote>
<p>线程工厂，为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个方法，Thread  newThread(Runnable r).</p>
<p>除了上面的这些主要参数外，还有一个不常用的参数RejectedExecutionHandler handler。当线程池无法执行新任务时，这可能是由于任务队列已满或者是无法成功执行任务，这个时候ThreadPoolExecutor会调用handler的rejectedExecution方法来通知调用者，默认情况下rejectedExecution方法会直接抛出一个RejectedExecutionException。ThreadPoolExecutor为RejectedExecutionHandler提供了几个可选值：CallerRunsPolicy，AbortPolicy，DiscardPolicy和DiscardOldestPolicy，其中AbortPolicy是默认值，它会直接抛出RejectedExecutionException。</p>
<p>ThreadPoolExecutor执行任务时大致遵循如下规则：</p>
</blockquote>
<ol>
<li>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li>
<li>如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</li>
<li>如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</li>
<li>如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。</li>
</ol>
<blockquote>
<p>ThreadPoolExecutor的参数配置在AsyncTask中有明显的体现，如下：</p>
</blockquote>
<pre><code>private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
private static final int CORE_POOL_SIZE = CPU_COUNT + 1;
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE = 1;

private static final ThreadFactory sThreadFactory = new ThreadFactory() {
    private final AtomicInteger mCount = new AtomicInteger(1);
    public Thread newThread(Runnable r) {
        return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement());
    }
}

private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);

/**
 * An Executor that can be used to execute tasks in parallel
 **/
public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);
</code></pre><blockquote>
<p>从上面的代码可以知道，AsyncTask对THREAD_POOL_EXECUTOR这个线程池进行了配置，配置后的线程池规格如下：</p>
</blockquote>
<ul>
<li>核心线程池等于CPU核心数+1</li>
<li>线程池的最大线程数为CPU核心数的2倍+1</li>
<li>核心线程无超时机制，非核心线程在闲置时的超时时间为1秒</li>
<li>任务队列的容量为128</li>
</ul>
<h4 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h4><blockquote>
<p>Android中常见的四类不同功能特性的线程池，都是通过直接或间接的配置ThreadPoolExecutor的参数来实现具有不同功能特性的线程池。</p>
</blockquote>
<h5 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h5><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre><blockquote>
</blockquote>
<h5 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h5><pre><code>public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L,TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre><h5 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h5><pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
}

public static ScheduledThreadPoolExecutor (int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0 ,NANOSECONDS, new DelayedWorkQueue());
}
</code></pre><h5 id="SingleThreadPool"><a href="#SingleThreadPool" class="headerlink" title="SingleThreadPool"></a>SingleThreadPool</h5><pre><code>public static ExecutorService newSingleThreadPool() {
        return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre><p><strong>系统预置的四种线程池的典型使用方法</strong></p>
<pre><code>Runnable command = new Runnable() {
        @Override
        public void run() {
            SystemClock.sleep(2000);
        }
}

ExecutorService fixedThreadPool = Executors.newFixedThreadPool(4);
fixedThreadPool.execute(command);

ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
cachedThreadPool.execute(command);

ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(4);
// 2000ms后执行command
scheduledThreadPool.schedule(command, 2000, TimeUnit.MILLISECONDS);
// 延迟10ms后，每隔1000ms执行一次command
scheduledThreadPool.scheduleAtFixedRate(command, 10, 1000, TimeUnit.MILLISECONDS);

ExecutorService singleThreadPool = Executors.newSingleThreadPool();
singleThreadPool.execute(command);
</code></pre><p><strong>参考资料</strong></p>
<p>《Android开发艺术探索》 —  任玉刚</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;线程：在操作系统（OS）中，线程是OS调度的最小单元，同时又是一种受限的系统资源，不可能无限制的产生，并且其创建和
    
    </summary>
    
      <category term="学习记录" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
</feed>
