<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>sh2zqp</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Android开发爱好者">
<meta property="og:type" content="website">
<meta property="og:title" content="sh2zqp">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="sh2zqp">
<meta property="og:description" content="Android开发爱好者">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sh2zqp">
<meta name="twitter:description" content="Android开发爱好者">
  
    <link rel="alternate" href="/atom.xml" title="sh2zqp" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">sh2zqp</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Keep Learning</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android事件分发机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/01/Android事件分发机制/" class="article-date">
  <time datetime="2016-10-01T01:54:33.000Z" itemprop="datePublished">2016-10-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习记录/">学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/01/Android事件分发机制/">Android事件分发机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>ViewGroup是一组View的集合，它包含很多的子View和子ViewGroup，是Android中所有布局的父类或间接父类，像LinearLayout、RelativeLayout等都是继承自ViewGroup的。但ViewGroup实际上也是一个View，只不过比起View，它多了可以包含子View和定义布局参数的功能。这里按照View和ViewGroup两种情况去分析，其中，View特指不是容器的组件，而ViewGroup则是一个容器，里面可以包含前者的非容器View和ViewGroup。</strong></p>
<ul>
<li>View 的事件分发</li>
<li>ViewGroup 的事件分发</li>
<li>总结</li>
</ul>
<hr>
<h2 id="View-的事件分发"><a href="#View-的事件分发" class="headerlink" title="View 的事件分发"></a>View 的事件分发</h2><blockquote>
<p>定义一个Activity，其布局中只有一个按钮，并给按钮注册一个点击事件，如下：</p>
</blockquote>
<pre><code>button.setOnClickListener(new OnClickListener() {  
    @Override  
    public void onClick(View v) {  
        Log.d(&quot;TAG&quot;, &quot;onClick execute&quot;);  
    }  
});
</code></pre><blockquote>
<p>按钮被点击，onClick方法执行。然后再给按钮再添加一个touch事件，如下：</p>
</blockquote>
<pre><code>button.setOnTouchListener(new OnTouchListener() {  
    @Override  
    public boolean onTouch(View v, MotionEvent event) {  
        Log.d(&quot;TAG&quot;, &quot;onTouch execute, action &quot; + event.getAction());  
        return false;  
    }  
});  
</code></pre><blockquote>
<p>onTouch方法能够执行的逻辑要更复杂一些，如判断手指按下、抬起、移动等事件。</p>
</blockquote>
<p><strong>问题来了，哪一个会先执行呢？</strong></p>
<blockquote>
<p>运行程序点击按钮，打印结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130614230234671" alt=""></p>
<blockquote>
<p>结果证明：onTouch是优先于onClick执行，并且onTouch执行了两次，一次是ACTION_DOWN，一次是ACTION_UP(你还可能会有多次ACTION_MOVE的执行，如果你手抖了一下)。</p>
<p>因此事件传递的顺序是先经过onTouch，再传递到onClick。</p>
</blockquote>
<p><strong>为什么会这样？</strong></p>
<blockquote>
<p>查看onTouch方法，发现其有返回值的，上面返回的是false。</p>
</blockquote>
<p><strong>如果返回true呢？</strong></p>
<blockquote>
<p>再次运行，结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130614231001468" alt=""></p>
<blockquote>
<p>onClick方法不再执行了！为什么会这样呢？</p>
<p>可以暂时理解成onTouch方法返回true就认为这个事件被onTouch消费掉了，因而不会再继续向下传递。</p>
<p>当然，我们不会仅仅满足于此，让我们深层次的去看看出现上述现象的原理到底是什么？</p>
<p>首先，你触摸到了任何控件，那一定会调用该控件的dispatchTouchEvent方法。当点击按钮的时，就会去调用Button的dispatchTouchEvent方法，可Button里没有这个方法，那就去它父类TextView里找，发现TextView也没有，继续在TextView的父类View里找，Bingo，终于找到了。</p>
<p>然后，重点来了，看一下View中dispatchTouchEvent方法的源码吧！</p>
</blockquote>
<pre><code>public boolean dispatchTouchEvent(MotionEvent event) {  
    if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  
            mOnTouchListener.onTouch(this, event)) {  
        return true;  
    }  
    return onTouchEvent(event);  
}  
</code></pre><blockquote>
<p>简洁，只有几行代码！先是一个判断，如果mOnTouchListener != null，(mViewFlags &amp; ENABLED_MASK) == ENABLED和mOnTouchListener.onTouch(this, event)这三个条件都为真，就返回true，否则就去执行onTouchEvent(event)方法并返回。_</p>
<p>第一个条件，mOnTouchListener变量是在哪赋值的呢？寻找之后在View里发现了如下方法：</p>
</blockquote>
<pre><code>public void setOnTouchListener(OnTouchListener l) {  
    mOnTouchListener = l;  
}  
</code></pre><blockquote>
<p>Bingo！mOnTouchListener是在这里赋值的，也就是说，只要给控件注册了touch事件，mOnTouchListener就一定被赋值了，也就不为null了。</p>
<p>第二个条件，(mViewFlags &amp; ENABLED_MASK) == ENABLED，判断当前点击的控件是否是enable的，按钮默认都是enable的，因此这个条件恒定为true。_</p>
<p>第三个条件，mOnTouchListener.onTouch(this, event)，关键点，回调控件注册touch事件时的onTouch方法。如果在onTouch方法里返回true，这三个条件全部成立，从而整个方法直接返回true。如果在onTouch方法里返回false，就会再去执行onTouchEvent(event)方法。</p>
<p>结合前面的例子综合分析一下，先在dispatchTouchEvent中最先执行的是onTouch方法，因此onTouch要先于onClick执行，也印证了刚刚的打印结果。而如果在onTouch方法里返回了true，就会让dispatchTouchEvent方法直接返回true，不会再继续往下执行。而打印结果也证实了如果onTouch返回true，其onTouchEvent(event)方法也就不再执行了， onClick也就不会再执行了(后面我们知道，onClick方法就是在onTouchEvent(event)方法里执行的)。</p>
<p>根据以上分析，从原理上解释了前面例子的运行结果。那我们就来看下onTouchEvent的源码，看看onClick方法是不是真的在里面，如下所示：</p>
</blockquote>
<pre><code>1.  public boolean onTouchEvent(MotionEvent event) {  
2.      final int viewFlags = mViewFlags;  
3.      if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {  
4.          // A disabled view that is clickable still consumes the touch  
5.          // events, it just doesn&apos;t respond to them.  
6.          return (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  
7.                  (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));  
8.      }  
9.      if (mTouchDelegate != null) {  
10.         if (mTouchDelegate.onTouchEvent(event)) {  
11.             return true;  
12.         }  
13.     }  
14.     if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  
15.             (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {  
16.         switch (event.getAction()) {  
17.             case MotionEvent.ACTION_UP:  
18.                 boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0;  
19.                 if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) {  
20.                     // take focus if we don&apos;t have it already and we should in  
21.                     // touch mode.  
22.                     boolean focusTaken = false;  
23.                     if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {  
24.                         focusTaken = requestFocus();  
25.                     }  
26.                     if (!mHasPerformedLongPress) {  
27.                         // This is a tap, so remove the longpress check  
28.                         removeLongPressCallback();  
29.                         // Only perform take click actions if we were in the pressed state  
30.                         if (!focusTaken) {  
31.                             // Use a Runnable and post this rather than calling  
32.                             // performClick directly. This lets other visual state  
33.                             // of the view update before click actions start.  
34.                             if (mPerformClick == null) {  
35.                                 mPerformClick = new PerformClick();  
36.                             }  
37.                             if (!post(mPerformClick)) {  
38.                                 performClick();  
39.                             }  
40.                         }  
41.                     }  
42.                     if (mUnsetPressedState == null) {  
43.                         mUnsetPressedState = new UnsetPressedState();  
44.                     }  
45.                     if (prepressed) {  
46.                         mPrivateFlags |= PRESSED;  
47.                         refreshDrawableState();  
48.                         postDelayed(mUnsetPressedState,  
49.                                 ViewConfiguration.getPressedStateDuration());  
50.                     } else if (!post(mUnsetPressedState)) {  
51.                         // If the post failed, unpress right now  
52.                         mUnsetPressedState.run();  
53.                     }  
54.                     removeTapCallback();  
55.                 }  
56.                 break;  
57.             case MotionEvent.ACTION_DOWN:  
58.                 if (mPendingCheckForTap == null) {  
59.                     mPendingCheckForTap = new CheckForTap();  
60.                 }  
61.                 mPrivateFlags |= PREPRESSED;  
62.                 mHasPerformedLongPress = false;  
63.                 postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  
64.                 break;  
65.             case MotionEvent.ACTION_CANCEL:  
66.                 mPrivateFlags &amp;= ~PRESSED;  
67.                 refreshDrawableState();  
68.                 removeTapCallback();  
69.                 break;  
70.             case MotionEvent.ACTION_MOVE:  
71.                 final int x = (int) event.getX();  
72.                 final int y = (int) event.getY();  
73.                 // Be lenient about moving outside of buttons  
74.                 int slop = mTouchSlop;  
75.                 if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) ||  
76.                         (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) {  
77.                     // Outside button  
78.                     removeTapCallback();  
79.                     if ((mPrivateFlags &amp; PRESSED) != 0) {  
80.                         // Remove any future long press/tap checks  
81.                         removeLongPressCallback();  
82.                         // Need to switch from pressed to not pressed  
83.                         mPrivateFlags &amp;= ~PRESSED;  
84.                         refreshDrawableState();  
85.                     }  
86.                 }  
87.                 break;  
88.         }  
89.         return true;  
90.     }  
91.     return false;  
92. } 
</code></pre><p><strong>比较长，挑重点看</strong></p>
<blockquote>
<p>在第14行我们可以看出，如果该控件是可以点击的就会进入到第16行的switch判断中去，而如果当前的事件是抬起手指，则会进入到MotionEvent.ACTION_UP这个case当中。在经过种种判断之后，会执行到第38行的performClick()方法，那就看看这个方法：_</p>
</blockquote>
<pre><code>public boolean performClick() {  
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  
    if (mOnClickListener != null) {  
        playSoundEffect(SoundEffectConstants.CLICK);  
        mOnClickListener.onClick(this);  
        return true;  
    }  
    return false;  
} 
</code></pre><p><strong>舒服多了</strong></p>
<blockquote>
<p>看到mOnClickListener.onClick(this)，我们就更开心了，只要mOnClickListener不是null，就会去调用它，那mOnClickListener又是在哪里赋值的呢？看下面：</p>
</blockquote>
<pre><code>public void setOnClickListener(OnClickListener l) {  
    if (!isClickable()) {  
        setClickable(true);  
    }  
    mOnClickListener = l;  
}  
</code></pre><blockquote>
<p>一切都清楚了！当调用setOnClickListener方法来给控件注册一个点击事件时，就会给mOnClickListener赋值。然后每当控件被点击时，都会在performClick()方法里回调被点击控件的onClick方法。</p>
<p>整个事件分发的流程似乎就这样要结束了，不，还有一个要重点说明的是touch事件的层级传递。如果给一个控件注册了touch事件，每次点击它的时候都会触发一系列的ACTION_DOWN，ACTION_MOVE，ACTION_UP等事件，简称为事件流，请注意，如果你在执行ACTION_DOWN的时候返回了false，那么这个事件流就会被中断执行。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个action事件返回true，才会触发后一个action 事件。</p>
</blockquote>
<p><strong>这不是自相矛盾吗？</strong></p>
<blockquote>
<p>前面的例子中，明明在onTouch事件里面返回了false，ACTION_DOWN和ACTION_UP不是都得到执行了吗？其实你只是被假象所迷惑了，仔细分析一下代码，就会知道在前面的例子当中，我们到底返回的是什么。首先在onTouch事件里返回了false，就一定会进入到onTouchEvent方法中，然后我们来看一下onTouchEvent方法的细节。_由于点击了按钮且按钮是可点击的_，就会进入到第14行这个if判断的内部，然后你会发现，不管当前的action是什么，最终都一定会走到第89行，返回一个true。</p>
</blockquote>
<p><strong>是不是有一种被欺骗的感觉？</strong></p>
<blockquote>
<p>明明在onTouch事件里返回了false，系统还是在onTouchEvent方法中帮你返回了true。就因为这个原因，才使得前面的例子中ACTION_UP可以得到执行。_</p>
<p>我们可以换一个控件，将按钮替换成ImageView，然后给它也注册一个touch事件，并返回false。如下所示：</p>
</blockquote>
<pre><code>imageView.setOnTouchListener(new OnTouchListener() {  
    @Override  
    public boolean onTouch(View v, MotionEvent event) {  
        Log.d(&quot;TAG&quot;, &quot;onTouch execute, action &quot; + event.getAction());  
        return false;  
    }  
});  
</code></pre><blockquote>
<p>运行程序，点击ImageView，结果如下</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130617193504328" alt=""></p>
<blockquote>
<p>在ACTION_DOWN执行完后，后面的一系列action事件都不会得到执行了。这又是为什么呢？因为ImageView和按钮不同，它是默认不可点击的，因此在onTouchEvent的第14行判断时无法进入到if的内部，直接跳到第91行返回了false，也就导致后面其它的action都无法执行了。View的事件分发，就到这里。</p>
</blockquote>
<hr>
<h2 id="ViewGroup的事件分发"><a href="#ViewGroup的事件分发" class="headerlink" title="ViewGroup的事件分发"></a>ViewGroup的事件分发</h2><blockquote>
<p>首先，自定义一个布局为MyLayout，继承自LinearLayout，如下：</p>
</blockquote>
<pre><code>public class MyLayout extends LinearLayout {  
    public MyLayout(Context context, AttributeSet attrs) {  
        super(context, attrs);  
    }  
}  
</code></pre><blockquote>
<p>然后，打开布局文件activity_main.xml，在其中加入自定义的布局MyLayout，如下：</p>
</blockquote>
<pre><code>&lt;com.example.viewgrouptouchevent.MyLayout 
        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:id=&quot;@+id/my_layout&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    android:orientation=&quot;vertical&quot; &gt;  
    &lt;Button  
        android:id=&quot;@+id/button1&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Button1&quot; /&gt;  
    &lt;Button  
        android:id=&quot;@+id/button2&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Button2&quot; /&gt;  
&lt;/com.example.viewgrouptouchevent.MyLayout&gt;  
</code></pre><blockquote>
<p>在MyLayout中添加了两个按钮，最后在MainActivity中为这两个按钮和MyLayout注册监听事件：</p>
</blockquote>
<pre><code>myLayout.setOnTouchListener(new OnTouchListener() {  
    @Override  
    public boolean onTouch(View v, MotionEvent event) {  
        Log.d(&quot;TAG&quot;, &quot;myLayout on touch&quot;);  
        return false;  
    }  
});  
button1.setOnClickListener(new OnClickListener() {  
    @Override  
    public void onClick(View v) {  
        Log.d(&quot;TAG&quot;, &quot;You clicked button1&quot;);  
    }  
});  
button2.setOnClickListener(new OnClickListener() {  
    @Override  
    public void onClick(View v) {  
        Log.d(&quot;TAG&quot;, &quot;You clicked button2&quot;);  
    }  
});  
</code></pre><blockquote>
<p>运行项目，分别点击一下Button1、Button2和空白区域，打印结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130629144048875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<blockquote>
<p>当点击按钮的时，MyLayout注册的onTouch方法并不会执行，只有点击空白区域的时候才会执行该方法。可以先暂时理解成Button的onClick方法将事件消费掉了，因此事件不会再继续向下传递。</p>
<p>Android中的touch事件是先传递到View，再传递到ViewGroup的？</p>
</blockquote>
<p><strong>结论下的太早，做个实验</strong></p>
<blockquote>
<p>ViewGroup中有一个onInterceptTouchEvent方法，我们来看一下这个方法的源码：</p>
</blockquote>
<pre><code>public boolean onInterceptTouchEvent(MotionEvent ev) {  
    return false;  
} 
</code></pre><p><strong>还是这么短(注释已略去)</strong></p>
<blockquote>
<p>只有一行代码，返回一个false！既然是布尔型的返回，那么只有两种可能，我们在MyLayout中重写这个方法，然后分布返回一个true和false试试，代码如下所示：</p>
</blockquote>
<pre><code>public class MyLayout extends LinearLayout {  
    public MyLayout(Context context, AttributeSet attrs) {  
        super(context, attrs);  
    }  
    @Override  
    public boolean onInterceptTouchEvent(MotionEvent ev) {  
        return true;  
    }  
}  
</code></pre><blockquote>
<p>运行项目，分别Button1、Button2和空白区域，打印结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130629145544984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<blockquote>
<p>奇怪了，不管点哪里，永远都只会触发MyLayout的touch事件了，按钮的点击事件完全被屏蔽掉了！</p>
</blockquote>
<p><strong>这是为什么？</strong></p>
<blockquote>
<p>如果Android中的touch事件是先传递到View，再传递到ViewGroup的，那么MyLayout又怎么可能屏蔽掉Button的点击事件呢？</p>
<p>看来只有通过源码，才能搞清Android中ViewGroup的事件分发机制，解决心中疑惑，不过结论一定是：<strong>Android中touch事件的传递，绝对是先传递到ViewGroup，再传递到View的。</strong></p>
<p>在上一小节中，我们说过只要你触摸了任何控件，就一定会调用该控件的dispatchTouchEvent方法。这个说法没错，只不过还不完整而已。实际是，当你点击了某个控件，首先会去调用该控件所在布局的dispatchTouchEvent方法，然后在布局的dispatchTouchEvent方法中找到被点击的相应控件，再去调用该控件的dispatchTouchEvent方法。如果我们点击了MyLayout中的按钮，会先去调用MyLayout的dispatchTouchEvent方法，可是你会发现MyLayout中并没有这个方法，那就去到它的父类LinearLayout中找，发现也没有这个方法，那就继续再找LinearLayout的父类ViewGroup，终于在ViewGroup中看到了这个方法，按钮的dispatchTouchEvent方法就是在这里调用的。</p>
<p>ViewGroup中的dispatchTouchEvent方法的源码如下：</p>
</blockquote>
<pre><code>1.  public boolean dispatchTouchEvent(MotionEvent ev) {  
2.      final int action = ev.getAction();  
3.      final float xf = ev.getX();  
4.      final float yf = ev.getY();  
5.      final float scrolledXFloat = xf + mScrollX;  
6.      final float scrolledYFloat = yf + mScrollY;  
7.      final Rect frame = mTempRect;  
8.      boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;  
9.      if (action == MotionEvent.ACTION_DOWN) {  
10.         if (mMotionTarget != null) {  
11.             mMotionTarget = null;  
12.         }  
13.         if (disallowIntercept || !onInterceptTouchEvent(ev)) {  
14.             ev.setAction(MotionEvent.ACTION_DOWN);  
15.             final int scrolledXInt = (int) scrolledXFloat;  
16.             final int scrolledYInt = (int) scrolledYFloat;  
17.             final View[] children = mChildren;  
18.             final int count = mChildrenCount;  
19.             for (int i = count - 1; i &gt;= 0; i--) {  
20.                 final View child = children[i];  
21.                 if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE  
22.                         || child.getAnimation() != null) {  
23.                     child.getHitRect(frame);  
24.                     if (frame.contains(scrolledXInt, scrolledYInt)) {  
25.                         final float xc = scrolledXFloat - child.mLeft;  
26.                         final float yc = scrolledYFloat - child.mTop;  
27.                         ev.setLocation(xc, yc);  
28.                         child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
29.                         if (child.dispatchTouchEvent(ev))  {  
30.                             mMotionTarget = child;  
31.                             return true;  
32.                         }  
33.                     }  
34.                 }  
35.             }  
36.         }  
37.     }  
38.     boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  
39.             (action == MotionEvent.ACTION_CANCEL);  
40.     if (isUpOrCancel) {  
41.         mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;  
42.     }  
43.     final View target = mMotionTarget;  
44.     if (target == null) {  
45.         ev.setLocation(xf, yf);  
46.         if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) {  
47.             ev.setAction(MotionEvent.ACTION_CANCEL);  
48.             mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
49.         }  
50.         return super.dispatchTouchEvent(ev);  
51.     }  
52.     if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) {  
53.         final float xc = scrolledXFloat - (float) target.mLeft;  
54.         final float yc = scrolledYFloat - (float) target.mTop;  
55.         mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
56.         ev.setAction(MotionEvent.ACTION_CANCEL);  
57.         ev.setLocation(xc, yc);  
58.         if (!target.dispatchTouchEvent(ev)) {  
59.         }  
60.         mMotionTarget = null;  
61.         return true;  
62.     }  
63.     if (isUpOrCancel) {  
64.         mMotionTarget = null;  
65.     }  
66.     final float xc = scrolledXFloat - (float) target.mLeft;  
67.     final float yc = scrolledYFloat - (float) target.mTop;  
68.     ev.setLocation(xc, yc);  
69.     if ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) {  
70.         ev.setAction(MotionEvent.ACTION_CANCEL);  
71.         target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
72.         mMotionTarget = null;  
73.     }  
74.     return target.dispatchTouchEvent(ev);  
75. }  
</code></pre><p><strong>挑重点看</strong></p>
<blockquote>
<p>首先，在第13行处有一个条件判断，如果disallowIntercept和!onInterceptTouchEvent(ev)两者有一个为true，就会进入到这个条件判断中。disallowIntercept是指是否禁用掉事件拦截的功能，默认是false，也可以通过调用requestDisallowInterceptTouchEvent方法对这个值进行修改。那么当第一个值为false的时候就会完全依赖第二个值来决定是否可以进入到条件判断的内部，第二个值是什么呢？竟然就是对onInterceptTouchEvent方法的返回值取反！也就是说如果我们在onInterceptTouchEvent方法中返回false，就会让第二个值为true，从而进入到条件判断的内部，如果我们在onInterceptTouchEvent方法中返回true，就会让第二个值为false，从而跳出了这个条件判断。</p>
<p>由于我们在MyLayout中重写了onInterceptTouchEvent方法，让这个方法返回true，导致所有按钮的点击事件都被屏蔽了，那我们就完全有理由相信，按钮点击事件的处理就是在第13行条件判断的内部进行的！那重点看下条件判断的内部是怎么实现的。在第19行通过一个for循环，遍历了当前ViewGroup下的所有子View，然后在第24行判断当前遍历的View是不是正在点击的View，如果是的话就会进入到该条件判断的内部，然后在第29行调用了该View的dispatchTouchEvent，之后就是上节讲的View的事件分发了。</p>
<p>然后需要注意，调用子View的dispatchTouchEvent后是有返回值的。我们已经知道，如果一个控件是可点击的，那么点击该控件时，dispatchTouchEvent的返回值必定是true。因此会导致第29行的条件判断成立，于是在第31行给ViewGroup的dispatchTouchEvent方法直接返回了true。这样就导致后面的代码无法执行到了，也是印证了我们前面的Demo打印的结果，如果按钮的点击事件得到执行，就会把MyLayout的touch事件拦截掉。</p>
<p>如果我们点击的不是按钮，而是空白区域呢？这种情况就一定不会在第31行返回true了，而是会继续执行后面的代码。那我们继续往后看，在第44行，如果target等于null，就会进入到该条件判断内部，这里一般情况下target都会是null，因此会在第50行调用super.dispatchTouchEvent(ev)。这句代码会调用到哪里呢？当然是View中的dispatchTouchEvent方法了，因为ViewGroup的父类就是View。之后的处理逻辑又和前面所说的是一样的了，也因此MyLayout中注册的onTouch方法会得到执行。之后的代码在一般情况下是走不到的了，我们也就不再继续往下分析。</p>
<p>ViewGroup事件分发过程的流程图如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130629200236578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<blockquote>
<p>现在整个ViewGroup的事件分发流程的分析也就到此结束了，我们最后再来简单梳理一下吧。</p>
</blockquote>
<ol>
<li>Android事件分发是先传递到ViewGroup，再由ViewGroup传递到View的。</li>
<li>在ViewGroup中可以通过onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。</li>
<li>子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>onTouch和onTouchEvent区别，如何使用？</li>
</ol>
<blockquote>
<p>这两个方法都是在View的dispatchTouchEvent中调用的，onTouch先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一，mOnTouchListener的值不能为空，第二，当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。</p>
</blockquote>
<ol>
<li>为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？</li>
</ol>
<blockquote>
<blockquote>
<p>滑动菜单的功能是通过给ListView注册了一个touch事件来实现的。如果你在onTouch方法里处理完了滑动逻辑后返回true，那么ListView本身的滚动事件就被屏蔽了，自然也就无法滑动，因此解决办法就是在onTouch方法里返回false。</p>
</blockquote>
</blockquote>
<ol>
<li>为什么图片轮播器里的图片使用Button而不用ImageView？</li>
</ol>
<blockquote>
<p>因为Button是可点击的，而ImageView是不可点击的。如果想要使用ImageView，可以有两种改法。第一，在ImageView的onTouch方法里返回true，这样可以保证ACTION_DOWN之后的其它action都能得到执行，才能实现图片滚动的效果。第二，在布局文件里面给ImageView增加一个android:clickable=”true”的属性，这样ImageView变成可点击的之后，即使在onTouch里返回了false，ACTION_DOWN之后的其它action也是可以得到执行的。</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h3><p><a href="http://blog.csdn.net/sinyu890807/article/details/9097463" target="_blank" rel="external">http://blog.csdn.net/sinyu890807/article/details/9097463</a><br><a href="http://blog.csdn.net/sinyu890807/article/details/9153747" target="_blank" rel="external">http://blog.csdn.net/sinyu890807/article/details/9153747</a><br>《Android开发艺术探索》—— <a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="external">任玉刚</a><br>《Android群英传》——<a href="http://blog.csdn.net/eclipsexys" target="_blank" rel="external"> 徐宜生</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/01/Android事件分发机制/" data-id="civaavwkq0009or9ybtrta064" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/事件分发/">事件分发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android消息处理机制 — 实用易懂(1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/05/Android消息处理机制 — 实用易懂(1)/" class="article-date">
  <time datetime="2016-08-05T09:40:41.000Z" itemprop="datePublished">2016-08-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习记录/">学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/05/Android消息处理机制 — 实用易懂(1)/">Android消息处理机制 — 实用易懂(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="四个核心类"><a href="#四个核心类" class="headerlink" title="四个核心类"></a>四个核心类</h3><ul>
<li>Looper </li>
<li>Handler </li>
<li>Message </li>
<li>MessageQueue(MQ被封装到Looper里面了，我们不会直接与MQ打交道)</li>
</ul>
<h3 id="核心类详解"><a href="#核心类详解" class="headerlink" title="核心类详解"></a>核心类详解</h3><h4 id="线程控制者Looper"><a href="#线程控制者Looper" class="headerlink" title="线程控制者Looper"></a>线程控制者Looper</h4><blockquote>
<p>Looper的字面意思是“循环者”，它被设计用来使一个普通线程变成Looper线程。所谓Looper线程就是循环工作的线程。在程序开发中（尤其是GUI开发中），我们经常会需要一个线程不断循环，一旦有新任务则执行，执行完继续等待下一个任务，这就是Looper线程。使用Looper类创建Looper线程很简单：</p>
</blockquote>
<pre><code>public class LooperThread extends Thread {
    @Override
    public void run() {
        // 将当前线程初始化为Looper线程
        Looper.prepare();

        // ...其他处理，如实例化handler

        // 开始循环处理消息队列
        Looper.loop();
    }
}
</code></pre><blockquote>
<p>通过上面两行核心代码，你的线程就升级为Looper线程了！！！是不是很神奇？让我们放慢镜头，看看这两行代码各自做了什么。</p>
</blockquote>
<ul>
<li>Looper.prepare()</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/Looper.prepare().png" alt=""></p>
<blockquote>
<p>通过上图可以看到，现在你的线程中有一个Looper对象，它的内部维护了一个消息队列MQ。注意，一个Thread只能有一个Looper对象，为什么呢？咱们来看源码。</p>
</blockquote>
<pre><code>public class Looper {
    // 每个线程中的Looper对象其实是一个ThreadLocal，即线程本地存储(TLS)对象
    private static final ThreadLocal sThreadLocal = new ThreadLocal();
    // Looper内的消息队列
    final MessageQueue mQueue;
    // 当前线程
    Thread mThread;
    // 。。。其他属性

    // 每个Looper对象中有它的消息队列，和它所属的线程
    private Looper() {
        mQueue = new MessageQueue();
        mRun = true;
        mThread = Thread.currentThread();
    }

    // 我们调用该方法会在调用线程的TLS中创建Looper对象
    public static final void prepare() {
        if (sThreadLocal.get() != null) {
            // 试图在有Looper的线程中再次创建Looper将抛出异常
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper());
    }
    // 其他方法
}
</code></pre><blockquote>
<p>通过源码，prepare()背后的工作方式一目了然，其核心就是将looper对象定义为ThreadLocal。</p>
</blockquote>
<ul>
<li>Looper.loop()<br><img src="http://o9zgq2ik9.bkt.clouddn.com/Looper.loop().png" alt=""></li>
</ul>
<blockquote>
<p>调用loop方法后，Looper线程就开始真正工作了，它不断从自己的MQ中取出队头的消息(也叫任务)执行。其源码分析如下：</p>
</blockquote>
<pre><code>public static final void loop() {
        Looper me = myLooper();  //得到当前线程Looper
        MessageQueue queue = me.mQueue;  //得到当前looper的MQ

        // 这两行没看懂= = 不过不影响理解
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();
        // 开始循环
        while (true) {
            Message msg = queue.next(); // 取出message
            if (msg != null) {
                if (msg.target == null) {
                    // message没有target为结束信号，退出循环
                    return;
                }
                // 日志。。。
                if (me.mLogging!= null) me.mLogging.println(
                        &quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot;
                        + msg.callback + &quot;: &quot; + msg.what
                        );
                // 非常重要！将真正的处理工作交给message的target，即后面要讲的handler
                msg.target.dispatchMessage(msg);
                // 还是日志。。。
                if (me.mLogging!= null) me.mLogging.println(
                        &quot;&lt;&lt;&lt;&lt;&lt; Finished to    &quot; + msg.target + &quot; &quot;
                        + msg.callback);

                // 下面没看懂，同样不影响理解
                final long newIdent = Binder.clearCallingIdentity();
                if (ident != newIdent) {
                    Log.wtf(&quot;Looper&quot;, &quot;Thread identity changed from 0x&quot;
                            + Long.toHexString(ident) + &quot; to 0x&quot;
                            + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                            + msg.target.getClass().getName() + &quot; &quot;
                            + msg.callback + &quot; what=&quot; + msg.what);
                }
                // 回收message资源
                msg.recycle();
            }
        }
    }
</code></pre><blockquote>
<p>除了prepare()和loop()方法，Looper类还提供了一些有用的方法，比如Looper.myLooper()得到当前线程looper对象：</p>
</blockquote>
<pre><code>public static final Looper myLooper() {
    // 在任意线程调用Looper.myLooper()返回的都是那个线程的looper
    return (Looper)sThreadLocal.get();
}
</code></pre><blockquote>
<p>getThread()得到looper对象所属线程：</p>
</blockquote>
<pre><code>public Thread getThread() {
    return mThread;
}
</code></pre><blockquote>
<p>quit()方法结束looper循环：</p>
</blockquote>
<pre><code>public void quit() {
    // 创建一个空的message，它的target为NULL，表示结束循环消息
    Message msg = Message.obtain();
    // 发出消息
    mQueue.enqueueMessage(msg, 0);
}
</code></pre><blockquote>
<p>到此为止，你应该对Looper有了基本的了解，总结几点：</p>
</blockquote>
<ul>
<li>每个线程有且最多只能有一个Looper对象，它是一个ThreadLocal</li>
<li>Looper内部有一个消息队列，loop()方法调用后线程开始不断从队列中取出消息执行</li>
<li>Looper使一个线程变成Looper线程。</li>
</ul>
<blockquote>
<p>那么，我们如何往MQ上添加消息呢？下面有请Handler！</p>
</blockquote>
<h4 id="异步处理者Handler"><a href="#异步处理者Handler" class="headerlink" title="异步处理者Handler"></a>异步处理者Handler</h4><blockquote>
<p>什么是Handler？Handler扮演了往MQ上添加消息和处理消息的角色（只处理由自己发出的消息），即通知MQ它要执行一个任务(sendMessage)，并在loop到自己的时候执行该任务(handleMessage)，整个过程是异步的。Handler创建时会关联一个looper，默认的构造方法将关联当前线程的looper，不过这也是可以set的。默认的构造方法：</p>
</blockquote>
<pre><code>public class Handler {
    final MessageQueue mQueue;  // 关联的MQ
    final Looper mLooper;  // 关联的looper
    final Callback mCallback; 
    // 其他属性

    public Handler() {
        // 没看懂，直接略过，，，
        if (FIND_POTENTIAL_LEAKS) {
            final Class&lt;? extends Handler&gt; klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                    klass.getCanonicalName());
            }
        }
        // 默认将关联当前线程的looper
        mLooper = Looper.myLooper();
        // looper不能为空，即该默认的构造方法只能在looper线程中使用
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);
        }
        // 重要！！！直接把关联looper的MQ作为自己的MQ，因此它的消息将发送到关联looper的MQ上
        mQueue = mLooper.mQueue;
        mCallback = null;
    }

    // 其他方法
}
</code></pre><blockquote>
<p>下面我们就可以为之前的LooperThread类加入Handler：</p>
</blockquote>
<pre><code>public class LooperThread extends Thread {
    private Handler handler1;
    private Handler handler2;

    @Override
    public void run() {
        // 将当前线程初始化为Looper线程
        Looper.prepare();

        // 实例化两个handler
        handler1 = new Handler();
        handler2 = new Handler();

        // 开始循环处理消息队列
        Looper.loop();
    }
}
</code></pre><blockquote>
<p>加入handler后的效果如下图：</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/%E5%8A%A0%E5%85%A5handler%E5%90%8E%E7%9A%84%E6%95%88%E6%9E%9C.png" alt=""></p>
<blockquote>
<p>可以看到，一个线程可以有多个Handler，但是只能有一个Looper！</p>
</blockquote>
<h5 id="Handler发送消息"><a href="#Handler发送消息" class="headerlink" title="Handler发送消息"></a>Handler发送消息</h5><blockquote>
<p>有了handler之后，我们就可以使用 post(Runnable), postAtTime(Runnable, long), postDelayed(Runnable, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long)和sendMessageDelayed(Message, long)这些方法向MQ上发送消息了。光看这些API你可能会觉得handler能发两种消息，一种是Runnable对象，一种是message对象，这是直观的理解，但其实post发出的Runnable对象最后都被封装成message对象了，见源码：</p>
</blockquote>
<pre><code>// 此方法用于向关联的MQ上发送Runnable对象，它的run方法将在handler关联的looper线程中执行
    public final boolean post(Runnable r)
    {
       // 注意getPostMessage(r)将runnable封装成message
       return  sendMessageDelayed(getPostMessage(r), 0);
    }

    private final Message getPostMessage(Runnable r) {
        Message m = Message.obtain();  //得到空的message
        m.callback = r;  //将runnable设为message的callback，
        return m;
    }

    public boolean sendMessageAtTime(Message msg, long uptimeMillis)
    {
        boolean sent = false;
        MessageQueue queue = mQueue;
        if (queue != null) {
            msg.target = this;  // message的target必须设为该handler！
            sent = queue.enqueueMessage(msg, uptimeMillis);
        }
        else {
            RuntimeException e = new RuntimeException(
                this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
        }
        return sent;
    }
</code></pre><blockquote>
<p>其他方法就不罗列了，总之通过handler发出的message有如下特点：</p>
</blockquote>
<ul>
<li><p>message.target为该handler对象，这确保了looper执行到该message时能找到处理它的handler，即loop()方法中的关键代码<br>  msg.target.dispatchMessage(msg);</p>
</li>
<li><p>post发出的message，其callback为Runnable对象</p>
</li>
</ul>
<h5 id="Handler处理消息"><a href="#Handler处理消息" class="headerlink" title="Handler处理消息"></a>Handler处理消息</h5><blockquote>
<p>说完了消息的发送，再来看下handler如何处理消息。消息的处理是通过核心方法dispatchMessage(Message msg)与钩子方法handleMessage(Message msg)完成的，见源码</p>
</blockquote>
<pre><code>// 处理消息，该方法由looper调用
    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            // 如果message设置了callback，即runnable消息，处理callback！
            handleCallback(msg);
        } else {
            // 如果handler本身设置了callback，则执行callback
            if (mCallback != null) {
                 /* 这种方法允许让activity等来实现Handler.Callback接口，避免了自己编写handler重写handleMessage方法。见http://alex-yang-xiansoftware-com.iteye.com/blog/850865 */
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            // 如果message没有callback，则调用handler的钩子方法handleMessage
            handleMessage(msg);
        }
    }

    // 处理runnable消息
    private final void handleCallback(Message message) {
        message.callback.run();  //直接调用run方法！
    }
    // 由子类实现的钩子方法
    public void handleMessage(Message msg) {
    }
</code></pre><blockquote>
<p>可以看到，除了handleMessage(Message msg)和Runnable对象的run方法由开发者实现外（实现具体逻辑），handler的内部工作机制对开发者是透明的。这正是handler API设计的精妙之处！</p>
</blockquote>
<h5 id="Handler的用处"><a href="#Handler的用处" class="headerlink" title="Handler的用处"></a>Handler的用处</h5><blockquote>
<p>我在小标题中将handler描述为“异步处理大师”，这归功于Handler拥有下面两个重要的特点：</p>
</blockquote>
<ul>
<li>handler可以在任意线程发送消息，这些消息会被添加到关联的MQ上。</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/%E4%BB%BB%E6%84%8F%E7%BA%BF%E7%A8%8B%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.png" alt=""></p>
<ul>
<li>handler是在它关联的looper线程中处理消息的</li>
</ul>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/%E5%85%B3%E8%81%94%E7%9A%84looper%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF.png" alt=""></p>
<blockquote>
<p>这就解决了android最经典的不能在其他非主线程中更新UI的问题。<em>android的主线程也是一个looper线程</em>(looper在android中运用很广)，我们在其中创建的handler默认将关联主线程MQ。因此，利用handler的一个solution就是在activity中创建handler并将其引用传递给worker thread，worker thread执行完任务后使用handler发送消息通知activity更新UI。(过程如图)</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/%E6%9B%B4%E6%96%B0UI.png" alt=""></p>
<blockquote>
<p>下面给出sample代码，仅供参考：</p>
</blockquote>
<pre><code>public class TestDriverActivity extends Activity {
    private TextView textview;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        textview = (TextView) findViewById(R.id.textview);
        // 创建并启动工作线程
        Thread workerThread = new Thread(new SampleTask(new MyHandler()));
        workerThread.start();
    }

    public void appendText(String msg) {
        textview.setText(textview.getText() + &quot;\n&quot; + msg);
    }

    class MyHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            String result = msg.getData().getString(&quot;message&quot;);
            // 更新UI
            appendText(result);
        }
    }
}

public class SampleTask implements Runnable {
    private static final String TAG = SampleTask.class.getSimpleName();
    Handler handler;

    public SampleTask(Handler handler) {
        super();
        this.handler = handler;
    }
    @Override
    public void run() {
        try {  // 模拟执行某项任务，下载等
            Thread.sleep(5000);
            // 任务完成后通知activity更新UI
            Message msg = prepareMessage(&quot;task completed!&quot;);
            // message将被添加到主线程的MQ中
            handler.sendMessage(msg);
        } catch (InterruptedException e) {
            Log.d(TAG, &quot;interrupted!&quot;);
        }

    }

    private Message prepareMessage(String str) {
        Message result = handler.obtainMessage();
        Bundle data = new Bundle();
        data.putString(&quot;message&quot;, str);
        result.setData(data);
        return result;
    }
}
</code></pre><blockquote>
<p>当然，handler能做的远远不仅如此，由于它能post Runnable对象，它还能与Looper配合实现经典的Pipeline Thread(流水线线程)模式</p>
</blockquote>
<h4 id="封装任务Message"><a href="#封装任务Message" class="headerlink" title="封装任务Message"></a>封装任务Message</h4><blockquote>
<p>在整个消息处理机制中，message又叫task，封装了任务携带的信息和处理该任务的handler。message的用法比较简单，这里不做总结了。但是有这么几点需要注意（待补充）：</p>
<ul>
<li>尽管Message有public的默认构造方法，但是你应该通过Message.obtain()来从消息池中获得空消息对象，以节省资源。</li>
<li>如果你的message只需要携带简单的int信息，请优先使用Message.arg1和Message.arg2来传递信息，这比用Bundle更省内存</li>
<li>擅用message.what来标识信息，以便用不同方式处理message。</li>
</ul>
</blockquote>
<p><strong>参考资料</strong><br><a href="http://www.cnblogs.com/codingmyworld/archive/2011/09/12/2174255.html" target="_blank" rel="external">博文</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/05/Android消息处理机制 — 实用易懂(1)/" data-id="civaavwl5000lor9yykpyebhd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Handler/">Handler</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/消息处理机制/">消息处理机制</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android的线程和线程池" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/01/Android的线程和线程池/" class="article-date">
  <time datetime="2016-07-01T02:36:34.000Z" itemprop="datePublished">2016-07-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习记录/">学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/01/Android的线程和线程池/">Android的线程和线程池</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>线程：在操作系统（OS）中，线程是OS调度的最小单元，同时又是一种受限的系统资源，不可能无限制的产生，并且其创建和销毁都会有一定的开销。当OS中存在大量的线程时，OS会通过时间片轮询的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数目小于等于CPU的核心数，一般是不可能的。</p>
<p>线程池：在一个进程中频繁地创建和销毁线程不是一种高效的做法，正确地做法是使用线程池。线程池中会缓存一定数目的线程，然后通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。Android中的线程池来源于Java，主要是通过Executor来派生特定类型的线程池，不同类型的线程池又具有不同的特性。</p>
<p>按用途来划分，线程有两种：</p>
</blockquote>
<ul>
<li>主线程：处理和界面有关的事情</li>
<li>子线程：执行耗时的一些操作</li>
</ul>
<blockquote>
<p>由于Android的特性，如果在主线程中执行耗时操作，系统会无法及时地响应，并抛出ANR（应用程序无响应），因此，耗时操作必须要放在子线程中执行。</p>
<p>除了传统的Java中的Thread类表示线程外，在Android中，系统提供了自己特有的可以扮演线程角色的类，如AsyncTask，IntentService，HandlerThread（一种特殊的线程）等，需要注意的是这些类本质上仍是创痛的线程，AsyncTask底层用到了Java中的线程池，而IntentService和HandlerThread的底层则直接使用了Thread线程类。</p>
</blockquote>
<ul>
<li>AsyncTask封装了线程池和Handler，主要是方便开发者在子线程中更新UI。</li>
<li>HandlerThread是一个具有消息循环的线程，在它的内部可以使用Handler。</li>
<li>IntentService是一个服务，系统对其进行了封装，使其可以方便地执行后台任务，IntentService内部采用HandlerThread来执行任务，任务执行完毕后，其会自动退出。从任务执行的角度来看，IntentService的作用很像一个后台线程，但是IntentService是一种服务，它是不容易被系统杀死的，从而尽量保证任务的执行，而如果是一个后台线程的话，由于这个时候进程中没有活动的四大组件，那么这个进程的优先级就会非常低，会很容易被系统杀死，这是IntentService的优点。</li>
</ul>
<h3 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h3><blockquote>
<p>Android沿用Java的线程模型。</p>
</blockquote>
<h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><blockquote>
<p>主线程(UI线程)是指进程所拥有的线程，在Java中默认情况下一个进程只有一个线程，这个线程就是主线层。主线程的主要任务是处理于界面的交互相关的逻辑，在Android中就是运行四大组件以及处理和它们的交互，因为用户随时会和界面发生交互，因此主线程在任何时候都必须具有较高的响应速度，否则就会造成界面卡顿，用户体验不好。</p>
</blockquote>
<h4 id="子线程"><a href="#子线程" class="headerlink" title="子线程"></a>子线程</h4><blockquote>
<p>为了保持较高的响应速度，在主线程中就不应该执行耗时任务，这个时候子线程的作用就体现出来了。子线程又被称为工作线程，除了主线程外，其他的都是子线程。子线程就是要执行耗时任务，如网络请求，I/O操作等。Android3.0以后的系统都要求网络访问必须在子线程中进行，否则就会访问失败并抛出NetworkOnMainThreadException异常，这么做主要是避免主线程被耗时任务阻塞，造成ANR。</p>
</blockquote>
<h3 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h3><blockquote>
<p>除去传统的Thread， Android中的线程形态有AsyncTask，IntentService，HandlerThread三种，它们的底层实现也是线程，只是它们具有特殊的表现形式，同时在使用上也各有优缺点。</p>
</blockquote>
<h4 id="AsyncTask及其原理"><a href="#AsyncTask及其原理" class="headerlink" title="AsyncTask及其原理"></a>AsyncTask及其原理</h4><blockquote>
<p>为了简化子线程中访问UI的过程，系统提供了AsyncTask。不同版本API的AsyncTask具有不同的表现，尤其是在多任务并发执行上。</p>
<p>AsyncTask是一种轻量级的异步任务类，可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程中更新UI。从实现上说，AsyncTask封装了Thread和Handler，并通过AsyncTask可以更加方便的执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合执行特别耗时的后台任务，对于特别耗时的任务，建议使用线程池。</p>
<p>AsyncTask是一个抽象范型类，使用时要通过子类继承，其提供了Params，Progress，Result三个范型参数，其中Params表示参数的类型，Progress表示后台任务执行进度的类型，Result表示后台任务的返回结果类型，如果AsyncTask确实不需要传递任何参数，这三个范型参数可以使用Void来代替。AysncTask的类声明如下：</p>
</blockquote>
<pre><code>public abstract class AsyncTask&lt;Params, Progress, Result&gt;
</code></pre><blockquote>
<p>AsyncTask提供了4个核心方法，具体解释如下：</p>
</blockquote>
<ol>
<li>onProExecute(), 在主线程中执行，在异步任务执行之前，此方法会被调用，一般用于一些准备工作。</li>
<li>doInBackground(Params … params), 在线程池中执行，用于执行异步任务，params参数表示异步任务的输入参数。在此方法中可以通过调用publishProgress()方法来更新任务的进度， publishProgress()方法会触发onProgressUpdate()方法的调用。另外此方法需要返回计算结果给onPostExecute()方法。</li>
<li>onProgressUpdate(Progress … values), 在主线程中执行，当后台任务的执行进度发生改变时，此方法通过publishProgress()方法被调用。</li>
<li>onPostExecute(Result result), 在主线程中执行，当后台异步任务执行完毕之后，此方法会被调用，其中，result参数时后台异步任务的返回值，即doInBackground方法的返回值。</li>
</ol>
<blockquote>
<p>4个方法的执行顺序是：onPreExecute, doInBackground, onPostExecute. onProgressUpdate方法看情况执行，如果publishProgress方法在doInBackground方法中被调用，其执行顺序就在onPostExecute之前，否则，其不执行。除了上述4个方法外，AsyncTask也提供onCancelled()方法，当异步任务被取消时，onCancelled()方法会在主线程中被调用执行，这个时候onPostExecute方法就不会再被调用。</p>
</blockquote>
<p><strong>典型案例</strong></p>
<pre><code>private class DownLoadAsyncTask extends AsyncTask&lt;URL, Integer, Long&gt; {
    protected Long doInBackground(URL ... urls) {
        int count = urls.length;
        long totalsize = 0;
        for(int i = 0; i &lt; count; i++) {
            totalsize += Downloader.down(urls[i]);
            publishProgress((int) ((i / (float) count * 100));
            // Escape early if cancel() is called
            if(isCancelled()) {
                break;
            }
        }
        return totalsize;
    }
    protected void onProgressUpdate(Integer ... progress) {
        setProgressPercent(progress[0]);
    }
    protected void onPostExecute(Long result) {
        showDialog(&quot;Downloaded&quot; + result + &quot;bytes&quot;);
    }
}
</code></pre><blockquote>
<p>上面实现了一个具体的AsyncTask类，主要功能时模拟文件下载的过程，输入参数类型为URL，后台任务进程参数为Integer，后台任务的返回结果为Long类型。注意一点：括号中的 … 表示参数个数不定，它代表一种数组型的参数，在这点上Java和C是一致的。</p>
<p>具体的AsyncTask类定义完成后，当要执行下载任务时，通过下面方式完成：</p>
</blockquote>
<pre><code>AsyncTask task = new DownloadAsyncTask();
task.execute(url1,url2,url3);
</code></pre><p><strong>AsyncTask在具体的使用过程中的一些条件限制：</strong></p>
<ol>
<li>AsyncTask的类必须在主线程中加载，这意味着第一次访问AsyncTask必须发生在主线程，当然这个过程在Android4.1及以上的版本中已经被系统自动完成。在5.0的源码中，可以看到在ActivityThread的main方法中会调用AsyncTask的init方法，这就满足了这个限制条件。至于为什么必须满足这个条件，在下面小节的原理分析中会给予解答。<ol>
<li>AsyncTask实现类的对象必须在主线程中创建。</li>
<li>AsyncTask实现类的execute()方法也必须在主线程中被调用。</li>
<li>不要在程序中手动直接调用onPreExecute(), doInBackground(), onPostExecute(), onProgressUpdate()这四个方法。</li>
<li>一个AsyncTask实现类对象只能执行一次，即只能调用一次execute()方法，否则会报异常。</li>
<li>Android1.6之前，AsyncTask是串行执行任务的，1.6的时候开始采用线程池处理并行任务，但是从3.0开始，为了避免AsyncTask所带来的并发错误，其又再一次采用一个线程来串行执行任务。尽管如此，3.0以后的版本中，我们仍然可以通过AsyncTask的executeOnExecuter方法来并行执行任务。</li>
</ol>
</li>
</ol>
<h4 id="AsyncTask的工作原理"><a href="#AsyncTask的工作原理" class="headerlink" title="AsyncTask的工作原理"></a>AsyncTask的工作原理</h4><blockquote>
<p>待完成</p>
</blockquote>
<h4 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h4><blockquote>
<p>HandlerThread继承了Thread，是一种可以使用Handler的Thread，它的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了。</p>
<p>HandlerThread的run方法如下所示：</p>
</blockquote>
<pre><code>public void run() {
    mTid = Process.myTid();
    Looper.prepare();
    synchrinized(this) {
        mLooper = Looper.myLooper();
        notifyAll();
    }
    Process.setThreadPriority(mPriority);
    onLooperPrepared();
    Looper.loop();
    mTid = -1;
}
</code></pre><blockquote>
<p>从HandlerThread的实现来看，它和普通的Thread有显著的不同，普通的Thread主要用于在run方法中执行一个耗时任务，而HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式来通知HandlerThread执行一个具体的任务。HandlerThread类是一个很有用的类，它在Android中的一个具体应用场景就是IntentService，将在下节介绍。由于HandlerThread的run方法是一个无限循环，因此当明确不需要再使用的时候，可以通过它的quit或者quitSafely方法来终止线程的执行，好的编程习惯。</p>
</blockquote>
<h4 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h4><blockquote>
<p>Todo</p>
</blockquote>
<h3 id="Android中的线程池"><a href="#Android中的线程池" class="headerlink" title="Android中的线程池"></a>Android中的线程池</h3><p><strong>线程池的优点</strong></p>
<ol>
<li>重用线程池中的线程，避免因为创建线程和销毁线程带来不必要的内存开销。</li>
<li>能有效控制线程池中的最大并发数，避免大量的线程之间因互相抢占资源而导致的阻塞现象。</li>
<li>能够对线程池进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ol>
<blockquote>
<p>Android中线程池的概念来自Java中的Executer，Executer是一个接口，真正的线程池实现为ThreadPoolExecuter，其提供了一系列的参数来配置线程池，通过不同的参数可以查创建不同的线程池。从线程池的功能特性上来说，Android的线程池有4类，并且可以通过Executers所提供的工厂方法来得到。</p>
</blockquote>
<h4 id="ThreadPoolExecuter"><a href="#ThreadPoolExecuter" class="headerlink" title="ThreadPoolExecuter"></a>ThreadPoolExecuter</h4><blockquote>
<p>ThreadPoolExecuter是线程池的真正实现，它的构造方法提供了一系列参数来配置线程池。下面是其一个比较常用的构造方法，构造方法中的参数会直接影响线程池的功能特性。</p>
</blockquote>
<pre><code>public ThreadPoolExecutor(
        int corePoolSize, 
        int maximumPoolSize, 
        long keepAliveTime, 
        TimeUnit unit, 
        BlockingQueue&lt;Runnable&gt; workQueue, 
        ThreadFactory threadFactory
)
</code></pre><blockquote>
<p>下面会介绍各个参数的具体用法</p>
</blockquote>
<ul>
<li>corePoolSize</li>
</ul>
<blockquote>
<p>线程池的核心线程数目，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔由keepAliveTime所指定，当等待时间超过keepAliveTime所指定的时长后，核心线程就会被终止。</p>
</blockquote>
<ul>
<li>maximumPoolSize</li>
</ul>
<blockquote>
<p>线程池所能容纳的最大线程数，当活动线程数达到这个数值后，后续的新任务将会被阻塞。</p>
</blockquote>
<ul>
<li>keepAliveTime</li>
</ul>
<blockquote>
<p>非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。当ThreadPoolExecutor的allowCoreThreadTimeOut这个属性设置为true时，keepAliveTime同样会作用于核心线程。</p>
</blockquote>
<ul>
<li>unit</li>
</ul>
<blockquote>
<p>用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的TimeUnit.MILLISECONDS(毫秒), TimeUnit.SECONDS(秒), TimeUnit.MINUTES(分钟)等。</p>
</blockquote>
<ul>
<li>workQueue</li>
</ul>
<blockquote>
<p>线程池中的任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中。</p>
</blockquote>
<ul>
<li>threadFactory</li>
</ul>
<blockquote>
<p>线程工厂，为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个方法，Thread  newThread(Runnable r).</p>
<p>除了上面的这些主要参数外，还有一个不常用的参数RejectedExecutionHandler handler。当线程池无法执行新任务时，这可能是由于任务队列已满或者是无法成功执行任务，这个时候ThreadPoolExecutor会调用handler的rejectedExecution方法来通知调用者，默认情况下rejectedExecution方法会直接抛出一个RejectedExecutionException。ThreadPoolExecutor为RejectedExecutionHandler提供了几个可选值：CallerRunsPolicy，AbortPolicy，DiscardPolicy和DiscardOldestPolicy，其中AbortPolicy是默认值，它会直接抛出RejectedExecutionException。</p>
<p>ThreadPoolExecutor执行任务时大致遵循如下规则：</p>
</blockquote>
<ol>
<li>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li>
<li>如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</li>
<li>如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</li>
<li>如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。</li>
</ol>
<blockquote>
<p>ThreadPoolExecutor的参数配置在AsyncTask中有明显的体现，如下：</p>
</blockquote>
<pre><code>private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
private static final int CORE_POOL_SIZE = CPU_COUNT + 1;
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE = 1;

private static final ThreadFactory sThreadFactory = new ThreadFactory() {
    private final AtomicInteger mCount = new AtomicInteger(1);
    public Thread newThread(Runnable r) {
        return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement());
    }
}

private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);

/**
 * An Executor that can be used to execute tasks in parallel
 **/
public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);
</code></pre><blockquote>
<p>从上面的代码可以知道，AsyncTask对THREAD_POOL_EXECUTOR这个线程池进行了配置，配置后的线程池规格如下：</p>
</blockquote>
<ul>
<li>核心线程池等于CPU核心数+1</li>
<li>线程池的最大线程数为CPU核心数的2倍+1</li>
<li>核心线程无超时机制，非核心线程在闲置时的超时时间为1秒</li>
<li>任务队列的容量为128</li>
</ul>
<h4 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h4><blockquote>
<p>Android中常见的四类不同功能特性的线程池，都是通过直接或间接的配置ThreadPoolExecutor的参数来实现具有不同功能特性的线程池。</p>
</blockquote>
<h5 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h5><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre><blockquote>
</blockquote>
<h5 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h5><pre><code>public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L,TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre><h5 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h5><pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
}

public static ScheduledThreadPoolExecutor (int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0 ,NANOSECONDS, new DelayedWorkQueue());
}
</code></pre><h5 id="SingleThreadPool"><a href="#SingleThreadPool" class="headerlink" title="SingleThreadPool"></a>SingleThreadPool</h5><pre><code>public static ExecutorService newSingleThreadPool() {
        return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre><p><strong>系统预置的四种线程池的典型使用方法</strong></p>
<pre><code>Runnable command = new Runnable() {
        @Override
        public void run() {
            SystemClock.sleep(2000);
        }
}

ExecutorService fixedThreadPool = Executors.newFixedThreadPool(4);
fixedThreadPool.execute(command);

ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
cachedThreadPool.execute(command);

ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(4);
// 2000ms后执行command
scheduledThreadPool.schedule(command, 2000, TimeUnit.MILLISECONDS);
// 延迟10ms后，每隔1000ms执行一次command
scheduledThreadPool.scheduleAtFixedRate(command, 10, 1000, TimeUnit.MILLISECONDS);

ExecutorService singleThreadPool = Executors.newSingleThreadPool();
singleThreadPool.execute(command);
</code></pre><p><strong>参考资料</strong></p>
<p>《Android开发艺术探索》 —  任玉刚</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/01/Android的线程和线程池/" data-id="civaavwl7000oor9yfzknh2v6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程池/">线程池</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习记录/">学习记录</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ANR/">ANR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AS/">AS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AndroidStudio/">AndroidStudio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FC/">FC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fresco/">Fresco</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glide/">Glide</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Handler/">Handler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OOM/">OOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OkHttp/">OkHttp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Picasso/">Picasso</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/">Retrofit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ThreadLocal/">ThreadLocal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UIL/">UIL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Volley/">Volley</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apk签名/">apk签名</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jks密钥生成/">jks密钥生成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/书籍/">书籍</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件分发/">事件分发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存优化/">内存优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图片加载/">图片加载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多渠道打包/">多渠道打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源库/">开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/打包/">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息处理机制/">消息处理机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程池/">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络请求/">网络请求</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阅读/">阅读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ANR/" style="font-size: 10px;">ANR</a> <a href="/tags/AS/" style="font-size: 10px;">AS</a> <a href="/tags/AndroidStudio/" style="font-size: 10px;">AndroidStudio</a> <a href="/tags/FC/" style="font-size: 10px;">FC</a> <a href="/tags/Fresco/" style="font-size: 10px;">Fresco</a> <a href="/tags/Glide/" style="font-size: 10px;">Glide</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Handler/" style="font-size: 16.67px;">Handler</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/OOM/" style="font-size: 13.33px;">OOM</a> <a href="/tags/OkHttp/" style="font-size: 10px;">OkHttp</a> <a href="/tags/Picasso/" style="font-size: 10px;">Picasso</a> <a href="/tags/Retrofit/" style="font-size: 10px;">Retrofit</a> <a href="/tags/ThreadLocal/" style="font-size: 10px;">ThreadLocal</a> <a href="/tags/UIL/" style="font-size: 10px;">UIL</a> <a href="/tags/Volley/" style="font-size: 10px;">Volley</a> <a href="/tags/apk签名/" style="font-size: 10px;">apk签名</a> <a href="/tags/jks密钥生成/" style="font-size: 10px;">jks密钥生成</a> <a href="/tags/书籍/" style="font-size: 10px;">书籍</a> <a href="/tags/事件分发/" style="font-size: 10px;">事件分发</a> <a href="/tags/内存优化/" style="font-size: 10px;">内存优化</a> <a href="/tags/博客/" style="font-size: 10px;">博客</a> <a href="/tags/图片加载/" style="font-size: 10px;">图片加载</a> <a href="/tags/多渠道打包/" style="font-size: 10px;">多渠道打包</a> <a href="/tags/开源库/" style="font-size: 13.33px;">开源库</a> <a href="/tags/总结/" style="font-size: 13.33px;">总结</a> <a href="/tags/打包/" style="font-size: 10px;">打包</a> <a href="/tags/消息处理机制/" style="font-size: 16.67px;">消息处理机制</a> <a href="/tags/源码/" style="font-size: 13.33px;">源码</a> <a href="/tags/笔记/" style="font-size: 20px;">笔记</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/线程池/" style="font-size: 10px;">线程池</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a> <a href="/tags/网络请求/" style="font-size: 10px;">网络请求</a> <a href="/tags/阅读/" style="font-size: 10px;">阅读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/08/阅读记录/">阅读记录</a>
          </li>
        
          <li>
            <a href="/2016/11/08/Android内存优化之OOM/">Android内存优化之OOM</a>
          </li>
        
          <li>
            <a href="/2016/10/29/AndroidStudio生成jks密钥～签名apk～多渠道打包/">AndroidStudio打包～生成jks密钥～签名apk～多渠道打包</a>
          </li>
        
          <li>
            <a href="/2016/10/28/Android中的图片加载框架/">Android中的图片加载框架</a>
          </li>
        
          <li>
            <a href="/2016/10/23/Android中网络请求框架/">Android中网络请求框架</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 QinPeng Zhu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>