<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="笔记,注解,Dagger2,依赖注入,Ioc,控制反转," />





  <link rel="alternate" href="/atom.xml" title="sh2zqp" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="http://sh2zqp.github.io/favicon.ico" />






<meta name="description" content="什么是Dagger2
Dagger2是Android中比较热门的依赖注入框架，而Android开发当前非常流行框架就是MVP模式了，Dagger2的目标便是将MVP中的V和P 进一步解耦，达到模块化最大的解耦，使得代码更容易维护。

Google官方主页介绍

Dagger is a fully static, compile-time dependency injection framework">
<meta property="og:type" content="article">
<meta property="og:title" content="Dagger2 入门详解">
<meta property="og:url" content="http://yoursite.com/2016/12/21/Dagger2 入门详解/index.html">
<meta property="og:site_name" content="sh2zqp">
<meta property="og:description" content="什么是Dagger2
Dagger2是Android中比较热门的依赖注入框架，而Android开发当前非常流行框架就是MVP模式了，Dagger2的目标便是将MVP中的V和P 进一步解耦，达到模块化最大的解耦，使得代码更容易维护。

Google官方主页介绍

Dagger is a fully static, compile-time dependency injection framework">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1818011-f8884b1f3c71e61d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1818011-e9598e0d6581d92f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1818011-edb92a97c1ae2c15.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo1.png">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1818011-2fcd4ed5a6a53f9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo2.png">
<meta property="og:image" content="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo3.png">
<meta property="og:image" content="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo4.png">
<meta property="og:image" content="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo5.png">
<meta property="og:image" content="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo6.png">
<meta property="og:image" content="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo7.png">
<meta property="og:image" content="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo8.png">
<meta property="og:image" content="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo9.png">
<meta property="og:updated_time" content="2016-12-21T11:32:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dagger2 入门详解">
<meta name="twitter:description" content="什么是Dagger2
Dagger2是Android中比较热门的依赖注入框架，而Android开发当前非常流行框架就是MVP模式了，Dagger2的目标便是将MVP中的V和P 进一步解耦，达到模块化最大的解耦，使得代码更容易维护。

Google官方主页介绍

Dagger is a fully static, compile-time dependency injection framework">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1818011-f8884b1f3c71e61d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'sh2zqp'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/12/21/Dagger2 入门详解/"/>


<link rel="icon" href="http://sh2zqp.github.io/favicon.ico" type="image/x-icon" />
  <title> Dagger2 入门详解 | sh2zqp </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-tw">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">sh2zqp</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Keep Learning</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Dagger2 入门详解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-12-21T14:12:26+08:00" content="2016-12-21">
              2016-12-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/学习记录/" itemprop="url" rel="index">
                    <span itemprop="name">学习记录</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/21/Dagger2 入门详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/21/Dagger2 入门详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/12/21/Dagger2 入门详解/" class="leancloud_visitors" data-flag-title="Dagger2 入门详解">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">閱讀次數 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-eye">浏览</i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="什么是Dagger2"><a href="#什么是Dagger2" class="headerlink" title="什么是Dagger2"></a>什么是Dagger2</h2><blockquote>
<p>Dagger2是Android中<strong>比较热门</strong>的<strong>依赖注入框架</strong>，而Android开发当前非常流行框架就是<strong>MVP模式</strong>了，Dagger2的目标便是将MVP中的V和P 进一步解耦，达到模块化最大的解耦，使得代码更容易维护。</p>
</blockquote>
<p><strong>Google官方主页介绍</strong></p>
<blockquote>
<p>Dagger is a fully static, compile-time dependency injection framework for both Java and Android. It is an adaptation of an earlier version created by Square and now maintained by Google.<br>Dagger aims to address many of the development and performance issues that have plagued reflection-based solutions. More details can be found in this talk(slides) by +Gregory Kick.</p>
</blockquote>
<p><strong>翻译理解</strong></p>
<blockquote>
<p>Dagger是为Android和Java平台提供的一个完全静态的，在编译时进行依赖注入的框架。 早期的版本由Square公司进行改编，现在由Google进行维护。<br>Dagger旨在解决基于反射带来的开发和性能上的问题（因为Dagger并没有用反射来做依赖注入）。更多详细内容可以看一下<a href="https://plus.google.com/+GregoryKick/" target="_blank" rel="external">Gregory Kicktalk</a>这个人的<a href="https://www.youtube.com/watch?v=oK_XtfXPkqw" target="_blank" rel="external">talk</a>。</p>
</blockquote>
<p><strong>通俗理解</strong></p>
<blockquote>
<p>其实就是告诉我们Dagger可以用来进行依赖注入，搞过Spring的人肯定都知道这是啥，SpringMVC里用到了大量依赖注入，下面聊一聊<strong>依赖注入</strong>。</p>
</blockquote>
<h2 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h2><p><strong>维基百科</strong></p>
<blockquote>
<p><strong>控制反转</strong>(Inversion of Control，缩写为<strong>IoC</strong>)，是面向对象编程中的一种<strong>设计原则</strong>，可以用来<strong>降低计算机代码之间的耦合度</strong>。其中最常见的方式叫做依赖注入(Dependency Injection，简称DI)，还有一种方式叫“依赖查找”(Dependency Lookup)。通过控制反转，对象在被创建的时候，由一个调度者调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p>
</blockquote>
<p><strong>通俗理解</strong></p>
<blockquote>
<p>当一个类中需要依赖其他对象时,不需要你亲自为那些需要依赖的对象赋值,为那些对象赋值的操作交给了<strong>IOC框架</strong>(如Dagger2)。例如，我们在做项目时，经常需要在一个对象里去创建另一个对象的示例，这种行为是<strong>产生耦合</strong>的常见形式，对于一个大型项目来说，过多的相互依赖会导致代码难以维护，很容易就会碰到修改一个小需求需要大面积的修改各种代码，特别是代码原来不是自己维护的，麻烦会更大。</p>
</blockquote>
<h2 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h2><blockquote>
<p>有一家咖啡店CoffeeShop，向顾客提供咖啡，我们非常容易明白咖啡店CoffeeShop是不能自己生产咖啡给顾客的，他们只能通过不同咖啡制作方法来生产咖啡供顾客饮用，此时抽象一个接口CoffeeMaker。</p>
</blockquote>
<h3 id="传统做法"><a href="#传统做法" class="headerlink" title="传统做法"></a>传统做法</h3><ul>
<li><p>业务核心类是CoffeeShop，通过CoffeeMaker负责生产Coffee并进行售卖</p>
<p>  /**</p>
<ul>
<li>这是一个售卖Coffee的例子</li>
<li>CoffeeMaker是对生成Coffee过程的一个封装</li>
<li><p>制作Coffee需要实现CoffeeMaker的produceCoffee方法<br>*/<br>public class CoffeeShop {</p>
<p> private CoffeeMaker mCoffeeMachine;</p>
<p> public CoffeeShop(CoffeeMaker coffeeMachine) {</p>
<pre><code>mCoffeeMachine = new SimpleCoffeeMachine();
</code></pre><p> }</p>
<p> public String provideCoffee() {</p>
<pre><code>return mCoffeeMachine.produceCoffee();
</code></pre><p> }<br>}</p>
</li>
</ul>
</li>
<li><p>Coffee的实际生产接口CoffeeMaker</p>
<p>  public interface CoffeeMaker {</p>
<pre><code>String produceCoffee(); // 实际生成咖啡的方法
</code></pre><p>  }</p>
</li>
<li><p>实际的Coffee生产者，下面是简单的咖啡机SimpleCoffeeMachine</p>
<p>  public class SimpleCoffeeMachine implements CoffeeMaker {</p>
<pre><code>@Override
public String produceCoffee() {
    return &quot;Coffee is made by SimpleCoffeeMachine&quot;;
}
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>刚开始咖啡都是咖啡机做出来的，这家咖啡店很简单，在CoffeeShop中可以看到，CoffeeShop持有了一个CoffeeMaker生产接口，而具体制作Coffee的过程是由实现了CoffeeMaker的自动咖啡机SimpleCoffeeMachine实现的，CoffeeMaker是在构造方法中new 出了一个实现CoffeeMaker接口的SimpleCoffeeMachine。当前的功能很简单，这么写看着也没什么问题。</p>
<p>随着业务的扩展，消费人群改变了，自动咖啡机SimpleCoffeeMachine也完全不能满足现有客户的需求，这个时候我们的CoffeeShop该进行业务升级。</p>
</blockquote>
<ul>
<li><p>雇佣<strong>咖啡师</strong>CoffeeCooker来制作咖啡。</p>
<p>  public class CoffeeCooker {</p>
<pre><code>private String mName; // 咖啡师名字
private String MCoffeeType; // 生产的Coffee类型

public CoffeeCooker(String name, String MCoffeeType) {
    mName = name;
    this.MCoffeeType = MCoffeeType;
}

public String produceCoffee() {
    return mName + &quot;制作了&quot; + MCoffeeType + &quot;的Coffee.&quot;;
}
</code></pre><p>  }</p>
</li>
<li><p>此时要升级SimpleCoffeeMachine了</p>
<p>  public class SimpleCoffeeMachine implements CoffeeMaker {</p>
<p>  //    @Override<br>  //    public String produceCoffee() {<br>  //        return “Coffee is made by SimpleCoffeeMachine”;<br>  //    }</p>
<pre><code>// 升级后
private CoffeeCooker mCoffeeCooker;

public SimpleCoffeeMachine(CoffeeCooker coffeeCooker) {
    mCoffeeCooker = coffeeCooker;
}
@Override
public String produceCoffee() {
    return mCoffeeCooker.produceCoffee();
}
</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>基于目前的情况，我们制作咖啡的流程发生了变化，原来的业务随着CoffeeCooker的加入发生了改变，但细心的小伙伴会发现目前还有一个地方受到了影响，那就是我们的CoffeeShop，</p>
</blockquote>
<pre><code>public class CoffeeShop {

    private CoffeeMaker mCoffeeMaker;

//    public CoffeeShop(CoffeeMaker coffeeMachine) {
//        mCoffeeMachine = new SimpleCoffeeMachine();
//    }

    // 升级后
    public CoffeeShop(CoffeeCooker coffeeCooker) {
        mCoffeeMaker = new SimpleCoffeeMachine(coffeeCooker);
    }

    public String provideCoffee() {
        return mCoffeeMaker.produceCoffee();
    }
}
</code></pre><blockquote>
<p>我们的SimpleCoffeeMachine升级了，业务波动影响到了我们的CoffeeShop，这时候不得不对CoffeeShop也进行修改。这时候我们的CoffeeShop就懵逼了，你SimpleCoffeeMachine业务升级就升级呗，为毛我制造CoffeeShop的过程也要变动，非常的不愿意，但迫于老板的压力。最后还是给整改了。很明显，这是一个<strong>不合适的流程</strong>，简单的一个业务的升级，还要我们对整个咖啡店进行修改，那如果业务非常复杂，引用了SimpleCoffeeMachine的可不仅仅是CoffeeShop一个，那是不是每个引用的地方都需要进行修改，业务庞大的情况下，这种修改就是致命的，不仅需要做大量没有意义的体力劳动来修改，还可能导致大片业务代码的变动直接<strong>增加测试的成本</strong>，其他接收这个需求的开发人员直接得跪键盘了，一个S SimpleCoffeeMachine的改动对CoffeeShop产生了直接的影响，肯定有什么地方是不对的。原因就是CoffeeShop里的SimpleCoffeeMachine是<strong>自己new出来的</strong>。这就是一个很不好的地方。这种糟糕的<strong>实例引用的方式</strong>我们称之为<strong>硬初始化（Hard init）</strong>，和<strong>硬编码（Hard coding）</strong>一样，都是糟糕代码滋生的好方法，Hard init不仅增加了<strong>各个模块的耦合</strong>，还让<strong>单元测试</strong>变得<strong>更加困难</strong>了。</p>
</blockquote>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote>
<p>那么该用什么方法来尽量地<strong>降低各个模块的耦合</strong>，避免<strong>new对象</strong>带来的问题呢。我们知道，类的初始化可以<strong>描述成new</strong>,get和set，new就是我们上面说的Hard init，容易增加各个模块之间的耦合，而<strong>get，则可以看做是工厂模式</strong>，工厂模式是new的一个<strong>升级版本</strong>，相对硬初始化来说，工厂模式把<strong>对象的创建都集中在工厂</strong>里了，对于需要依赖的类来说，无需再考虑对象的创建工作了，只需要关注如何从工厂里获得，在发生修改时也不会有太多的改动，和以前的方案比起来要好了不少。但工厂模式的对象创建依然非常的不灵活，对象的实现<strong>完全取决于工厂</strong>，会导致原来的<strong>依赖由具体的对象</strong>变为<strong>依赖相应的工厂</strong>，本质上还是有依赖关系的！！！对，工厂模式并没有改变本质的<strong>依赖关系</strong>，而且，对于简单职责的工厂来说，抽出一层工厂似乎并不会太麻烦，但当我们的工厂中提供的类的实现复杂起来时，又回到了最初的问题上，我们是在工厂中new对象还是继续给工厂中的内容再提供一个工厂呢，这种层层嵌套会让我们的代码变得干涩难懂，也会有<strong>设计过度</strong>的嫌疑，工厂模式在解决依赖问题还是有点尴尬。</p>
</blockquote>
<h3 id="手动依赖注入"><a href="#手动依赖注入" class="headerlink" title="手动依赖注入"></a>手动依赖注入</h3><blockquote>
<p>那么最后还有一个<strong>set</strong>，也就是我们的<strong>依赖注入</strong>了，依赖注入的依赖是<strong>从外部传递过来的</strong>，而且在Java平台上很多时候都是通过<strong>反射或者动态编译</strong>来提供<strong>依赖注入</strong>，这样就更加剥离的各个部分的耦合性，也让上述两种方式只能望其项背了。</p>
<p>依赖注入主要有三种途径：</p>
</blockquote>
<pre><code>public class CoffeeShopWithInjection implements InjectMaker {

    private CoffeeMaker mCoffeeMaker;

    // 第1种依赖注入方式: 构造器注入
    public CoffeeShopWithInjection(CoffeeMaker coffeeMaker) {
        mCoffeeMaker = coffeeMaker;
    }

    // 第2种依赖注入方式: Setter注入
    public void setCoffeeMaker(CoffeeMaker coffeeMaker) {
        mCoffeeMaker = coffeeMaker;
    }

    // 第3种依赖注入方式: 接口注入
    @Override
    public void injectMaker(CoffeeMaker coffeeMaker) {
        mCoffeeMaker = coffeeMaker;
    }

    public String produceCoffee() {
        return mCoffeeMaker.produceCoffee();
    }
}
</code></pre><blockquote>
<p>InjectMarker接口内容如下：</p>
</blockquote>
<pre><code>public interface InjectMaker {
    void injectMaker(CoffeeMaker coffeeMaker);
}
</code></pre><blockquote>
<p>依赖注入的最基本的原理比较容易理解，就是不要在需要依赖的类中通过<strong>new</strong>来创建依赖而是<strong>通过方法提供的参数注入进来</strong>，这样我们的需要依赖的类和提供依赖的类的实现方法分隔开了。不过这种<strong>手动提供依赖</strong>也是很繁杂的工作，充满的浓浓的重复体力劳动的气息，如何来尽量减少这些冗余代码的制作呢，答案就是下一部分。</p>
</blockquote>
<h3 id="依赖注入框架-Dagger2"><a href="#依赖注入框架-Dagger2" class="headerlink" title="依赖注入框架(Dagger2)"></a>依赖注入框架(Dagger2)</h3><blockquote>
<p>一般的IOC框架都是通过<strong>反射</strong>来实现的,但Dagger2作为Android端的IOC框架,为了不影响性能,它是通过<strong>apt动态生成代码</strong>来实现的.</p>
</blockquote>
<h4 id="Dagger2主要分为三个模块"><a href="#Dagger2主要分为三个模块" class="headerlink" title="Dagger2主要分为三个模块"></a>Dagger2主要分为三个模块</h4><ul>
<li>依赖提供方Module,负责提供依赖中所需要的对象,实际编码中类似于<strong>工厂类</strong></li>
<li>依赖需求方实例,它声明依赖对象,它在实际编码中对应<strong>业务类</strong>,例如Activity,当你在Activity中需要某个对象时,你只要在其中<strong>声明</strong>就行,声明的方法在下面会讲到</li>
<li>依赖注入组件Component,负责将对象注入到依赖需求方,它在实际编码中是<strong>一个接口</strong>,编译时Dagger2会自动为它生成一个实现类</li>
</ul>
<h4 id="Dagger2的主要工作流程"><a href="#Dagger2的主要工作流程" class="headerlink" title="Dagger2的主要工作流程"></a>Dagger2的主要工作流程</h4><ul>
<li>将依赖需求方实例传入给Component实现类</li>
<li>Component实现类根据依赖需求方实例中<strong>依赖声明</strong>,来确定该实例需要依赖哪些对象</li>
<li>确定依赖对象后,Component会在与自己关联的<strong>Module类</strong>中查找有没有提供<strong>这些依赖对象的方法</strong>,有的话就将Module类中提供的对象<strong>设置到依赖需求方实例中</strong></li>
</ul>
<blockquote>
<p>通俗上来讲就好比你现在需要一件衣服,自己做太麻烦了,你就去商店买,你跟商店老板说明你想要购买的类型后,商店老板就会在自己的衣服供应商中查找有没有你所说的类型,有就将它卖给你.其中<strong>你就对应上面所说的依赖需求方实例</strong>,你只要说明你需要什么,<strong>商店老板则对应Component实现类</strong>,负责满足别人的需求,而<strong>衣服供应商则对应Module类</strong>,他负责生产衣服.也许这里有点绕,但经过下面的Demo,也许能够帮助你理解.</p>
</blockquote>
<h4 id="在项目中引入Dagger2"><a href="#在项目中引入Dagger2" class="headerlink" title="在项目中引入Dagger2"></a>在项目中引入Dagger2</h4><p><strong>在项目下的build.gradle文件中添加apt插件</strong></p>
<pre><code>buildscript {
    ...
    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.2.2&apos;
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
        //添加apt插件
        classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;
    }
}
...
</code></pre><p><strong>在app目录的build.gradle文件中添加</strong></p>
<pre><code>apply plugin: &apos;com.android.application&apos;
//应用apt插件,一定要放在下面
apply plugin: &apos;com.neenbedankt.android-apt&apos;
...
dependencies {
    ...
    //引入dagger2
    compile &apos;com.google.dagger:dagger:2.4&apos;
    apt &apos;com.google.dagger:dagger-compiler:2.4&apos;
    //java注解
    provided &apos;org.glassfish:javax.annotation:10.0-b28&apos;
}
</code></pre><h4 id="Module类注入方式"><a href="#Module类注入方式" class="headerlink" title="Module类注入方式"></a>Module类注入方式</h4><p><strong>编写布料类Cloth</strong></p>
<blockquote>
<p>写一个Cloth类用作依赖对象,它包含一个color属性</p>
</blockquote>
<pre><code>public class Cloth {
    private String color;

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return color + &quot;布料&quot;;
    }
}
</code></pre><p><strong>书写Module类</strong></p>
<blockquote>
<p>现在的需求是MainActivity中需要使用到Cloth对象,所以我们要为MainActivity书写一个Module类用来提供Cloth对象,相当于创建了一个<strong>提供商</strong></p>
</blockquote>
<pre><code>@Module
public class MainModule {
    @Provides
    public Cloth getCloth() {
        Cloth cloth = new Cloth();
        cloth.setColor(&quot;红色&quot;);
        return cloth;
    }
}
</code></pre><blockquote>
<p>嗯?怎么多了两个注解?这两个注解有什么用呢?<br><strong>注解</strong>是Dagger2中的关键,编写<strong>Module类</strong>时要在该类上声明<strong>@Module</strong>以表明该类是Module类,这样Dagger2才能识别,那<strong>@Provides</strong>又是干嘛的呢?它的作用是声明Module类中<strong>哪些方法是用来提供依赖对象的</strong>,当<strong>Component类</strong>需要<strong>依赖对象</strong>时,他就会根据<strong>返回值的类型</strong>来在<strong>有@Provides注解的方法中选择调用哪个方法</strong>.在一个方法上声明@Provides注解,就相当于创建了<strong>一条生产线</strong>,这条生产线的产物就是方法的<strong>返回值类型</strong>.有了这条生产线,供应商就能<strong>提供这种类型的商品</strong>了,当商店老板（Component类）发现有人（依赖需求方）需要这种类型的商品时,<strong>供应商Module</strong>就可以提供给他了。</p>
</blockquote>
<p><strong>书写Component接口</strong></p>
<pre><code>@Component(modules = MainModule.class)
public interface MainComponent {
    void inject(MainActivity mainActivity);
}
</code></pre><blockquote>
<p>和Module类一样,<strong>Component类</strong>也是需要注解声明的,那个注解就是<strong>@Component</strong>,但是@Component注解的作用可<strong>不是单单用来声明Component类</strong>,他还有更强大的功能,@Component注解有<strong>modules和dependencies</strong>两个属性,这两个属性的类型都是<strong>Class数组</strong>,modules的作用就是<strong>声明该Component含有哪几个Module</strong>,即有几个供应商,当Component需要<strong>某个依赖对象</strong>时,就会通过<strong>这些Module类中对应的方法</strong>获取依赖对象,MainComponent中只包含<strong>MainModule</strong>,所以令modules=MainModule.class,<strong>相当于供应商和商店老板确定合作关系的合同</strong>.而<strong>dependencies属性则是声明Component类的依赖关系</strong>,这个下面再详讲.</p>
<p><strong>接口中那个方法</strong>又是干嘛用的呢?</p>
<p>我们现在只是声明了Component类,但我们要怎么将<strong>Component类和依赖需求方</strong>对象联合起来呢?答案就是通过这个<strong>inject方法</strong>,这个方法可以将依赖需求方对象送到Component类中,Component类就会根据<strong>依赖需求方对象中声明的依赖关系</strong>来<strong>注入依赖需求方对象中所需要的对象</strong>,本Demo中<strong>MainActivity（依赖需求方）</strong>中需要<strong>Cloth对象</strong>,所以我们通过inject方法将MainActivity实例传入到MainComponent中,MainComponent就会从MainModule中的getCloth方法获取Cloth实例,并将该实例赋值给MainActivity中的cloth字段.相当于你去商店的道路,没有这条路,<strong>你就无法去商店和老板说明你所需要的东西</strong>.但是这里需要注意的是,<strong>inject方法的参数不能用子类来接收,例如本Demo中,如果inject的参数是Activity,那么Dagger2就会报错.</strong></p>
</blockquote>
<p><strong>在MainActivity中声明</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private TextView mTextView;
    @Inject
    Cloth mCloth;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mTextView = (TextView) findViewById(R.id.tv);

        MainComponent build = DaggerMainComponent.builder()
                .mainModule(new MainModule())
                .build();
        build.inject(this);

        mTextView.setText(&quot;我现在有&quot; + mCloth);
    }
}
</code></pre><blockquote>
<p>上面代码中有两处关键:</p>
</blockquote>
<ul>
<li><strong>声明依赖对象Cloth</strong>,就是在cloth字段上添加<strong>@Inject</strong>注解,Dagger2中<strong>声明依赖对象</strong>都是通过@Inject注解,但是@Inject注解的字段不能是<strong>private和protected的</strong>. </li>
<li>通过Dagger2自动生成的类来创建<strong>Component的实现类</strong>,创建时需要传入该Component实现类所需要的<strong>Module类实例</strong>,传入方法就是调用Module类类名首字母小写对应的方法.这里我们通过Dagger2自动生成的<strong>DaggerMainComponent</strong>类创建了MainComponent的实例,相当于我们创建了一个实实在在的商店,不再是理论上的商店,但是创建商店一定也要创建真实的供应商嘛,所以创建Component实现类时一定要<strong>传入Module的实例.</strong>(注意编写完Component接口后Dagger2并不会自动创建对应的类,需要我们点击Android Studio中bulid菜单下的Rebulid Poject选项,或者直接书写代码,编译时Dagger2就会帮你自动生成).<br>  再将MainActivity通过inject方法发送到MainComponent中,调用完<strong>inject方法</strong>后,你就会发现,MainActivity中的<strong>mCloth字段已经被赋值</strong>,而且该mCloth对应的就是我们在<strong>MainModule类getCloth方法中创建的Cloth对象.</strong></li>
</ul>
<p><strong>运行结果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1818011-f8884b1f3c71e61d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="注解依赖对象注入方式"><a href="#注解依赖对象注入方式" class="headerlink" title="注解依赖对象注入方式"></a>注解<strong>依赖对象</strong>注入方式</h4><blockquote>
<p>前面的例子可能给人最大的感受就是麻烦吧?就是为mCloth赋个值,又要写什么Module类,又是要写什么Component接口.其实Dagger2还可以用注解来提供依赖对象.让我们来瞧瞧怎么使用.</p>
</blockquote>
<p><strong>创建依赖类Shoe</strong></p>
<blockquote>
<p>我们又创建一个依赖类Shoe</p>
</blockquote>
<pre><code>public class Shoe {
    @Inject
    public Shoe() {}

    @Override
    public String toString() {
        return &quot;鞋子&quot;;
    }
}
</code></pre><blockquote>
<p>但是这次我们创建的方<strong>式和Cloth不一样了</strong>,我们在<strong>构造函数上声明了@Inject注解</strong>,这个注解有什么用呢?作用可大了,<strong>当Component在所拥有的Module类中找不到依赖需求方需要类型的提供方法时</strong>,Dagger2就会检查该需要类型的<strong>有没有用@Inject声明的构造方法</strong>,<strong>有则用该构造方法创建一个</strong>.</p>
<p>相当于你去商店购买东西,你需要的东西商店的供应商不生产,商店老板就只好帮你去网上看看有没有你需要的东西,有则帮你网购一个.</p>
</blockquote>
<p><strong>在MainActivity中声明Shoe依赖</strong></p>
<blockquote>
<p>我们修改之前的MainActivity,添加一点东西</p>
</blockquote>
<pre><code>public class MainActivity extends AppCompatActivity {
    private TextView mTextView;
    @Inject
    Cloth mCloth;
    @Inject
    Shoe mShoe;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mTextView = (TextView) findViewById(R.id.tv);

        MainComponent build = DaggerMainComponent.builder()
                .mainModule(new MainModule())
                .build();
        build.inject(this);

        //mTextView.setText(&quot;我现在有&quot; + mCloth);
        mTextView.setText(&quot;我现在有&quot; + mCloth + &quot;和&quot; + mShoe);
    }
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1818011-e9598e0d6581d92f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>注意</strong></p>
<blockquote>
<p>有些读者可能会这样想:为什么不都用这种方法来声明呢?为什么要用Module类?<br>答案是这样的,项目中我们会用到<strong>别人的jar包</strong>,我们无法修改别人的源码,就更别说<strong>在人家的类上添加注解了</strong>,所以我们只能通过Module类来提供.</p>
</blockquote>
<h4 id="复杂一点的使用情况"><a href="#复杂一点的使用情况" class="headerlink" title="复杂一点的使用情况"></a>复杂一点的使用情况</h4><blockquote>
<p>我们创建的这些<strong>依赖类</strong>都<strong>不用依赖于其它依赖类</strong>,但是如果需要依赖于其它依赖类又要怎么弄呢?</p>
</blockquote>
<p><strong>创建依赖类Clothes</strong></p>
<blockquote>
<p>我们又来创建一个<strong>衣服类Clothes</strong>,制作衣服时<strong>需要布料</strong>,所以我们在创建Clothes的实例时需要<strong>用到Cloth实例</strong>(依赖到Cloth类)</p>
</blockquote>
<pre><code>public class Clothes {
    private Cloth cloth;
    public Clothes(Cloth cloth) {
        this.cloth = cloth;
    }
    public Cloth getCloth() {
        return cloth;
    }
    @Override
    public String toString() {
        return cloth.getColor() + &quot;衣服&quot;;
    }
}
</code></pre><p><strong>在Module类中增加提供方法</strong></p>
<blockquote>
<p>现在我们的MainActivity中需要<strong>依赖于Clothes对象</strong>,所以我们在MianModule中<strong>添加提供Clothes对象的方法</strong>,但是<strong>Clothes需要依赖于Cloth对象</strong>,这要怎么办呢?可能最先想到的办法就是这样:</p>
</blockquote>
<pre><code>@Provides
    public Clothes getClothes() {
        Cloth cloth = new Cloth();
        cloth.setColor(&quot;红色&quot;);
        return new Clothes(cloth);
}
</code></pre><blockquote>
<p>直接在方法中创建一个Cloth不就得了,但是你有没有发现,创建Cloth的代码已经在<strong>getCloth方法中有了</strong>,我们能不能用getCloth方法中创建的Cloth实例来创建Clothes实例呢?</p>
<p>Dagger2提供了这样的功能,我们只要在getClothes方法中<strong>添加Cloth参数</strong>,Dagger2就会像帮<strong>依赖需求方找依赖对象一样帮你找到该方法依赖的Cloth实例</strong>,所以我们代码可以这样改:</p>
</blockquote>
<pre><code>@Provides
    public Clothes getClothes(Cloth cloth) {
        return new Clothes(cloth);
}
</code></pre><p><strong>在MainActivity中声明Clothes依赖</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {
    ...
    @Inject
    Clothes clothes;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        tv.setText(&quot;我现在有&quot; + cloth + &quot;和&quot; + shoe + &quot;和&quot; + clothes);
    }
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1818011-edb92a97c1ae2c15.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>同理,在带有@Inject注解的构造函数要是依赖于其它对象,Dagger2也会帮你自动注入.</p>
</blockquote>
<p><strong> 创建依赖类Shirt</strong></p>
<pre><code>public class Shirt {
    Cloth mCloth;
    @Inject
    public Shirt(Cloth cloth) {
        mCloth = cloth;
    }
    @Override
    public String toString() {
        return mCloth + &quot;T恤&quot;;
    }
}
</code></pre><p><strong>在MainActivity中声明Shirt依赖</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {
    ...
    @Inject
    Shirt mShirt;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        mTextView.setText(&quot;我现在有&quot; + mCloth + &quot;和&quot; + mShoe + &quot;和&quot; + mClothes + &quot;和&quot; + mShirt);
    }
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo1.png" alt=""></p>
<h4 id="依赖总结"><a href="#依赖总结" class="headerlink" title="依赖总结"></a>依赖总结</h4><blockquote>
<p>引用<a href="https://dreamerhome.github.io/2016/07/07/dagger/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">依赖注入神器：Dagger2详解系列</a>中的一段话:<br>我们有<strong>两种方式可以提供依赖</strong>，一个是<strong>注解了@Inject的构造方法</strong>，一个是在<strong>Module里提供的依赖</strong>，那么Dagger2是怎么选择依赖提供的呢，规则是这样的：</p>
</blockquote>
<ul>
<li>步骤1：查找Module中是否存在创建该类的方法</li>
<li>步骤2：若存在创建类方法，查看该方法是否存在参数<ul>
<li>步骤2.1：若存在参数，则按从步骤1开始依次初始化每个参数</li>
<li>步骤2.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束</li>
</ul>
</li>
<li>步骤3：若不存在创建类方法，则查找Inject注解的构造函数，看构造函数是否存在参数<ul>
<li>步骤3.1：若存在参数，则从步骤1开始依次初始化每个参数</li>
<li>步骤3.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束</li>
</ul>
</li>
</ul>
<p><strong>也就说Dagger2会递归的提供依赖</strong></p>
<h4 id="Named和-Qulifier注解的使用"><a href="#Named和-Qulifier注解的使用" class="headerlink" title="@Named和@Qulifier注解的使用"></a>@Named和@Qulifier注解的使用</h4><p><strong>@Named</strong></p>
<blockquote>
<p>假设我们现在又有了新的需求,MainActivity中需要<strong>两种布料</strong>,分别是红布料和蓝布料,但我们的MainModule类中只能提供红布料,怎么办呢?<br>读者可能会想:在MainModule类中再添加一个提供蓝布料的方法不就行了:</p>
</blockquote>
<pre><code>@Provides
public Cloth getRedCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;红色&quot;);
    return cloth;
}
@Provides
public Cloth getBlueCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;蓝色&quot;);
    return cloth;
}
</code></pre><blockquote>
<p>可问题就来了,Dagger2<strong>是通过返回值类型来确定的</strong>,当你需要红布料时,它又怎么知道哪个是红布料呢?所以Dagger2为我们提供<strong>@Named</strong>注解,它怎么使用呢?它有一个value值,<strong>用来标识这个方法是给谁用的</strong>.修改我们的代码:</p>
</blockquote>
<pre><code>@Provides
@Named(&quot;red&quot;)
public Cloth getRedCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;红色&quot;);
    return cloth;
}
@Provides
@Named(&quot;blue&quot;)
public Cloth getBlueCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;蓝色&quot;);
    return cloth;
}
</code></pre><blockquote>
<p>我们在getRedCloth方法上使用<strong>@Named(“red”)表明此方法返回的是红布料</strong>,同理,在<strong>getBlueCloth方法上使用@Named(“blue”)</strong>表明此方法返回的是蓝布料,接下我们只要在MainActivity中的布料字段上<strong>同样使用@Named注解</strong>,就可以<strong>一一配对</strong>了.</p>
</blockquote>
<pre><code>public class MainActivity extends AppCompatActivity {
    ...
    @Inject
    @Named(&quot;red&quot;)
    Cloth redCloth;
    @Inject
    @Named(&quot;blue&quot;)
    Cloth blueCloth;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        tv.setText(&quot;我现在有&quot; + mRedCloth + &quot;和&quot; + mBlueCloth );
    }
}
</code></pre><blockquote>
<p>在redCloth上用@Named(“red”)标记后,他就会对应Module中对应的方法.</p>
</blockquote>
<p><strong>运行结果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1818011-2fcd4ed5a6a53f9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>@Qulifier</strong></p>
<blockquote>
<p>@Qulifier功能和@Named一样,并且@Named就是继承@Qulifier的,我们要怎么使用@Qulifier注解呢?答案就是自定义一个注解:</p>
</blockquote>
<pre><code>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface RedCloth {
}
</code></pre><blockquote>
<p>有了这个注解,我们就可以用它在替换掉上面的@Named(“red”),效果是一样的.</p>
</blockquote>
<p><strong>略</strong></p>
<blockquote>
<p>而且这两个注解还能使用在依赖参数上,比如这个:</p>
</blockquote>
<pre><code>@Provides
 public Clothes getClothes(@Named(&quot;blue&quot;) Cloth cloth){
     return new Clothes(cloth);
 }
</code></pre><blockquote>
<p>效果和上面说明的一样,进入这个方法的cloth由上面有@Named(“blue”)的方法提供</p>
</blockquote>
<h4 id="Singleton和-Scope的使用"><a href="#Singleton和-Scope的使用" class="headerlink" title="@Singleton和@Scope的使用"></a>@Singleton和@Scope的使用</h4><p><strong>@Singleton</strong></p>
<blockquote>
<p>假设现在MainActivity中需要依赖Clothes和Cloth,我们在MainModule中提供这两个类的提供方法:</p>
</blockquote>
<pre><code>@Provides
@Named(&quot;blue&quot;)
public Cloth getBlueCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;蓝色&quot;);
    return cloth;
}
@Provides
public Clothes getClothes(@Named(&quot;blue&quot;) Cloth cloth) {
    return new Clothes(cloth);
}
</code></pre><blockquote>
<p>接着在MainActivity中声明</p>
</blockquote>
<pre><code>mTextView.setText(&quot;mBlueCloth=mClothes中的mBlueCloth吗?:&quot; + (mBlueCloth == mClothes.getCloth()));
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo2.png" alt=""></p>
<blockquote>
<p>你会发现,MainActivity中的<strong>Cloth对象</strong>和<strong>Clothes中的Cloth对象</strong>并<strong>不是同一个对象</strong>,注入过程中,对mBlueCloth注入时会调用一次getBlueCloth方法,<strong>创建了一个Cloth对象</strong>;注入mClothes时又会调用一次getBlueCloth方法,这时<strong>又会创建一个Cloth对象</strong>,所以才会出现上面的结果.但是如果需要MainActivity中的mBlueCloth对象和mClothes中的mBlueCloth对象是<strong>同一个对象</strong>又要怎么办呢?Dagger2为我们提供了<strong>@Singleton</strong>注解,和名字一样,这个注解的作用就是<strong>声明单例模式</strong>,我们先看看它怎么使用,下面再讲原理.</p>
</blockquote>
<p><strong>首先,在getRedCloth方法上添加该注解</strong></p>
<pre><code>@Provides
@Named(&quot;blue&quot;)
@Singleton
public Cloth getBlueCloth() {
    Cloth cloth = new Cloth();
    cloth.setColor(&quot;蓝色&quot;);
    return cloth;
}
</code></pre><p><strong>再在MainComponent接口上添加该注解</strong></p>
<pre><code>@Singleton
@Component(modules = MainModule.class)
public interface MainComponent {
    void inject(MainActivity mainActivity);
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo3.png" alt=""></p>
<blockquote>
<p>有没有发现,MainActivity中的Cloth对象和Clothes中的Cloth对象是同一个对象了,是不是很神奇!</p>
</blockquote>
<p><strong>Scope</strong></p>
<blockquote>
<p>@Singleton是怎么实现的呢?我们先看看<strong>@Scope注解</strong>,弄懂它,@Singleton你也就会明白了,下面我们就来分析分析<br>顾名思义,@Scope就是用来<strong>声明作用范围的</strong>.@Scope和@Qulifier一样,需要我们<strong>自定义注解才能使用,</strong>我们先自定义一个注解:</p>
</blockquote>
<pre><code>@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface PreActivity {
}
</code></pre><blockquote>
<p>这个注解有什么用呢?答案就是<strong>声明作用范围</strong>,当我们将这个注解使用在Module类中的Provide方法上时,就是声明这个Provide方法是在PerActivity作用范围内的,并且当一个Component要引用这个Module时,必须也要声明这个Component是PerActivity作用范围内的,否则就会报错,声明方法也很简单,就是在Component接口上使用这个注解.但是我们声明这个作用范围又有什么用呢?</p>
<p>原来Dagger2有这样一个机制:在同一个作用范围内,Provide方法<strong>提供的依赖对象就会变成单例</strong>,也就是说依赖需求方不管依赖几次Provide方法提供的依赖对象,Dagger2都<strong>只会调用一次这个方法</strong>.就和上面那个例子一样,正常情况下,在注入MainActivity中的mBlueCloth对象时会调用一次getBlueCloth方法,注入mClothes对象时因为依赖Cloth对象,所以又会调用一次getBlueCloth方法,导致这两个Cloth对象并不是同一个实例.但是我们给它<strong>声明作用范围</strong>后,这两次对Cloth的依赖<strong>只会调用一次getBlueCloth方法</strong>,这样这两个Cloth对象就是同一实例了,这样就保证了在给MainActivity注入时,所有声明的<strong>Cloth</strong>依赖都是指向同一个实例.(注意:只有Module类中声明了作用范围的Provide方法才能实现单例,没声明的方法就不是单例的)</p>
<p>查看源码你会发现Singleton其实是<strong>继承@Scope注解的</strong>,所以你知道了Singleton是怎么实现单例模式的吧.</p>
<p>可能有些读者可能会问,Dagger2既然有了Singleton为什么还要我们<strong>自定义PerActivity注解</strong>?这就涉及到<strong>代码可读性</strong>了,当<strong>依赖需求方是Activity</strong>时,我们可以自定义一个PerActivity注解,当<strong>依赖需求方是Fragment时</strong>,我们又可以自定义一个PerFragment注解,这样我们就能清楚的区分依赖对象的提供目标了.</p>
<p>那我们通过<strong>构造函数提供依赖的方式又要怎么声明作用范围</strong>呢?答案就是在<strong>类名上使用注解标明</strong>,<strong>切记不要在构造函数上用注解标明,这样是无效的</strong>.<br>读者可以试试用PerActivity注解代替上面例子中的Singleton注解,你会发现效果是一样的.</p>
<p><strong>注意注意注意</strong>:单例是在<strong>同一个Component实例提供依赖的前提下才有效的</strong>,<strong>不同的Component实例只能通过Component依赖才能实现单例</strong>.也就是说,你虽然在两个Component接口上都添加了PerActivity注解,但是这两个Component提供依赖时是<strong>没有联系</strong>的,他们<strong>只能在各自的范围内实现单例</strong>.(下面会降到)</p>
</blockquote>
<h4 id="组件依赖dependencies的使用"><a href="#组件依赖dependencies的使用" class="headerlink" title="组件依赖dependencies的使用"></a>组件依赖dependencies的使用</h4><blockquote>
<p>在实际开发中,我们经常会使用到工具类,工具类一般在<strong>整个App的生命周期内都是单例的</strong>,我们现在给我们的Demo添加一个工具类ClothHandler:</p>
</blockquote>
<pre><code>public class ClothHandler {
    public Clothes handle(Cloth cloth){
        return new Clothes(cloth);
    }
}
</code></pre><blockquote>
<p>它的功能就是<strong>将cloth加工成clothes,</strong>假设我们现在有<strong>两个Activity</strong>中都要使用该工具类,我们要怎么使用Dagger2帮我们注入呢?</p>
<p>我们先用上面所学的方法试试,先在MainModule中添加提供方法:</p>
</blockquote>
<pre><code>@Module
public class MainModule {
     .....
    @PerActivity
    @Provides
    public ClothHandler getClothHandler(){
        return new ClothHandler();
    }
}
</code></pre><blockquote>
<p>再在MainActivity中声明依赖</p>
</blockquote>
<pre><code>public class MainActivity extends AppCompatActivity {
        .....    
    @Inject
    ClothHandler mClothHandler;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ......
    mTextView.setText(&quot;红布料加工后变成了&quot; + mClothHandler.handle(mRedCloth) + &quot;\nmClothHandler地址:&quot; + mClothHandler);
    }
    //在布局文件中声明的点击方法
    public void onclick(View view) {
        Intent intent = new Intent(this,SecondActivity.class);
        startActivity(intent);
    }
}
</code></pre><blockquote>
<p>同理在书写第二个Activity,并为它书写Module类Component接口</p>
</blockquote>
<pre><code>public class SecondActivity extends AppCompatActivity {
    private TextView tv;
    @Inject
    Cloth mBlueCloth;
    @Inject
    ClothHandler mClothHandler;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
        tv = (TextView) findViewById(R.id.tv2);
        SecondComponent component = DaggerSecondComponent.builder()
                .secondModule(new SecondModule())
                .build();
        component.inject(this);
        tv.setText(&quot;蓝布料加工后变成了&quot; + mClothHandler.handle(mBlueCloth) + &quot;\nmClothHandler地址:&quot; + mClothHandler);
    }
}

@Module
public class SecondModule {
    @PreActivity
    @Provides
    public Cloth getBlueCloth(){
        Cloth cloth = new Cloth();
        cloth.setColor(&quot;蓝色&quot;);
        return cloth;
    }
    @PreActivity
    @Provides
    public ClothHandler getClothHandler(){
        return new ClothHandler();
    }
}

@Component(modules = SecondModule.class)
@PreActivity
public interface SecondComponent {
    void inject(SecondActivity secondActivity);
}
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo4.png" alt=""><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo5.png" alt=""></p>
<blockquote>
<p>你会发现,虽然我们成功的将ClothHandler注入到了这两个Activity中,但是你会发现,这两个Activity中的ClothHandler<strong>实例不是一样的</strong>(验证了上面那个结论),并且我们发现这种注入方式要在每一个Module中都要提供getClothHandler方法, 假如有20个Activity都需要用到ClothHandler,那我们都这样写,不就代码重复了吗.并且我们还要实现单例,怎么办呢?Dagger2很贴心的为我们<strong>提供了Component依赖</strong>,就能完美的解决这个问题.</p>
<p>在面向对象的思想中,我们碰到这种情况一般都要<strong>抽取父类,</strong>Dagger2也是用的这种思想,我们先创建一个<strong>BaseModule</strong>,用来提供工具类:</p>
</blockquote>
<pre><code>@Module
public class BaseModule {
    @Singleton //单例
    @Provides
    public ClothHandler getClothHandler(){
        return new ClothHandler();
    }
}
</code></pre><blockquote>
<p>在创建一个BaseComponent接口:</p>
</blockquote>
<pre><code>@Singleton
@Component(modules = BaseModule.class)
public interface BaseComponent {
    ClothHandler getClothHandler();
}
</code></pre><blockquote>
<p>嗯?</p>
<p>这个Component怎么有点不一样,怎<strong>么没有inject方法呢?</strong>上面讲过,我们通过inject方法依赖需求方实例送到Component中,从而帮助依赖需求方实现依赖,但是我们<strong>这个BaseComponent是给其他Component提供依赖的</strong>,所以我们就可以不用inject方法,但是BaseComponent中多了一个<strong>getClothHandler方法,它的返回值是ClothHandler对象</strong>,这个方法有什么用呢?它的作用就是告诉<strong>依赖于BaseComponent的Component</strong>,<strong>BaseComponent能为你们提供ClothHandler对象</strong>,如果没有这个方法,BaseComponent就不能提供ClothHandler对象(这个提供规则和上面的依赖规则相同,可以实现单例).既然有了BaseComponent,那我们就可在其它Component中依赖它了.我们删除MainModule和SecondModule中的getClothHandler方法即可。</p>
<p>接下来在MainComponent和SecondComponent中声明依赖,就要用到@Component中的dependencies属性了:</p>
</blockquote>
<pre><code>@PreActivity
@Component(modules=MainModule.class,dependencies = BaseComponent.class)
public interface MainComponent {
    void inject(MainActivity mainActivity);
}

@PreActivity
@Component(modules = SecondModule.class,dependencies = BaseComponent.class)
public interface SecondComponent {
    void inject(SecondActivity secondActivity);
}
</code></pre><blockquote>
<p>下面我们用Android Studio中build菜单下的Rebuild Object选项后,你会发现创建MainComponent和SecondComponent实例时多了一个baseComponent方法:</p>
</blockquote>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo6.png" alt=""> <img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo7.png" alt=""></p>
<blockquote>
<p>这个方法需要我们传入一个<strong>BaseComponent实例</strong>,原因很简单,MainComponent和SecondComponent既然<strong>依赖BaseComponent</strong>,肯定需要你传入一个<strong>BaseComponent实例</strong>给它,它才能从BaseComponent实例中获取到它需要的对象嘛.但是需要注意的是,如果要MainComponent和SecondComponent依赖到的对象是同一个的话(<strong>也就是单例</strong>),创建它们是<strong>传入的BaseComponent实例也必须是同一个</strong>,上面说过,不同的Component实例是无法提供相同的依赖实例的,因为它们之间是没有联系的.这样的话,我们就需要在MainActivity和SecondActivity中能获取到同一个BaseComponent实例,怎么样能实现呢?很多人一开始都会想到用<strong>静态工厂</strong>,这种方法可行,但是我们一般都会自定义一个<strong>Application类</strong>,用它来提供BaseComponent实例,因为在<strong>整个App生命周期内都只有一个Application实例</strong>,所以其中的BaseComponent实例也不会变.我们自定义一个MyApplication类</p>
</blockquote>
<pre><code>public class MyApplication extends Application {
    private BaseComponent baseComponent;
    @Override
    public void onCreate() {
        super.onCreate();
        baseComponent = DaggerBaseComponent.builder().baseModule(new BaseModule()).build();
    }

    public BaseComponent getBaseComponent() {
        return baseComponent;
    }
}
</code></pre><blockquote>
<p>我们在onCreate方法中创建BaseComponent实例,并对外提供获取方法.<br>这种方式还有一种好处,就是当我们在BaseModule中需要用到Application实例时,我们就可以在创建BaseModule时传入this.</p>
<p>接下来在AndroidManifest.xml中声明我们新建的MyApplication</p>
<p>接下来修改MainActivity和SecondActivity中的代码</p>
</blockquote>
<pre><code>MainComponent build = DaggerMainComponent
                .builder()
                .baseComponent(((MyApplication)getApplication()).getBaseComponent())
                .mainModule(new MainModule())
                .build();

SecondComponent component = DaggerSecondComponent
                .builder()
                .baseComponent(((MyApplication)getApplication()).getBaseComponent())
                .secondModule(new SecondModule())
                .build();
</code></pre><p><strong>运行结果</strong></p>
<p><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo8.png" alt=""><img src="http://o9zgq2ik9.bkt.clouddn.com/dagger2demo9.png" alt=""></p>
<blockquote>
<p>我们成功的将ClothHandler注入到了这两个Activity中,并且还实现了单例.(注意:这里能实现单例跟BaseComponent中声明了@Singleton有很大关系,因为BaseComponent都没有单例的话,外部依赖它的Component就更不可能单例了).</p>
</blockquote>
<h4 id="Component的生命周期"><a href="#Component的生命周期" class="headerlink" title="Component的生命周期"></a>Component的生命周期</h4><blockquote>
<p>一般情况下我们都是在Activity的onCreate方法中创建Component实例,再调用inject方法完成依赖.所以Component依赖可以分为三个过程:</p>
</blockquote>
<ul>
<li><p>创建Component实例</p>
<p>  MainComponent component = DaggerMainComponent</p>
<pre><code>.builder()
.baseComponent(((MyApplication)getApplication()).getBaseComponent())
.mainModule(new MainModule())
.build();
</code></pre></li>
<li><p>调用inject方法</p>
<p>  component.inject(this);</p>
</li>
</ul>
<blockquote>
<p>调用完这个方法整个依赖就完成了.</p>
</blockquote>
<ul>
<li>Component实例被销毁</li>
</ul>
<blockquote>
<p>onCreate()方法调用完成后,Component实例就会因为没有被引用而被垃圾回收器回收.其中传入给Component实例的Module实例也会一同被回收,这也就能说明不同的Component实例之间是没有联系的(Component依赖除外).</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>至此,Dagger2<strong>基础</strong>已讲完,对于Dagger2在项目中的使用方法,可以参考github上的开源项目.</p>
<p>最后我们引用一下<a href="http://blog.piasy.com/2016/04/11/Dagger2-Scope-Instance/" target="_blank" rel="external">Dagger2 Scope 注解能保证依赖在 component 生命周期内的单例性吗？</a>中的注意事项:</p>
</blockquote>
<ul>
<li>component 的 inject 函数不要声明基类参数；</li>
<li>Scope 注解必须用在 module 的 provide 方法上，否则并不能达到局部单例的效果；</li>
<li>如果 module 的 provide 方法使用了 scope 注解，那么 component 就必须使用同一个注解，否则编译会失败；</li>
<li>如果 module 的 provide 方法没有使用 scope 注解，那么 component 和 module 是否加注解都无关紧要，可以通过编译，但是没有局部单例效果；</li>
<li>对于直接使用 @Inject 构造函数的依赖，如果把 scope 注解放到它的类上，而不是构造函数上，就能达到局部单例的效果了；</li>
<li>被依赖的Component能提供某个对象时,一定要在接口中声明以该对象为返回值的方法(也就是<strong>暴露接口</strong>).这样依赖它的Component才能获取到这种对象.</li>
</ul>
<blockquote>
<p><a href="https://github.com/sh2zqp/Dagger2Demo" target="_blank" rel="external">源码入口</a></p>
</blockquote>
<p><strong>参考资料</strong></p>
<p><a href="https://google.github.io/dagger/" target="_blank" rel="external">Google官方介绍</a><br><a href="https://dreamerhome.github.io/2016/07/07/dagger/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">依赖注入神器：Dagger2详解系列</a><br><a href="http://www.jianshu.com/p/1d84ba23f4d2" target="_blank" rel="external">Dagger2 入门,以初学者角度</a><br><a href="https://github.com/luxiaoming/dagger2Demo" target="_blank" rel="external">Dagger2图文完全教程</a><br><a href="http://blog.piasy.com/2016/04/11/Dagger2-Scope-Instance/" target="_blank" rel="external">Dagger2 Scope 注解能保证依赖在 component 生命周期内的单例性吗？</a><br><a href="https://github.com/codeestX/GeekNews" target="_blank" rel="external">GeekNews</a></p>

      
    </div>

    <div>
      
        
<div id="wechat_subscriber" style="display: block； padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.jpg" alt="QinPeng Zhu wechat" style="width: 200px; max-width: 100%;"/>
    <div>扫一扫，关注我的公众号获取更多资讯！</div>
</div>

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>学习分享，感谢鼓励！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/uploads/images/wechat-reward-image.png" alt="QinPeng Zhu WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/uploads/images/alipay-reward-image.png" alt="QinPeng Zhu Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/笔记/" rel="tag">#笔记</a>
          
            <a href="/tags/注解/" rel="tag">#注解</a>
          
            <a href="/tags/Dagger2/" rel="tag">#Dagger2</a>
          
            <a href="/tags/依赖注入/" rel="tag">#依赖注入</a>
          
            <a href="/tags/Ioc/" rel="tag">#Ioc</a>
          
            <a href="/tags/控制反转/" rel="tag">#控制反转</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/08/Android内存优化之OOM/" rel="next" title="Android内存优化之OOM">
                <i class="fa fa-chevron-left"></i> Android内存优化之OOM
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/22/阅读记录/" rel="prev" title="阅读记录">
                阅读记录 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/12/21/Dagger2 入门详解/"
     data-title="Dagger2 入门详解"
     data-content=""
     data-url="http://yoursite.com/2016/12/21/Dagger2 入门详解/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/12/21/Dagger2 入门详解/"
           data-title="Dagger2 入门详解" data-url="http://yoursite.com/2016/12/21/Dagger2 入门详解/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            本站概覽
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.gif"
               alt="QinPeng Zhu" />
          <p class="site-author-name" itemprop="name">QinPeng Zhu</p>
          <p class="site-description motion-element" itemprop="description">Android开发爱好者</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分類</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">61</span>
                <span class="site-state-item-name">標籤</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/sh2zqp" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              站点导航
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://developers.google.cn/" title="Google Developers" target="_blank">Google Developers</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hukai.me/android-training-course-in-chinese/index.html" title="Android官方培训课程中文版" target="_blank">Android官方培训课程中文版</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://gold.xitu.io/welcome" title="掘金" target="_blank">掘金</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://gank.io/" title="干货集中营" target="_blank">干货集中营</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://itscoder.com/" title="itscoder" target="_blank">itscoder</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jcodecraeer.com/" title="泡在网上的日子" target="_blank">泡在网上的日子</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://toutiao.io/" title="开发者头条" target="_blank">开发者头条</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.oschina.net/android" title="开源中国社区" target="_blank">开源中国社区</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jianshu.com/" title="简书" target="_blank">简书</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://droidyue.com/" title="技术小黑屋" target="_blank">技术小黑屋</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.androiddevtools.cn/" title="AndroidDevTools" target="_blank">AndroidDevTools</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jikedaohang.com/" title="极客导航" target="_blank">极客导航</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://tech.youzan.com/" title="有赞技术博客" target="_blank">有赞技术博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://p.codekk.com/" title="codeKK" target="_blank">codeKK</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.imooc.com/" title="慕课网" target="_blank">慕课网</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jikexueyuan.com/" title="极客学院" target="_blank">极客学院</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.liaoxuefeng.com/" title="廖雪峰" target="_blank">廖雪峰</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/guolin_blog" title="郭霖" target="_blank">郭霖</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/eclipsexys" title="徐宜生" target="_blank">徐宜生</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://drakeet.me/" title="Drakeet" target="_blank">Drakeet</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://stormzhang.com/" title="stormzhang" target="_blank">stormzhang</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://wuxiaolong.me/" title="吴小龙同学" target="_blank">吴小龙同学</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hukai.me/" title="胡凯" target="_blank">胡凯</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.ruanyifeng.com/blog/" title="阮一峰" target="_blank">阮一峰</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/lmj623565791" title="Hongyang" target="_blank">Hongyang</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.youmeek.com/" title="YouMeek" target="_blank">YouMeek</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是Dagger2"><span class="nav-number">1.</span> <span class="nav-text">什么是Dagger2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是依赖注入"><span class="nav-number">2.</span> <span class="nav-text">什么是依赖注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小例子"><span class="nav-number">3.</span> <span class="nav-text">小例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统做法"><span class="nav-number">3.1.</span> <span class="nav-text">传统做法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂模式"><span class="nav-number">3.2.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#手动依赖注入"><span class="nav-number">3.3.</span> <span class="nav-text">手动依赖注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖注入框架-Dagger2"><span class="nav-number">3.4.</span> <span class="nav-text">依赖注入框架(Dagger2)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dagger2主要分为三个模块"><span class="nav-number">3.4.1.</span> <span class="nav-text">Dagger2主要分为三个模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dagger2的主要工作流程"><span class="nav-number">3.4.2.</span> <span class="nav-text">Dagger2的主要工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在项目中引入Dagger2"><span class="nav-number">3.4.3.</span> <span class="nav-text">在项目中引入Dagger2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Module类注入方式"><span class="nav-number">3.4.4.</span> <span class="nav-text">Module类注入方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注解依赖对象注入方式"><span class="nav-number">3.4.5.</span> <span class="nav-text">注解依赖对象注入方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂一点的使用情况"><span class="nav-number">3.4.6.</span> <span class="nav-text">复杂一点的使用情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#依赖总结"><span class="nav-number">3.4.7.</span> <span class="nav-text">依赖总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Named和-Qulifier注解的使用"><span class="nav-number">3.4.8.</span> <span class="nav-text">@Named和@Qulifier注解的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Singleton和-Scope的使用"><span class="nav-number">3.4.9.</span> <span class="nav-text">@Singleton和@Scope的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组件依赖dependencies的使用"><span class="nav-number">3.4.10.</span> <span class="nav-text">组件依赖dependencies的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Component的生命周期"><span class="nav-number">3.4.11.</span> <span class="nav-text">Component的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">3.4.12.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright" >
  
  &copy;  2016.7.1 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QinPeng Zhu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user">访问人数</i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人次</span>
  

  
    <span class="site-pv"><i class="fa fa-eye">总访问量</i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次</span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"sh2zqp"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  






  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("xMu3WSgG1UfWACwbpv9O2x3w-gzGzoHsz", "0GMUmyCR0G0NpL3rIedejTeX");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
