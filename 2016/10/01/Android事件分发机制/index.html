<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android事件分发机制 | sh2zqp</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="ViewGroup是一组View的集合，它包含很多的子View和子ViewGroup，是Android中所有布局的父类或间接父类，像LinearLayout、RelativeLayout等都是继承自ViewGroup的。但ViewGroup实际上也是一个View，只不过比起View，它多了可以包含子View和定义布局参数的功能。这里按照View和ViewGroup两种情况去分析，其中，View特指">
<meta property="og:type" content="article">
<meta property="og:title" content="Android事件分发机制">
<meta property="og:url" content="http://yoursite.com/2016/10/01/Android事件分发机制/index.html">
<meta property="og:site_name" content="sh2zqp">
<meta property="og:description" content="ViewGroup是一组View的集合，它包含很多的子View和子ViewGroup，是Android中所有布局的父类或间接父类，像LinearLayout、RelativeLayout等都是继承自ViewGroup的。但ViewGroup实际上也是一个View，只不过比起View，它多了可以包含子View和定义布局参数的功能。这里按照View和ViewGroup两种情况去分析，其中，View特指">
<meta property="og:image" content="http://img.blog.csdn.net/20130614230234671">
<meta property="og:image" content="http://img.blog.csdn.net/20130614231001468">
<meta property="og:image" content="http://img.blog.csdn.net/20130617193504328">
<meta property="og:image" content="http://img.blog.csdn.net/20130629144048875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20130629145544984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20130629200236578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:updated_time" content="2016-10-10T06:08:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android事件分发机制">
<meta name="twitter:description" content="ViewGroup是一组View的集合，它包含很多的子View和子ViewGroup，是Android中所有布局的父类或间接父类，像LinearLayout、RelativeLayout等都是继承自ViewGroup的。但ViewGroup实际上也是一个View，只不过比起View，它多了可以包含子View和定义布局参数的功能。这里按照View和ViewGroup两种情况去分析，其中，View特指">
<meta name="twitter:image" content="http://img.blog.csdn.net/20130614230234671">
  
    <link rel="alternate" href="/atom.xml" title="sh2zqp" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">sh2zqp</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Keep Learning</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Android事件分发机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/01/Android事件分发机制/" class="article-date">
  <time datetime="2016-10-01T01:54:33.000Z" itemprop="datePublished">2016-10-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习记录/">学习记录</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android事件分发机制
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>ViewGroup是一组View的集合，它包含很多的子View和子ViewGroup，是Android中所有布局的父类或间接父类，像LinearLayout、RelativeLayout等都是继承自ViewGroup的。但ViewGroup实际上也是一个View，只不过比起View，它多了可以包含子View和定义布局参数的功能。这里按照View和ViewGroup两种情况去分析，其中，View特指不是容器的组件，而ViewGroup则是一个容器，里面可以包含前者的非容器View和ViewGroup。</strong></p>
<ul>
<li>View 的事件分发</li>
<li>ViewGroup 的事件分发</li>
<li>总结</li>
</ul>
<hr>
<h2 id="View-的事件分发"><a href="#View-的事件分发" class="headerlink" title="View 的事件分发"></a>View 的事件分发</h2><blockquote>
<p>定义一个Activity，其布局中只有一个按钮，并给按钮注册一个点击事件，如下：</p>
</blockquote>
<pre><code>button.setOnClickListener(new OnClickListener() {  
    @Override  
    public void onClick(View v) {  
        Log.d(&quot;TAG&quot;, &quot;onClick execute&quot;);  
    }  
});
</code></pre><blockquote>
<p>按钮被点击，onClick方法执行。然后再给按钮再添加一个touch事件，如下：</p>
</blockquote>
<pre><code>button.setOnTouchListener(new OnTouchListener() {  
    @Override  
    public boolean onTouch(View v, MotionEvent event) {  
        Log.d(&quot;TAG&quot;, &quot;onTouch execute, action &quot; + event.getAction());  
        return false;  
    }  
});  
</code></pre><blockquote>
<p>onTouch方法能够执行的逻辑要更复杂一些，如判断手指按下、抬起、移动等事件。</p>
</blockquote>
<p><strong>问题来了，哪一个会先执行呢？</strong></p>
<blockquote>
<p>运行程序点击按钮，打印结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130614230234671" alt=""></p>
<blockquote>
<p>结果证明：onTouch是优先于onClick执行，并且onTouch执行了两次，一次是ACTION_DOWN，一次是ACTION_UP(你还可能会有多次ACTION_MOVE的执行，如果你手抖了一下)。</p>
<p>因此事件传递的顺序是先经过onTouch，再传递到onClick。</p>
</blockquote>
<p><strong>为什么会这样？</strong></p>
<blockquote>
<p>查看onTouch方法，发现其有返回值的，上面返回的是false。</p>
</blockquote>
<p><strong>如果返回true呢？</strong></p>
<blockquote>
<p>再次运行，结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130614231001468" alt=""></p>
<blockquote>
<p>onClick方法不再执行了！为什么会这样呢？</p>
<p>可以暂时理解成onTouch方法返回true就认为这个事件被onTouch消费掉了，因而不会再继续向下传递。</p>
<p>当然，我们不会仅仅满足于此，让我们深层次的去看看出现上述现象的原理到底是什么？</p>
<p>首先，你触摸到了任何控件，那一定会调用该控件的dispatchTouchEvent方法。当点击按钮的时，就会去调用Button的dispatchTouchEvent方法，可Button里没有这个方法，那就去它父类TextView里找，发现TextView也没有，继续在TextView的父类View里找，Bingo，终于找到了。</p>
<p>然后，重点来了，看一下View中dispatchTouchEvent方法的源码吧！</p>
</blockquote>
<pre><code>public boolean dispatchTouchEvent(MotionEvent event) {  
    if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  
            mOnTouchListener.onTouch(this, event)) {  
        return true;  
    }  
    return onTouchEvent(event);  
}  
</code></pre><blockquote>
<p>简洁，只有几行代码！先是一个判断，如果mOnTouchListener != null，(mViewFlags &amp; ENABLED_MASK) == ENABLED和mOnTouchListener.onTouch(this, event)这三个条件都为真，就返回true，否则就去执行onTouchEvent(event)方法并返回。_</p>
<p>第一个条件，mOnTouchListener变量是在哪赋值的呢？寻找之后在View里发现了如下方法：</p>
</blockquote>
<pre><code>public void setOnTouchListener(OnTouchListener l) {  
    mOnTouchListener = l;  
}  
</code></pre><blockquote>
<p>Bingo！mOnTouchListener是在这里赋值的，也就是说，只要给控件注册了touch事件，mOnTouchListener就一定被赋值了，也就不为null了。</p>
<p>第二个条件，(mViewFlags &amp; ENABLED_MASK) == ENABLED，判断当前点击的控件是否是enable的，按钮默认都是enable的，因此这个条件恒定为true。_</p>
<p>第三个条件，mOnTouchListener.onTouch(this, event)，关键点，回调控件注册touch事件时的onTouch方法。如果在onTouch方法里返回true，这三个条件全部成立，从而整个方法直接返回true。如果在onTouch方法里返回false，就会再去执行onTouchEvent(event)方法。</p>
<p>结合前面的例子综合分析一下，先在dispatchTouchEvent中最先执行的是onTouch方法，因此onTouch要先于onClick执行，也印证了刚刚的打印结果。而如果在onTouch方法里返回了true，就会让dispatchTouchEvent方法直接返回true，不会再继续往下执行。而打印结果也证实了如果onTouch返回true，其onTouchEvent(event)方法也就不再执行了， onClick也就不会再执行了(后面我们知道，onClick方法就是在onTouchEvent(event)方法里执行的)。</p>
<p>根据以上分析，从原理上解释了前面例子的运行结果。那我们就来看下onTouchEvent的源码，看看onClick方法是不是真的在里面，如下所示：</p>
</blockquote>
<pre><code>1.  public boolean onTouchEvent(MotionEvent event) {  
2.      final int viewFlags = mViewFlags;  
3.      if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {  
4.          // A disabled view that is clickable still consumes the touch  
5.          // events, it just doesn&apos;t respond to them.  
6.          return (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  
7.                  (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));  
8.      }  
9.      if (mTouchDelegate != null) {  
10.         if (mTouchDelegate.onTouchEvent(event)) {  
11.             return true;  
12.         }  
13.     }  
14.     if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  
15.             (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {  
16.         switch (event.getAction()) {  
17.             case MotionEvent.ACTION_UP:  
18.                 boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0;  
19.                 if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) {  
20.                     // take focus if we don&apos;t have it already and we should in  
21.                     // touch mode.  
22.                     boolean focusTaken = false;  
23.                     if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {  
24.                         focusTaken = requestFocus();  
25.                     }  
26.                     if (!mHasPerformedLongPress) {  
27.                         // This is a tap, so remove the longpress check  
28.                         removeLongPressCallback();  
29.                         // Only perform take click actions if we were in the pressed state  
30.                         if (!focusTaken) {  
31.                             // Use a Runnable and post this rather than calling  
32.                             // performClick directly. This lets other visual state  
33.                             // of the view update before click actions start.  
34.                             if (mPerformClick == null) {  
35.                                 mPerformClick = new PerformClick();  
36.                             }  
37.                             if (!post(mPerformClick)) {  
38.                                 performClick();  
39.                             }  
40.                         }  
41.                     }  
42.                     if (mUnsetPressedState == null) {  
43.                         mUnsetPressedState = new UnsetPressedState();  
44.                     }  
45.                     if (prepressed) {  
46.                         mPrivateFlags |= PRESSED;  
47.                         refreshDrawableState();  
48.                         postDelayed(mUnsetPressedState,  
49.                                 ViewConfiguration.getPressedStateDuration());  
50.                     } else if (!post(mUnsetPressedState)) {  
51.                         // If the post failed, unpress right now  
52.                         mUnsetPressedState.run();  
53.                     }  
54.                     removeTapCallback();  
55.                 }  
56.                 break;  
57.             case MotionEvent.ACTION_DOWN:  
58.                 if (mPendingCheckForTap == null) {  
59.                     mPendingCheckForTap = new CheckForTap();  
60.                 }  
61.                 mPrivateFlags |= PREPRESSED;  
62.                 mHasPerformedLongPress = false;  
63.                 postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  
64.                 break;  
65.             case MotionEvent.ACTION_CANCEL:  
66.                 mPrivateFlags &amp;= ~PRESSED;  
67.                 refreshDrawableState();  
68.                 removeTapCallback();  
69.                 break;  
70.             case MotionEvent.ACTION_MOVE:  
71.                 final int x = (int) event.getX();  
72.                 final int y = (int) event.getY();  
73.                 // Be lenient about moving outside of buttons  
74.                 int slop = mTouchSlop;  
75.                 if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) ||  
76.                         (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) {  
77.                     // Outside button  
78.                     removeTapCallback();  
79.                     if ((mPrivateFlags &amp; PRESSED) != 0) {  
80.                         // Remove any future long press/tap checks  
81.                         removeLongPressCallback();  
82.                         // Need to switch from pressed to not pressed  
83.                         mPrivateFlags &amp;= ~PRESSED;  
84.                         refreshDrawableState();  
85.                     }  
86.                 }  
87.                 break;  
88.         }  
89.         return true;  
90.     }  
91.     return false;  
92. } 
</code></pre><p><strong>比较长，挑重点看</strong></p>
<blockquote>
<p>在第14行我们可以看出，如果该控件是可以点击的就会进入到第16行的switch判断中去，而如果当前的事件是抬起手指，则会进入到MotionEvent.ACTION_UP这个case当中。在经过种种判断之后，会执行到第38行的performClick()方法，那就看看这个方法：_</p>
</blockquote>
<pre><code>public boolean performClick() {  
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  
    if (mOnClickListener != null) {  
        playSoundEffect(SoundEffectConstants.CLICK);  
        mOnClickListener.onClick(this);  
        return true;  
    }  
    return false;  
} 
</code></pre><p><strong>舒服多了</strong></p>
<blockquote>
<p>看到mOnClickListener.onClick(this)，我们就更开心了，只要mOnClickListener不是null，就会去调用它，那mOnClickListener又是在哪里赋值的呢？看下面：</p>
</blockquote>
<pre><code>public void setOnClickListener(OnClickListener l) {  
    if (!isClickable()) {  
        setClickable(true);  
    }  
    mOnClickListener = l;  
}  
</code></pre><blockquote>
<p>一切都清楚了！当调用setOnClickListener方法来给控件注册一个点击事件时，就会给mOnClickListener赋值。然后每当控件被点击时，都会在performClick()方法里回调被点击控件的onClick方法。</p>
<p>整个事件分发的流程似乎就这样要结束了，不，还有一个要重点说明的是touch事件的层级传递。如果给一个控件注册了touch事件，每次点击它的时候都会触发一系列的ACTION_DOWN，ACTION_MOVE，ACTION_UP等事件，简称为事件流，请注意，如果你在执行ACTION_DOWN的时候返回了false，那么这个事件流就会被中断执行。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个action事件返回true，才会触发后一个action 事件。</p>
</blockquote>
<p><strong>这不是自相矛盾吗？</strong></p>
<blockquote>
<p>前面的例子中，明明在onTouch事件里面返回了false，ACTION_DOWN和ACTION_UP不是都得到执行了吗？其实你只是被假象所迷惑了，仔细分析一下代码，就会知道在前面的例子当中，我们到底返回的是什么。首先在onTouch事件里返回了false，就一定会进入到onTouchEvent方法中，然后我们来看一下onTouchEvent方法的细节。_由于点击了按钮且按钮是可点击的_，就会进入到第14行这个if判断的内部，然后你会发现，不管当前的action是什么，最终都一定会走到第89行，返回一个true。</p>
</blockquote>
<p><strong>是不是有一种被欺骗的感觉？</strong></p>
<blockquote>
<p>明明在onTouch事件里返回了false，系统还是在onTouchEvent方法中帮你返回了true。就因为这个原因，才使得前面的例子中ACTION_UP可以得到执行。_</p>
<p>我们可以换一个控件，将按钮替换成ImageView，然后给它也注册一个touch事件，并返回false。如下所示：</p>
</blockquote>
<pre><code>imageView.setOnTouchListener(new OnTouchListener() {  
    @Override  
    public boolean onTouch(View v, MotionEvent event) {  
        Log.d(&quot;TAG&quot;, &quot;onTouch execute, action &quot; + event.getAction());  
        return false;  
    }  
});  
</code></pre><blockquote>
<p>运行程序，点击ImageView，结果如下</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130617193504328" alt=""></p>
<blockquote>
<p>在ACTION_DOWN执行完后，后面的一系列action事件都不会得到执行了。这又是为什么呢？因为ImageView和按钮不同，它是默认不可点击的，因此在onTouchEvent的第14行判断时无法进入到if的内部，直接跳到第91行返回了false，也就导致后面其它的action都无法执行了。View的事件分发，就到这里。</p>
</blockquote>
<hr>
<h2 id="ViewGroup的事件分发"><a href="#ViewGroup的事件分发" class="headerlink" title="ViewGroup的事件分发"></a>ViewGroup的事件分发</h2><blockquote>
<p>首先，自定义一个布局为MyLayout，继承自LinearLayout，如下：</p>
</blockquote>
<pre><code>public class MyLayout extends LinearLayout {  
    public MyLayout(Context context, AttributeSet attrs) {  
        super(context, attrs);  
    }  
}  
</code></pre><blockquote>
<p>然后，打开布局文件activity_main.xml，在其中加入自定义的布局MyLayout，如下：</p>
</blockquote>
<pre><code>&lt;com.example.viewgrouptouchevent.MyLayout 
        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:id=&quot;@+id/my_layout&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    android:orientation=&quot;vertical&quot; &gt;  
    &lt;Button  
        android:id=&quot;@+id/button1&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Button1&quot; /&gt;  
    &lt;Button  
        android:id=&quot;@+id/button2&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Button2&quot; /&gt;  
&lt;/com.example.viewgrouptouchevent.MyLayout&gt;  
</code></pre><blockquote>
<p>在MyLayout中添加了两个按钮，最后在MainActivity中为这两个按钮和MyLayout注册监听事件：</p>
</blockquote>
<pre><code>myLayout.setOnTouchListener(new OnTouchListener() {  
    @Override  
    public boolean onTouch(View v, MotionEvent event) {  
        Log.d(&quot;TAG&quot;, &quot;myLayout on touch&quot;);  
        return false;  
    }  
});  
button1.setOnClickListener(new OnClickListener() {  
    @Override  
    public void onClick(View v) {  
        Log.d(&quot;TAG&quot;, &quot;You clicked button1&quot;);  
    }  
});  
button2.setOnClickListener(new OnClickListener() {  
    @Override  
    public void onClick(View v) {  
        Log.d(&quot;TAG&quot;, &quot;You clicked button2&quot;);  
    }  
});  
</code></pre><blockquote>
<p>运行项目，分别点击一下Button1、Button2和空白区域，打印结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130629144048875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<blockquote>
<p>当点击按钮的时，MyLayout注册的onTouch方法并不会执行，只有点击空白区域的时候才会执行该方法。可以先暂时理解成Button的onClick方法将事件消费掉了，因此事件不会再继续向下传递。</p>
<p>Android中的touch事件是先传递到View，再传递到ViewGroup的？</p>
</blockquote>
<p><strong>结论下的太早，做个实验</strong></p>
<blockquote>
<p>ViewGroup中有一个onInterceptTouchEvent方法，我们来看一下这个方法的源码：</p>
</blockquote>
<pre><code>public boolean onInterceptTouchEvent(MotionEvent ev) {  
    return false;  
} 
</code></pre><p><strong>还是这么短(注释已略去)</strong></p>
<blockquote>
<p>只有一行代码，返回一个false！既然是布尔型的返回，那么只有两种可能，我们在MyLayout中重写这个方法，然后分布返回一个true和false试试，代码如下所示：</p>
</blockquote>
<pre><code>public class MyLayout extends LinearLayout {  
    public MyLayout(Context context, AttributeSet attrs) {  
        super(context, attrs);  
    }  
    @Override  
    public boolean onInterceptTouchEvent(MotionEvent ev) {  
        return true;  
    }  
}  
</code></pre><blockquote>
<p>运行项目，分别Button1、Button2和空白区域，打印结果如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130629145544984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<blockquote>
<p>奇怪了，不管点哪里，永远都只会触发MyLayout的touch事件了，按钮的点击事件完全被屏蔽掉了！</p>
</blockquote>
<p><strong>这是为什么？</strong></p>
<blockquote>
<p>如果Android中的touch事件是先传递到View，再传递到ViewGroup的，那么MyLayout又怎么可能屏蔽掉Button的点击事件呢？</p>
<p>看来只有通过源码，才能搞清Android中ViewGroup的事件分发机制，解决心中疑惑，不过结论一定是：<strong>Android中touch事件的传递，绝对是先传递到ViewGroup，再传递到View的。</strong></p>
<p>在上一小节中，我们说过只要你触摸了任何控件，就一定会调用该控件的dispatchTouchEvent方法。这个说法没错，只不过还不完整而已。实际是，当你点击了某个控件，首先会去调用该控件所在布局的dispatchTouchEvent方法，然后在布局的dispatchTouchEvent方法中找到被点击的相应控件，再去调用该控件的dispatchTouchEvent方法。如果我们点击了MyLayout中的按钮，会先去调用MyLayout的dispatchTouchEvent方法，可是你会发现MyLayout中并没有这个方法，那就去到它的父类LinearLayout中找，发现也没有这个方法，那就继续再找LinearLayout的父类ViewGroup，终于在ViewGroup中看到了这个方法，按钮的dispatchTouchEvent方法就是在这里调用的。</p>
<p>ViewGroup中的dispatchTouchEvent方法的源码如下：</p>
</blockquote>
<pre><code>1.  public boolean dispatchTouchEvent(MotionEvent ev) {  
2.      final int action = ev.getAction();  
3.      final float xf = ev.getX();  
4.      final float yf = ev.getY();  
5.      final float scrolledXFloat = xf + mScrollX;  
6.      final float scrolledYFloat = yf + mScrollY;  
7.      final Rect frame = mTempRect;  
8.      boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;  
9.      if (action == MotionEvent.ACTION_DOWN) {  
10.         if (mMotionTarget != null) {  
11.             mMotionTarget = null;  
12.         }  
13.         if (disallowIntercept || !onInterceptTouchEvent(ev)) {  
14.             ev.setAction(MotionEvent.ACTION_DOWN);  
15.             final int scrolledXInt = (int) scrolledXFloat;  
16.             final int scrolledYInt = (int) scrolledYFloat;  
17.             final View[] children = mChildren;  
18.             final int count = mChildrenCount;  
19.             for (int i = count - 1; i &gt;= 0; i--) {  
20.                 final View child = children[i];  
21.                 if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE  
22.                         || child.getAnimation() != null) {  
23.                     child.getHitRect(frame);  
24.                     if (frame.contains(scrolledXInt, scrolledYInt)) {  
25.                         final float xc = scrolledXFloat - child.mLeft;  
26.                         final float yc = scrolledYFloat - child.mTop;  
27.                         ev.setLocation(xc, yc);  
28.                         child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
29.                         if (child.dispatchTouchEvent(ev))  {  
30.                             mMotionTarget = child;  
31.                             return true;  
32.                         }  
33.                     }  
34.                 }  
35.             }  
36.         }  
37.     }  
38.     boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  
39.             (action == MotionEvent.ACTION_CANCEL);  
40.     if (isUpOrCancel) {  
41.         mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;  
42.     }  
43.     final View target = mMotionTarget;  
44.     if (target == null) {  
45.         ev.setLocation(xf, yf);  
46.         if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) {  
47.             ev.setAction(MotionEvent.ACTION_CANCEL);  
48.             mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
49.         }  
50.         return super.dispatchTouchEvent(ev);  
51.     }  
52.     if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) {  
53.         final float xc = scrolledXFloat - (float) target.mLeft;  
54.         final float yc = scrolledYFloat - (float) target.mTop;  
55.         mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
56.         ev.setAction(MotionEvent.ACTION_CANCEL);  
57.         ev.setLocation(xc, yc);  
58.         if (!target.dispatchTouchEvent(ev)) {  
59.         }  
60.         mMotionTarget = null;  
61.         return true;  
62.     }  
63.     if (isUpOrCancel) {  
64.         mMotionTarget = null;  
65.     }  
66.     final float xc = scrolledXFloat - (float) target.mLeft;  
67.     final float yc = scrolledYFloat - (float) target.mTop;  
68.     ev.setLocation(xc, yc);  
69.     if ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) {  
70.         ev.setAction(MotionEvent.ACTION_CANCEL);  
71.         target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
72.         mMotionTarget = null;  
73.     }  
74.     return target.dispatchTouchEvent(ev);  
75. }  
</code></pre><p><strong>挑重点看</strong></p>
<blockquote>
<p>首先，在第13行处有一个条件判断，如果disallowIntercept和!onInterceptTouchEvent(ev)两者有一个为true，就会进入到这个条件判断中。disallowIntercept是指是否禁用掉事件拦截的功能，默认是false，也可以通过调用requestDisallowInterceptTouchEvent方法对这个值进行修改。那么当第一个值为false的时候就会完全依赖第二个值来决定是否可以进入到条件判断的内部，第二个值是什么呢？竟然就是对onInterceptTouchEvent方法的返回值取反！也就是说如果我们在onInterceptTouchEvent方法中返回false，就会让第二个值为true，从而进入到条件判断的内部，如果我们在onInterceptTouchEvent方法中返回true，就会让第二个值为false，从而跳出了这个条件判断。</p>
<p>由于我们在MyLayout中重写了onInterceptTouchEvent方法，让这个方法返回true，导致所有按钮的点击事件都被屏蔽了，那我们就完全有理由相信，按钮点击事件的处理就是在第13行条件判断的内部进行的！那重点看下条件判断的内部是怎么实现的。在第19行通过一个for循环，遍历了当前ViewGroup下的所有子View，然后在第24行判断当前遍历的View是不是正在点击的View，如果是的话就会进入到该条件判断的内部，然后在第29行调用了该View的dispatchTouchEvent，之后就是上节讲的View的事件分发了。</p>
<p>然后需要注意，调用子View的dispatchTouchEvent后是有返回值的。我们已经知道，如果一个控件是可点击的，那么点击该控件时，dispatchTouchEvent的返回值必定是true。因此会导致第29行的条件判断成立，于是在第31行给ViewGroup的dispatchTouchEvent方法直接返回了true。这样就导致后面的代码无法执行到了，也是印证了我们前面的Demo打印的结果，如果按钮的点击事件得到执行，就会把MyLayout的touch事件拦截掉。</p>
<p>如果我们点击的不是按钮，而是空白区域呢？这种情况就一定不会在第31行返回true了，而是会继续执行后面的代码。那我们继续往后看，在第44行，如果target等于null，就会进入到该条件判断内部，这里一般情况下target都会是null，因此会在第50行调用super.dispatchTouchEvent(ev)。这句代码会调用到哪里呢？当然是View中的dispatchTouchEvent方法了，因为ViewGroup的父类就是View。之后的处理逻辑又和前面所说的是一样的了，也因此MyLayout中注册的onTouch方法会得到执行。之后的代码在一般情况下是走不到的了，我们也就不再继续往下分析。</p>
<p>ViewGroup事件分发过程的流程图如下：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20130629200236578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<blockquote>
<p>现在整个ViewGroup的事件分发流程的分析也就到此结束了，我们最后再来简单梳理一下吧。</p>
</blockquote>
<ol>
<li>Android事件分发是先传递到ViewGroup，再由ViewGroup传递到View的。</li>
<li>在ViewGroup中可以通过onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。</li>
<li>子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>onTouch和onTouchEvent区别，如何使用？</li>
</ol>
<blockquote>
<p>这两个方法都是在View的dispatchTouchEvent中调用的，onTouch先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一，mOnTouchListener的值不能为空，第二，当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。</p>
</blockquote>
<ol>
<li>为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？</li>
</ol>
<blockquote>
<blockquote>
<p>滑动菜单的功能是通过给ListView注册了一个touch事件来实现的。如果你在onTouch方法里处理完了滑动逻辑后返回true，那么ListView本身的滚动事件就被屏蔽了，自然也就无法滑动，因此解决办法就是在onTouch方法里返回false。</p>
</blockquote>
</blockquote>
<ol>
<li>为什么图片轮播器里的图片使用Button而不用ImageView？</li>
</ol>
<blockquote>
<p>因为Button是可点击的，而ImageView是不可点击的。如果想要使用ImageView，可以有两种改法。第一，在ImageView的onTouch方法里返回true，这样可以保证ACTION_DOWN之后的其它action都能得到执行，才能实现图片滚动的效果。第二，在布局文件里面给ImageView增加一个android:clickable=”true”的属性，这样ImageView变成可点击的之后，即使在onTouch里返回了false，ACTION_DOWN之后的其它action也是可以得到执行的。</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h3><p><a href="http://blog.csdn.net/sinyu890807/article/details/9097463" target="_blank" rel="external">http://blog.csdn.net/sinyu890807/article/details/9097463</a><br><a href="http://blog.csdn.net/sinyu890807/article/details/9153747" target="_blank" rel="external">http://blog.csdn.net/sinyu890807/article/details/9153747</a><br>《Android开发艺术探索》—— <a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="external">任玉刚</a><br>《Android群英传》——<a href="http://blog.csdn.net/eclipsexys" target="_blank" rel="external"> 徐宜生</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/01/Android事件分发机制/" data-id="civaavwkq0009or9ybtrta064" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/事件分发/">事件分发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/10/04/Java中的ThreadLocal/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java中的ThreadLocal
        
      </div>
    </a>
  
  
    <a href="/2016/08/05/Android消息处理机制 — 实用易懂(1)/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android消息处理机制 — 实用易懂(1)</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习记录/">学习记录</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ANR/">ANR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AS/">AS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AndroidStudio/">AndroidStudio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FC/">FC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fresco/">Fresco</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glide/">Glide</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Handler/">Handler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OOM/">OOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OkHttp/">OkHttp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Picasso/">Picasso</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/">Retrofit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ThreadLocal/">ThreadLocal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UIL/">UIL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Volley/">Volley</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apk签名/">apk签名</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jks密钥生成/">jks密钥生成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/书籍/">书籍</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件分发/">事件分发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存优化/">内存优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图片加载/">图片加载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多渠道打包/">多渠道打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源库/">开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/打包/">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息处理机制/">消息处理机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程池/">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络请求/">网络请求</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阅读/">阅读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ANR/" style="font-size: 10px;">ANR</a> <a href="/tags/AS/" style="font-size: 10px;">AS</a> <a href="/tags/AndroidStudio/" style="font-size: 10px;">AndroidStudio</a> <a href="/tags/FC/" style="font-size: 10px;">FC</a> <a href="/tags/Fresco/" style="font-size: 10px;">Fresco</a> <a href="/tags/Glide/" style="font-size: 10px;">Glide</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Handler/" style="font-size: 16.67px;">Handler</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/OOM/" style="font-size: 13.33px;">OOM</a> <a href="/tags/OkHttp/" style="font-size: 10px;">OkHttp</a> <a href="/tags/Picasso/" style="font-size: 10px;">Picasso</a> <a href="/tags/Retrofit/" style="font-size: 10px;">Retrofit</a> <a href="/tags/ThreadLocal/" style="font-size: 10px;">ThreadLocal</a> <a href="/tags/UIL/" style="font-size: 10px;">UIL</a> <a href="/tags/Volley/" style="font-size: 10px;">Volley</a> <a href="/tags/apk签名/" style="font-size: 10px;">apk签名</a> <a href="/tags/jks密钥生成/" style="font-size: 10px;">jks密钥生成</a> <a href="/tags/书籍/" style="font-size: 10px;">书籍</a> <a href="/tags/事件分发/" style="font-size: 10px;">事件分发</a> <a href="/tags/内存优化/" style="font-size: 10px;">内存优化</a> <a href="/tags/博客/" style="font-size: 10px;">博客</a> <a href="/tags/图片加载/" style="font-size: 10px;">图片加载</a> <a href="/tags/多渠道打包/" style="font-size: 10px;">多渠道打包</a> <a href="/tags/开源库/" style="font-size: 13.33px;">开源库</a> <a href="/tags/总结/" style="font-size: 13.33px;">总结</a> <a href="/tags/打包/" style="font-size: 10px;">打包</a> <a href="/tags/消息处理机制/" style="font-size: 16.67px;">消息处理机制</a> <a href="/tags/源码/" style="font-size: 13.33px;">源码</a> <a href="/tags/笔记/" style="font-size: 20px;">笔记</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/线程池/" style="font-size: 10px;">线程池</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a> <a href="/tags/网络请求/" style="font-size: 10px;">网络请求</a> <a href="/tags/阅读/" style="font-size: 10px;">阅读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/08/阅读记录/">阅读记录</a>
          </li>
        
          <li>
            <a href="/2016/11/08/Android内存优化之OOM/">Android内存优化之OOM</a>
          </li>
        
          <li>
            <a href="/2016/10/29/AndroidStudio生成jks密钥～签名apk～多渠道打包/">AndroidStudio打包～生成jks密钥～签名apk～多渠道打包</a>
          </li>
        
          <li>
            <a href="/2016/10/28/Android中的图片加载框架/">Android中的图片加载框架</a>
          </li>
        
          <li>
            <a href="/2016/10/23/Android中网络请求框架/">Android中网络请求框架</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 QinPeng Zhu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>