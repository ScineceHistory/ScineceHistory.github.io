<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="笔记," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="概述
线程：在操作系统（OS）中，线程是OS调度的最小单元，同时又是一种受限的系统资源，不可能无限制的产生，并且其创建和销毁都会有一定的开销。当OS中存在大量的线程时，OS会通过时间片轮询的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数目小于等于CPU的核心数，一般是不可能的。
线程池：在一个进程中频繁地创建和销毁线程不是一种高效的做法，正确地做法是使用线程池。线程池中会缓存一定数目的">
<meta property="og:type" content="article">
<meta property="og:title" content="Android的线程和线程池">
<meta property="og:url" content="http://yoursite.com/2016/07/01/Android的线程和线程池/index.html">
<meta property="og:site_name" content="sh2zqp">
<meta property="og:description" content="概述
线程：在操作系统（OS）中，线程是OS调度的最小单元，同时又是一种受限的系统资源，不可能无限制的产生，并且其创建和销毁都会有一定的开销。当OS中存在大量的线程时，OS会通过时间片轮询的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数目小于等于CPU的核心数，一般是不可能的。
线程池：在一个进程中频繁地创建和销毁线程不是一种高效的做法，正确地做法是使用线程池。线程池中会缓存一定数目的">
<meta property="og:updated_time" content="2016-10-03T15:21:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android的线程和线程池">
<meta name="twitter:description" content="概述
线程：在操作系统（OS）中，线程是OS调度的最小单元，同时又是一种受限的系统资源，不可能无限制的产生，并且其创建和销毁都会有一定的开销。当OS中存在大量的线程时，OS会通过时间片轮询的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数目小于等于CPU的核心数，一般是不可能的。
线程池：在一个进程中频繁地创建和销毁线程不是一种高效的做法，正确地做法是使用线程池。线程池中会缓存一定数目的">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'ScienceHistory'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/07/01/Android的线程和线程池/"/>

  <title> Android的线程和线程池 | sh2zqp </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">sh2zqp</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android的线程和线程池
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-01T10:36:34+08:00" content="2016-07-01">
              2016-07-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/学习记录/" itemprop="url" rel="index">
                    <span itemprop="name">学习记录</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>线程：在操作系统（OS）中，线程是OS调度的最小单元，同时又是一种受限的系统资源，不可能无限制的产生，并且其创建和销毁都会有一定的开销。当OS中存在大量的线程时，OS会通过时间片轮询的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数目小于等于CPU的核心数，一般是不可能的。</p>
<p>线程池：在一个进程中频繁地创建和销毁线程不是一种高效的做法，正确地做法是使用线程池。线程池中会缓存一定数目的线程，然后通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。Android中的线程池来源于Java，主要是通过Executor来派生特定类型的线程池，不同类型的线程池又具有不同的特性。</p>
<p>按用途来划分，线程有两种：</p>
</blockquote>
<ul>
<li>主线程：处理和界面有关的事情</li>
<li>子线程：执行耗时的一些操作</li>
</ul>
<blockquote>
<p>由于Android的特性，如果在主线程中执行耗时操作，系统会无法及时地响应，并抛出ANR（应用程序无响应），因此，耗时操作必须要放在子线程中执行。</p>
<p>除了传统的Java中的Thread类表示线程外，在Android中，系统提供了自己特有的可以扮演线程角色的类，如AsyncTask，IntentService，HandlerThread（一种特殊的线程）等，需要注意的是这些类本质上仍是创痛的线程，AsyncTask底层用到了Java中的线程池，而IntentService和HandlerThread的底层则直接使用了Thread线程类。</p>
</blockquote>
<ul>
<li>AsyncTask封装了线程池和Handler，主要是方便开发者在子线程中更新UI。</li>
<li>HandlerThread是一个具有消息循环的线程，在它的内部可以使用Handler。</li>
<li>IntentService是一个服务，系统对其进行了封装，使其可以方便地执行后台任务，IntentService内部采用HandlerThread来执行任务，任务执行完毕后，其会自动退出。从任务执行的角度来看，IntentService的作用很像一个后台线程，但是IntentService是一种服务，它是不容易被系统杀死的，从而尽量保证任务的执行，而如果是一个后台线程的话，由于这个时候进程中没有活动的四大组件，那么这个进程的优先级就会非常低，会很容易被系统杀死，这是IntentService的优点。</li>
</ul>
<h3 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h3><blockquote>
<p>Android沿用Java的线程模型。</p>
</blockquote>
<h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><blockquote>
<p>主线程(UI线程)是指进程所拥有的线程，在Java中默认情况下一个进程只有一个线程，这个线程就是主线层。主线程的主要任务是处理于界面的交互相关的逻辑，在Android中就是运行四大组件以及处理和它们的交互，因为用户随时会和界面发生交互，因此主线程在任何时候都必须具有较高的响应速度，否则就会造成界面卡顿，用户体验不好。</p>
</blockquote>
<h4 id="子线程"><a href="#子线程" class="headerlink" title="子线程"></a>子线程</h4><blockquote>
<p>为了保持较高的响应速度，在主线程中就不应该执行耗时任务，这个时候子线程的作用就体现出来了。子线程又被称为工作线程，除了主线程外，其他的都是子线程。子线程就是要执行耗时任务，如网络请求，I/O操作等。Android3.0以后的系统都要求网络访问必须在子线程中进行，否则就会访问失败并抛出NetworkOnMainThreadException异常，这么做主要是避免主线程被耗时任务阻塞，造成ANR。</p>
</blockquote>
<h3 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h3><blockquote>
<p>除去传统的Thread， Android中的线程形态有AsyncTask，IntentService，HandlerThread三种，它们的底层实现也是线程，只是它们具有特殊的表现形式，同时在使用上也各有优缺点。</p>
</blockquote>
<h4 id="AsyncTask及其原理"><a href="#AsyncTask及其原理" class="headerlink" title="AsyncTask及其原理"></a>AsyncTask及其原理</h4><blockquote>
<p>为了简化子线程中访问UI的过程，系统提供了AsyncTask。不同版本API的AsyncTask具有不同的表现，尤其是在多任务并发执行上。</p>
<p>AsyncTask是一种轻量级的异步任务类，可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程中更新UI。从实现上说，AsyncTask封装了Thread和Handler，并通过AsyncTask可以更加方便的执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合执行特别耗时的后台任务，对于特别耗时的任务，建议使用线程池。</p>
<p>AsyncTask是一个抽象范型类，使用时要通过子类继承，其提供了Params，Progress，Result三个范型参数，其中Params表示参数的类型，Progress表示后台任务执行进度的类型，Result表示后台任务的返回结果类型，如果AsyncTask确实不需要传递任何参数，这三个范型参数可以使用Void来代替。AysncTask的类声明如下：</p>
</blockquote>
<pre><code>public abstract class AsyncTask&lt;Params, Progress, Result&gt;
</code></pre><blockquote>
<p>AsyncTask提供了4个核心方法，具体解释如下：</p>
</blockquote>
<ol>
<li>onProExecute(), 在主线程中执行，在异步任务执行之前，此方法会被调用，一般用于一些准备工作。</li>
<li>doInBackground(Params … params), 在线程池中执行，用于执行异步任务，params参数表示异步任务的输入参数。在此方法中可以通过调用publishProgress()方法来更新任务的进度， publishProgress()方法会触发onProgressUpdate()方法的调用。另外此方法需要返回计算结果给onPostExecute()方法。</li>
<li>onProgressUpdate(Progress … values), 在主线程中执行，当后台任务的执行进度发生改变时，此方法通过publishProgress()方法被调用。</li>
<li>onPostExecute(Result result), 在主线程中执行，当后台异步任务执行完毕之后，此方法会被调用，其中，result参数时后台异步任务的返回值，即doInBackground方法的返回值。</li>
</ol>
<blockquote>
<p>4个方法的执行顺序是：onPreExecute, doInBackground, onPostExecute. onProgressUpdate方法看情况执行，如果publishProgress方法在doInBackground方法中被调用，其执行顺序就在onPostExecute之前，否则，其不执行。除了上述4个方法外，AsyncTask也提供onCancelled()方法，当异步任务被取消时，onCancelled()方法会在主线程中被调用执行，这个时候onPostExecute方法就不会再被调用。</p>
</blockquote>
<p><strong>典型案例</strong></p>
<pre><code>private class DownLoadAsyncTask extends AsyncTask&lt;URL, Integer, Long&gt; {
    protected Long doInBackground(URL ... urls) {
        int count = urls.length;
        long totalsize = 0;
        for(int i = 0; i &lt; count; i++) {
            totalsize += Downloader.down(urls[i]);
            publishProgress((int) ((i / (float) count * 100));
            // Escape early if cancel() is called
            if(isCancelled()) {
                break;
            }
        }
        return totalsize;
    }
    protected void onProgressUpdate(Integer ... progress) {
        setProgressPercent(progress[0]);
    }
    protected void onPostExecute(Long result) {
        showDialog(&quot;Downloaded&quot; + result + &quot;bytes&quot;);
    }
}
</code></pre><blockquote>
<p>上面实现了一个具体的AsyncTask类，主要功能时模拟文件下载的过程，输入参数类型为URL，后台任务进程参数为Integer，后台任务的返回结果为Long类型。注意一点：括号中的 … 表示参数个数不定，它代表一种数组型的参数，在这点上Java和C是一致的。</p>
<p>具体的AsyncTask类定义完成后，当要执行下载任务时，通过下面方式完成：</p>
</blockquote>
<pre><code>AsyncTask task = new DownloadAsyncTask();
task.execute(url1,url2,url3);
</code></pre><p><strong>AsyncTask在具体的使用过程中的一些条件限制：</strong></p>
<ol>
<li>AsyncTask的类必须在主线程中加载，这意味着第一次访问AsyncTask必须发生在主线程，当然这个过程在Android4.1及以上的版本中已经被系统自动完成。在5.0的源码中，可以看到在ActivityThread的main方法中会调用AsyncTask的init方法，这就满足了这个限制条件。至于为什么必须满足这个条件，在下面小节的原理分析中会给予解答。<ol>
<li>AsyncTask实现类的对象必须在主线程中创建。</li>
<li>AsyncTask实现类的execute()方法也必须在主线程中被调用。</li>
<li>不要在程序中手动直接调用onPreExecute(), doInBackground(), onPostExecute(), onProgressUpdate()这四个方法。</li>
<li>一个AsyncTask实现类对象只能执行一次，即只能调用一次execute()方法，否则会报异常。</li>
<li>Android1.6之前，AsyncTask是串行执行任务的，1.6的时候开始采用线程池处理并行任务，但是从3.0开始，为了避免AsyncTask所带来的并发错误，其又再一次采用一个线程来串行执行任务。尽管如此，3.0以后的版本中，我们仍然可以通过AsyncTask的executeOnExecuter方法来并行执行任务。</li>
</ol>
</li>
</ol>
<h4 id="AsyncTask的工作原理"><a href="#AsyncTask的工作原理" class="headerlink" title="AsyncTask的工作原理"></a>AsyncTask的工作原理</h4><blockquote>
<p>待完成</p>
</blockquote>
<h4 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h4><blockquote>
<p>HandlerThread继承了Thread，是一种可以使用Handler的Thread，它的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了。</p>
<p>HandlerThread的run方法如下所示：</p>
</blockquote>
<pre><code>public void run() {
    mTid = Process.myTid();
    Looper.prepare();
    synchrinized(this) {
        mLooper = Looper.myLooper();
        notifyAll();
    }
    Process.setThreadPriority(mPriority);
    onLooperPrepared();
    Looper.loop();
    mTid = -1;
}
</code></pre><blockquote>
<p>从HandlerThread的实现来看，它和普通的Thread有显著的不同，普通的Thread主要用于在run方法中执行一个耗时任务，而HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式来通知HandlerThread执行一个具体的任务。HandlerThread类是一个很有用的类，它在Android中的一个具体应用场景就是IntentService，将在下节介绍。由于HandlerThread的run方法是一个无限循环，因此当明确不需要再使用的时候，可以通过它的quit或者quitSafely方法来终止线程的执行，好的编程习惯。</p>
</blockquote>
<h4 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h4><blockquote>
<p>Todo</p>
</blockquote>
<h3 id="Android中的线程池"><a href="#Android中的线程池" class="headerlink" title="Android中的线程池"></a>Android中的线程池</h3><p><strong>线程池的优点</strong></p>
<ol>
<li>重用线程池中的线程，避免因为创建线程和销毁线程带来不必要的内存开销。</li>
<li>能有效控制线程池中的最大并发数，避免大量的线程之间因互相抢占资源而导致的阻塞现象。</li>
<li>能够对线程池进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ol>
<blockquote>
<p>Android中线程池的概念来自Java中的Executer，Executer是一个接口，真正的线程池实现为ThreadPoolExecuter，其提供了一系列的参数来配置线程池，通过不同的参数可以查创建不同的线程池。从线程池的功能特性上来说，Android的线程池有4类，并且可以通过Executers所提供的工厂方法来得到。</p>
</blockquote>
<h4 id="ThreadPoolExecuter"><a href="#ThreadPoolExecuter" class="headerlink" title="ThreadPoolExecuter"></a>ThreadPoolExecuter</h4><blockquote>
<p>ThreadPoolExecuter是线程池的真正实现，它的构造方法提供了一系列参数来配置线程池。下面是其一个比较常用的构造方法，构造方法中的参数会直接影响线程池的功能特性。</p>
</blockquote>
<pre><code>public ThreadPoolExecutor(
        int corePoolSize, 
        int maximumPoolSize, 
        long keepAliveTime, 
        TimeUnit unit, 
        BlockingQueue&lt;Runnable&gt; workQueue, 
        ThreadFactory threadFactory
)
</code></pre><blockquote>
<p>下面会介绍各个参数的具体用法</p>
</blockquote>
<ul>
<li>corePoolSize</li>
</ul>
<blockquote>
<p>线程池的核心线程数目，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔由keepAliveTime所指定，当等待时间超过keepAliveTime所指定的时长后，核心线程就会被终止。</p>
</blockquote>
<ul>
<li>maximumPoolSize</li>
</ul>
<blockquote>
<p>线程池所能容纳的最大线程数，当活动线程数达到这个数值后，后续的新任务将会被阻塞。</p>
</blockquote>
<ul>
<li>keepAliveTime</li>
</ul>
<blockquote>
<p>非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。当ThreadPoolExecutor的allowCoreThreadTimeOut这个属性设置为true时，keepAliveTime同样会作用于核心线程。</p>
</blockquote>
<ul>
<li>unit</li>
</ul>
<blockquote>
<p>用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的TimeUnit.MILLISECONDS(毫秒), TimeUnit.SECONDS(秒), TimeUnit.MINUTES(分钟)等。</p>
</blockquote>
<ul>
<li>workQueue</li>
</ul>
<blockquote>
<p>线程池中的任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中。</p>
</blockquote>
<ul>
<li>threadFactory</li>
</ul>
<blockquote>
<p>线程工厂，为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个方法，Thread  newThread(Runnable r).</p>
<p>除了上面的这些主要参数外，还有一个不常用的参数RejectedExecutionHandler handler。当线程池无法执行新任务时，这可能是由于任务队列已满或者是无法成功执行任务，这个时候ThreadPoolExecutor会调用handler的rejectedExecution方法来通知调用者，默认情况下rejectedExecution方法会直接抛出一个RejectedExecutionException。ThreadPoolExecutor为RejectedExecutionHandler提供了几个可选值：CallerRunsPolicy，AbortPolicy，DiscardPolicy和DiscardOldestPolicy，其中AbortPolicy是默认值，它会直接抛出RejectedExecutionException。</p>
<p>ThreadPoolExecutor执行任务时大致遵循如下规则：</p>
</blockquote>
<ol>
<li>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li>
<li>如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</li>
<li>如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</li>
<li>如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。</li>
</ol>
<blockquote>
<p>ThreadPoolExecutor的参数配置在AsyncTask中有明显的体现，如下：</p>
</blockquote>
<pre><code>private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
private static final int CORE_POOL_SIZE = CPU_COUNT + 1;
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE = 1;

private static final ThreadFactory sThreadFactory = new ThreadFactory() {
    private final AtomicInteger mCount = new AtomicInteger(1);
    public Thread newThread(Runnable r) {
        return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement());
    }
}

private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);

/**
 * An Executor that can be used to execute tasks in parallel
 **/
public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);
</code></pre><blockquote>
<p>从上面的代码可以知道，AsyncTask对THREAD_POOL_EXECUTOR这个线程池进行了配置，配置后的线程池规格如下：</p>
</blockquote>
<ul>
<li>核心线程池等于CPU核心数+1</li>
<li>线程池的最大线程数为CPU核心数的2倍+1</li>
<li>核心线程无超时机制，非核心线程在闲置时的超时时间为1秒</li>
<li>任务队列的容量为128</li>
</ul>
<h4 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h4><blockquote>
<p>Android中常见的四类不同功能特性的线程池，都是通过直接或间接的配置ThreadPoolExecutor的参数来实现具有不同功能特性的线程池。</p>
</blockquote>
<h5 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h5><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre><blockquote>
</blockquote>
<h5 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h5><pre><code>public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L,TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre><h5 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h5><pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
}

public static ScheduledThreadPoolExecutor (int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0 ,NANOSECONDS, new DelayedWorkQueue());
}
</code></pre><h5 id="SingleThreadPool"><a href="#SingleThreadPool" class="headerlink" title="SingleThreadPool"></a>SingleThreadPool</h5><pre><code>public static ExecutorService newSingleThreadPool() {
        return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre><p><strong>系统预置的四种线程池的典型使用方法</strong></p>
<pre><code>Runnable command = new Runnable() {
        @Override
        public void run() {
            SystemClock.sleep(2000);
        }
}

ExecutorService fixedThreadPool = Executors.newFixedThreadPool(4);
fixedThreadPool.execute(command);

ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
cachedThreadPool.execute(command);

ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(4);
// 2000ms后执行command
scheduledThreadPool.schedule(command, 2000, TimeUnit.MILLISECONDS);
// 延迟10ms后，每隔1000ms执行一次command
scheduledThreadPool.scheduleAtFixedRate(command, 10, 1000, TimeUnit.MILLISECONDS);

ExecutorService singleThreadPool = Executors.newSingleThreadPool();
singleThreadPool.execute(command);
</code></pre><p><strong>参考资料</strong></p>
<p>《Android开发艺术探索》 —  任玉刚</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>技术分享，感谢鼓励！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/uploads/images/wechat-reward-image.png" alt="QinPeng Zhu WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/uploads/images/alipay-reward-image.png" alt="QinPeng Zhu Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/笔记/" rel="tag">#笔记</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/05/Android消息处理机制 — 实用易懂/" rel="prev" title="Android消息处理机制 — 实用易懂">
                Android消息处理机制 — 实用易懂 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.gif"
               alt="QinPeng Zhu" />
          <p class="site-author-name" itemprop="name">QinPeng Zhu</p>
          <p class="site-description motion-element" itemprop="description">Android开发爱好者</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              大牛博客
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.liaoxuefeng.com/" title="廖雪峰" target="_blank">廖雪峰</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/singwhatiwanna" title="任玉刚" target="_blank">任玉刚</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/guolin_blog" title="郭霖" target="_blank">郭霖</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/eclipsexys" title="徐宜生" target="_blank">徐宜生</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://drakeet.me/" title="Drakeet" target="_blank">Drakeet</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://stormzhang.com/" title="stormzhang" target="_blank">stormzhang</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://gank.io/post/published" title="匠心写作" target="_blank">匠心写作</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://wuxiaolong.me/" title="吴小龙同学" target="_blank">吴小龙同学</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hukai.me/" title="胡凯" target="_blank">胡凯</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.ruanyifeng.com/blog/" title="阮一峰" target="_blank">阮一峰</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hujiaweibujidao.github.io/" title="hujiaweibujidao" target="_blank">hujiaweibujidao</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/luoyanglizi" title="lypeer" target="_blank">lypeer</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://kymjs.com/" title="张涛-开源实验室" target="_blank">张涛-开源实验室</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/njcit" title="有家客栈" target="_blank">有家客栈</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://zjutkz.net/" title="zjutkz's blog" target="_blank">zjutkz's blog</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/cym492224103" title="Chad.cym" target="_blank">Chad.cym</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/biezhihua" title="别志华" target="_blank">别志华</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.chengyunfeng.com/" title="云在千峰" target="_blank">云在千峰</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.apkdv.com/" title="LengYue" target="_blank">LengYue</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/u013022222" title="何以诚" target="_blank">何以诚</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.gcssloop.com/" title="GcsSloop" target="_blank">GcsSloop</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://tikitoo.github.io/" title="Tikitoo" target="_blank">Tikitoo</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/yayun0516" title="yayun" target="_blank">yayun</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.lightskystreet.com/" title="lightSky" target="_blank">lightSky</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blankj.com/" title="blankj" target="_blank">blankj</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://jayfeng.com/" title="杰风居" target="_blank">杰风居</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主线程和子线程"><span class="nav-number">2.</span> <span class="nav-text">主线程和子线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主线程"><span class="nav-number">2.1.</span> <span class="nav-text">主线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子线程"><span class="nav-number">2.2.</span> <span class="nav-text">子线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android中的线程形态"><span class="nav-number">3.</span> <span class="nav-text">Android中的线程形态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AsyncTask及其原理"><span class="nav-number">3.1.</span> <span class="nav-text">AsyncTask及其原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AsyncTask的工作原理"><span class="nav-number">3.2.</span> <span class="nav-text">AsyncTask的工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HandlerThread"><span class="nav-number">3.3.</span> <span class="nav-text">HandlerThread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IntentService"><span class="nav-number">3.4.</span> <span class="nav-text">IntentService</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android中的线程池"><span class="nav-number">4.</span> <span class="nav-text">Android中的线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecuter"><span class="nav-number">4.1.</span> <span class="nav-text">ThreadPoolExecuter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池的分类"><span class="nav-number">4.2.</span> <span class="nav-text">线程池的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FixedThreadPool"><span class="nav-number">4.2.1.</span> <span class="nav-text">FixedThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CachedThreadPool"><span class="nav-number">4.2.2.</span> <span class="nav-text">CachedThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ScheduledThreadPool"><span class="nav-number">4.2.3.</span> <span class="nav-text">ScheduledThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SingleThreadPool"><span class="nav-number">4.2.4.</span> <span class="nav-text">SingleThreadPool</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016.7.1 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QinPeng Zhu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
